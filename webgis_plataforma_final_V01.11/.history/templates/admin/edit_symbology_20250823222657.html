{% extends 'layout.html' %}
{% block content %}
<!-- Adicionar dados da empresa para JavaScript -->
<div id="company-data" data-company-slug="{{ current_user.company.slug if current_user.company else 'amplo' }}" style="display: none;"></div>

<style>
  #symbology-map {
    height: 50vh !important;
    min-height: 400px !important;
    width: 100% !important;
    z-index: 1;
    position: relative;
  }
  
  .leaflet-container {
    height: 100% !important;
    width: 100% !important;
  }
  
  .leaflet-control-attribution {
    font-size: 10px;
  }
  
  #palette-colors {
    flex-wrap: wrap;
  }
  
  #palette-colors div {
    margin-bottom: 5px;
  }
  
  .palette-preview-container {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 15px;
    margin-bottom: 15px;
  }
  
  /* Caixa explicativa compacta e horizontal - sempre visível */
  .method-info-compact {
    display: flex;
    align-items: flex-start;
    gap: 15px;
    padding: 16px 20px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e3f2fd 100%);
    border: 1px solid #0dcaf0;
    border-left: 4px solid #0dcaf0;
    border-radius: 8px;
    margin-top: 15px;
    margin-bottom: 20px;
    margin-left: 0;
    margin-right: 0;
    font-size: 0.8rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    width: 100%; /* Ocupa toda a largura da coluna col-md-12 */
    max-width: 100%;
    position: relative;
    left: 0;
    grid-column: 1 / -1; /* Estende por todas as colunas do grid */
    z-index: 10; /* Garante que fique acima de outros elementos */
    box-sizing: border-box; /* Inclui padding e border na largura total */
  }
  
  .method-info-compact .method-icon {
    font-size: 1rem;
    color: #0dcaf0;
    flex-shrink: 0;
  }
  
  .method-info-compact .method-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(13, 202, 240, 0.2);
  }
  
  .method-info-compact .method-title-section {
    flex: 1;
  }
  
  .method-info-compact .method-title {
    font-weight: 700;
    color: #0c63e4;
    margin-bottom: 4px;
    font-size: 1rem;
    letter-spacing: 0.5px;
  }
  
  .method-info-compact .method-description {
    color: #495057;
    line-height: 1.4;
    font-size: 0.85rem;
    font-style: italic;
  }
  
  .method-info-compact .method-content-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    width: 100%;
  }
  
  .method-info-compact .method-detail-card {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 6px;
    padding: 12px;
    border: 1px solid rgba(13, 202, 240, 0.15);
    transition: all 0.2s ease;
  }
  
  .method-info-compact .method-detail-card:hover {
    background: rgba(255, 255, 255, 0.9);
    border-color: rgba(13, 202, 240, 0.3);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  
  .method-info-compact .detail-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  
  .method-info-compact .detail-icon {
    font-size: 1rem;
    flex-shrink: 0;
  }
  
  .method-info-compact .detail-label {
    font-weight: 600;
    color: #0c63e4;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .method-info-compact .detail-text {
    color: #495057;
    font-size: 0.75rem;
    line-height: 1.4;
  }
  
  /* Ajuste para responsividade - comporta-se como col-md-12 */
  @media (max-width: 1200px) {
    .method-info-compact {
      margin-left: 0;
      margin-right: 0;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }
  }
  
  @media (max-width: 768px) {
    .method-info-compact {
      margin-left: 0;
      margin-right: 0;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }
  }
  
  /* Garante que a caixa se comporte exatamente como uma col-md-12 */
  .method-info-compact {
    flex: 0 0 100%;
    flex-basis: 100%;
    margin-left: 0;
    margin-right: 0;
  }

  /* Estilos para o select customizado de paletas */
  .custom-palette-select {
    position: relative;
    width: 100%;
  }

  .palette-select-header {
    background: #fff;
    border: 1px solid #ced4da;
    border-radius: 0.375rem;
    padding: 0.75rem 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
  }

  .palette-select-header:hover {
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
  }

  .palette-select-header:active {
    background-color: #f8f9fa;
  }

  .palette-select-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: #fff;
    border: 1px solid #ced4da;
    border-radius: 0.375rem;
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    z-index: 1000;
    max-height: 400px;
    overflow-y: auto;
  }

  .palette-options {
    padding: 0.5rem 0;
  }

  .palette-optgroup {
    margin-bottom: 1rem;
  }

  .palette-optgroup-label {
    padding: 0.5rem 1rem;
    font-weight: 600;
    color: #6c757d;
    background-color: #f8f9fa;
    border-bottom: 1px solid #dee2e6;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .palette-option {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    cursor: pointer;
    transition: background-color 0.15s ease;
    border-bottom: 1px solid #f8f9fa;
  }

  .palette-option:hover {
    background-color: #f8f9fa;
  }

  .palette-option:last-child {
    border-bottom: none;
  }

  .palette-preview-mini {
    width: 60px;
    height: 20px;
    border-radius: 4px;
    border: 1px solid #dee2e6;
    flex-shrink: 0;
    background: linear-gradient(to right, var(--color1), var(--color2), var(--color3), var(--color4), var(--color5), var(--color6), var(--color7), var(--color8));
  }

  .palette-option span {
    font-size: 0.875rem;
    color: #495057;
    flex: 1;
  }

  /* Filtros para diferentes tipos de simbologia */
  .palette-optgroup[data-type="qualitative"] {
    display: none;
  }

  .palette-optgroup[data-type="qualitative"].show-for-graduated {
    display: block;
  }
  
  /* Filtro para simbologia categorizada */
  .palette-optgroup[data-type="sequential"].show-for-categorized,
  .palette-optgroup[data-type="divergent"].show-for-categorized {
    display: none !important;
  }
  
  .palette-optgroup[data-type="qualitative"].show-for-categorized,
  .palette-optgroup[data-type="custom"].show-for-categorized {
    display: block !important;
  }
  
  /* Filtro para simbologia única */
  .palette-optgroup.show-for-single {
    display: block !important;
  }
  
  /* ===== MODAL DE CONFIRMAÇÃO CUSTOMIZADO ===== */
  .confirm-dialog-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.3s ease-out;
  }
  
  .confirm-dialog-content {
    background: linear-gradient(135deg, #ffffff, #f8f9fa);
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    width: 90%;
    max-width: 450px;
    position: relative;
    animation: slideInScale 0.4s ease-out;
    border: 2px solid var(--bs-primary);
  }
  
  .confirm-dialog-header {
    background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary));
    color: white;
    padding: 20px 25px;
    border-radius: 18px 18px 0 0;
    text-align: center;
    border-bottom: 3px solid #ffd700;
  }
  
  .confirm-dialog-header i {
    font-size: 32px;
    color: #ffd700;
    margin-bottom: 10px;
    display: block;
  }
  
  .confirm-dialog-header h4 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
    color: white;
  }
  
  .confirm-dialog-body {
    padding: 25px;
    text-align: center;
  }
  
  .confirm-dialog-body p {
    margin: 0;
    font-size: 16px;
    line-height: 1.5;
    color: #333;
  }
  
  .confirm-dialog-body strong {
    color: var(--bs-primary);
    font-weight: 700;
  }
  
  .confirm-dialog-footer {
    padding: 20px 25px;
    display: flex;
    gap: 15px;
    justify-content: center;
    border-top: 1px solid #e9ecef;
    background: #f8f9fa;
    border-radius: 0 0 18px 18px;
  }
  
  .confirm-dialog-footer button {
    padding: 12px 24px;
    border: none;
    border-radius: 25px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 120px;
    justify-content: center;
  }
  
  .confirm-dialog-footer .btn-cancel {
    background: #6c757d;
    color: white;
  }
  
  .confirm-dialog-footer .btn-cancel:hover {
    background: #5a6268;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
  }
  
  .confirm-dialog-footer .btn-confirm {
    background: var(--bs-primary);
    color: white;
  }
  
  .confirm-dialog-footer .btn-confirm:hover {
    background: #0056b3;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 123, 255, 0.4);
  }
  
  .confirm-dialog-footer button:active {
    transform: translateY(0);
  }
  
  /* ===== MODAL DE CRIAÇÃO DE PALETAS PERSONALIZADAS ===== */
  .custom-palette-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    animation: fadeIn 0.3s ease-out;
  }
  
  .custom-palette-modal-content {
    background: linear-gradient(135deg, #ffffff, #f8f9fa);
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    width: 90%;
    max-width: 800px;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
    animation: slideInScale 0.4s ease-out;
  }
  
  .custom-palette-modal-header {
    background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary));
    color: white;
    padding: 25px 30px;
    border-radius: 20px 20px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .custom-palette-modal-header h3 {
    margin: 0;
    font-size: 24px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .custom-palette-modal-header h3 i {
    font-size: 28px;
    color: #ffd700;
  }
  
  .btn-close-modal {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .btn-close-modal:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
  }
  
  .custom-palette-modal-body {
    padding: 30px;
  }
  
  .form-group {
    margin-bottom: 25px;
  }
  
  .form-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #333;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .form-group label i {
    color: var(--bs-primary);
    width: 16px;
  }
  
  .form-group input,
  .form-group select,
  .form-group textarea {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid #e9ecef;
    border-radius: 10px;
    font-size: 14px;
    transition: all 0.3s ease;
    background: white;
  }
  
  .form-group input:focus,
  .form-group select:focus,
  .form-group textarea:focus {
    outline: none;
    border-color: var(--bs-primary);
    box-shadow: 0 0 0 3px rgba(var(--bs-primary-rgb), 0.1);
  }
  
  .form-group textarea {
    resize: vertical;
    min-height: 60px;
  }
  
  /* Controles de quantidade de cores */
  .color-count-controls {
    display: flex;
    align-items: center;
    gap: 15px;
    background: #f8f9fa;
    padding: 15px;
    border-radius: 10px;
    border: 2px solid #e9ecef;
  }
  
  .btn-count {
    background: var(--bs-primary);
    color: white;
    border: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .btn-count:hover {
    background: var(--bs-primary);
    filter: brightness(0.9);
    transform: scale(1.1);
  }
  
  .btn-count:disabled {
    background: #6c757d;
    cursor: not-allowed;
    transform: none;
  }
  
  #color-count-display {
    font-size: 24px;
    font-weight: bold;
    color: var(--bs-primary);
    min-width: 30px;
    text-align: center;
  }
  
  .color-count-info {
    color: #6c757d;
    font-size: 12px;
    font-style: italic;
  }
  
  /* Preview da paleta personalizada */
  .palette-preview-container {
    background: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 15px;
    padding: 20px;
    margin-top: 15px;
  }
  
  .palette-preview {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
    min-height: 40px;
    align-items: center;
  }
  
  .preview-color {
    width: 30px;
    height: 30px;
    border-radius: 8px;
    border: 2px solid white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
  }
  
  .preview-color:hover {
    transform: scale(1.2);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.25);
    z-index: 10;
  }
  
  .preview-color::after {
    content: attr(title);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 5px 8px;
    border-radius: 4px;
    font-size: 11px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 1000;
  }
  
  .preview-color:hover::after {
    opacity: 1;
  }
  
  .palette-preview-info {
    text-align: center;
    padding-top: 10px;
    border-top: 1px solid #e9ecef;
  }
  
  .palette-preview-info small {
    color: #6c757d;
    font-size: 12px;
  }
  
  /* Container de cores */
  #palette-colors-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    margin-top: 15px;
    max-height: 400px;
    overflow-y: auto;
    padding-right: 10px;
  }
  
  /* Scrollbar personalizada para o container de cores */
  #palette-colors-container::-webkit-scrollbar {
    width: 8px;
  }
  
  #palette-colors-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }
  
  #palette-colors-container::-webkit-scrollbar-thumb {
    background: var(--bs-primary);
    border-radius: 4px;
  }
  
  #palette-colors-container::-webkit-scrollbar-thumb:hover {
    background: var(--bs-primary);
    filter: brightness(0.8);
  }
  
  .palette-color-item {
    background: white;
    border: 2px solid #e9ecef;
    border-radius: 15px;
    padding: 20px;
    transition: all 0.3s ease;
  }
  
  .palette-color-item:hover {
    border-color: var(--bs-primary);
    box-shadow: 0 5px 20px rgba(var(--bs-primary-rgb), 0.1);
    transform: translateY(-2px);
  }
  
  .color-item-header {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e9ecef;
  }
  
  .color-number {
    font-weight: 600;
    color: #333;
    font-size: 16px;
    text-align: center;
  }
  
  .color-inputs {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  
  .color-input-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  
  .color-input-group label {
    font-size: 12px;
    font-weight: 600;
    color: #666;
    margin: 0;
  }
  
  .color-input-group input {
    padding: 8px 12px;
    font-size: 13px;
  }
  
  .rgb-inputs {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
  }
  
  .rgb-inputs input {
    text-align: center;
    font-size: 12px;
    padding: 6px 8px;
  }
  
  /* Ferramentas rápidas */
  .quick-tools {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
    margin-top: 15px;
  }
  
  .btn-quick-tool {
    background: linear-gradient(135deg, #6c757d, #495057);
    color: white;
    border: none;
    padding: 12px 16px;
    border-radius: 10px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  
  .btn-quick-tool:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
  }
  
  .btn-quick-tool[data-action="generate-harmonious"] {
    background: linear-gradient(135deg, #28a745, #20c997);
  }
  
  .btn-quick-tool[data-action="generate-gradient"] {
    background: linear-gradient(135deg, #fd7e14, #e83e8c);
  }
  
  .btn-quick-tool[data-action="randomize"] {
    background: linear-gradient(135deg, #6f42c1, #e83e8c);
  }
  
  .btn-quick-tool[data-action="clear-all"] {
    background: linear-gradient(135deg, #dc3545, #c82333);
  }
  
  /* Footer do modal */
  .custom-palette-modal-footer {
    background: #f8f9fa;
    padding: 25px 30px;
    border-radius: 0 0 20px 20px;
    display: flex;
    justify-content: flex-end;
    gap: 15px;
    border-top: 1px solid #e9ecef;
  }
  
  .custom-palette-modal-footer .btn {
    padding: 12px 24px;
    border-radius: 10px;
    font-weight: 600;
    font-size: 14px;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .custom-palette-modal-footer .btn-secondary {
    background: #6c757d;
    color: white;
  }
  
  .custom-palette-modal-footer .btn-secondary:hover {
    background: #5a6268;
    transform: translateY(-1px);
  }
  
  .custom-palette-modal-footer .btn-primary {
    background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary));
    color: white;
  }
  
  .custom-palette-modal-footer .btn-primary:hover {
    background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary));
    filter: brightness(0.9);
    transform: translateY(-1px);
    box-shadow: 0 5px 15px rgba(var(--bs-primary-rgb), 0.3);
  }
  
  /* Animações */
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes slideInScale {
    from {
      opacity: 0;
      transform: scale(0.9) translateY(-20px);
    }
    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }
  
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }
  
  @keyframes slideOutScale {
    from {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
    to {
      opacity: 0;
      transform: scale(0.9) translateY(-20px);
    }
  }
  
  /* Responsividade */
  @media (max-width: 768px) {
    .custom-palette-modal-content {
      width: 95%;
      margin: 20px;
    }
    
    .custom-palette-modal-header {
      padding: 20px;
    }
    
    .custom-palette-modal-header h3 {
      font-size: 20px;
    }
  
    .custom-palette-modal-body {
      padding: 20px;
    }
    
    #palette-colors-container {
      grid-template-columns: 1fr;
      max-height: 300px;
    }
    
    .quick-tools {
      grid-template-columns: repeat(2, 1fr);
    }
    
    .custom-palette-modal-footer {
      flex-direction: column;
      padding: 20px;
    }
  }
  
  /* Para muitas cores, ajustar o grid */
  @media (min-width: 1200px) {
    #palette-colors-container {
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    }
  }
  
  /* Para telas muito pequenas */
  @media (max-width: 480px) {
    #palette-colors-container {
      grid-template-columns: 1fr;
      max-height: 250px;
    }
    
    .palette-color-item {
      padding: 15px;
    }
    
    .rgb-inputs {
      grid-template-columns: 1fr;
      gap: 5px;
    }
    
    .palette-preview-container {
      padding: 15px;
    }
    
    .preview-color {
      width: 25px;
      height: 25px;
    }
  }
  
  /* Animações para os modais */
  @keyframes modalSlideIn {
    from {
      opacity: 0;
      transform: translateY(-50px) scale(0.9);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }
  
  /* Estilos para os modais */
  .save-palette-modal,
  .manage-palettes-modal,
  .custom-palette-modal {
    animation: modalSlideIn 0.3s ease-out;
  }
  
  /* Hover effects para botões */
  .save-palette-modal button:hover,
  .manage-palettes-modal button:hover,
  .custom-palette-modal button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }
  
  /* Transições suaves */
  .save-palette-modal *,
  .manage-palettes-modal *,
  .custom-palette-modal * {
    transition: all 0.2s ease;
  }
  
  /* Scrollbar personalizada para os modais */
  .save-palette-modal ::-webkit-scrollbar,
  .manage-palettes-modal ::-webkit-scrollbar,
  .custom-palette-modal ::-webkit-scrollbar {
    width: 8px;
  }
  
  .save-palette-modal ::-webkit-scrollbar-track,
  .manage-palettes-modal ::-webkit-scrollbar-track,
  .custom-palette-modal ::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }
  
  .save-palette-modal ::-webkit-scrollbar-thumb,
  .manage-palettes-modal ::-webkit-scrollbar-thumb,
  .custom-palette-modal ::-webkit-scrollbar-thumb {
    background: var(--bs-primary);
    border-radius: 4px;
  }
  
  .save-palette-modal ::-webkit-scrollbar-thumb:hover,
  .manage-palettes-modal ::-webkit-scrollbar-thumb:hover,
  .custom-palette-modal ::-webkit-scrollbar-thumb:hover {
    background: var(--bs-primary-rgb, 0.8);
  }
  
  /* Estilos para interface de classes categorizadas */
  .categorized-class-item {
    transition: all 0.2s ease;
    border: 2px solid transparent;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .categorized-class-item:hover {
    border-color: #007bff;
    box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
  }
  
  .categorized-class-item.dragging {
    opacity: 0.5;
    transform: rotate(5deg);
    z-index: 1000;
  }
  
  .drag-handle {
    cursor: move;
    color: #6c757d;
    transition: color 0.2s ease;
  }
  
  .drag-handle:hover {
    color: #007bff;
  }
  
  .color-preview {
    transition: all 0.2s ease;
    cursor: pointer;
  }
  
  .color-preview:hover {
    transform: scale(1.1);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  }
  
  .categorized-class-rgb-inputs {
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    background: rgba(0,0,0,0.05);
    border-radius: 0.25rem;
    margin-top: 0.25rem;
  }
  
  /* Nova estrutura organizada */
  .category-header {
    border-bottom: 1px solid #e9ecef;
    padding-bottom: 0.5rem;
  }
  
  .control-section {
    background: rgba(0,0,0,0.02);
    border: 1px solid #e9ecef;
    border-radius: 0.375rem;
    padding: 0.75rem;
  }
  
  .section-header {
    color: #495057;
    border-bottom: 1px solid #dee2e6;
    padding-bottom: 0.25rem;
  }
  
  .section-header i {
    font-size: 0.875rem;
  }
  
  .line-controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 1rem;
    align-items: start;
  }
  
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }
  
  .control-group label {
    font-weight: 500;
    color: #495057;
  }
  
  /* Estilo antigo mantido para compatibilidade */
  .line-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
    padding: 0.5rem;
    background: rgba(0,123,255,0.05);
    border-radius: 0.25rem;
    margin-top: 0.25rem;
  }
  
  .line-spacing-slider {
    height: 4px;
    border-radius: 2px;
    background: #e9ecef;
    outline: none;
  }
  
  .line-spacing-slider::-webkit-slider-thumb {
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #007bff;
    cursor: pointer;
    border: 2px solid #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  }
  
  .line-spacing-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #007bff;
    cursor: pointer;
    border: 2px solid #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  }
  
  .line-spacing-slider:focus::-webkit-slider-thumb {
    background: #0056b3;
    box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
  }
  
  .line-spacing-slider:focus::-moz-range-thumb {
    background: #0056b3;
    box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
  }
  
  .line-spacing-value {
    font-weight: 500;
    color: #495057;
  }
  
  .line-spacing-controls {
    transition: all 0.3s ease;
  }
  
  .line-spacing-controls.hidden {
    display: none !important;
  }
  
  .row-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  
  .remove-category-btn {
    transition: all 0.2s ease;
  }
  
  .remove-category-btn:hover {
    background-color: #dc3545;
    border-color: #dc3545;
    color: white;
  }
  
  /* Drop zone visual feedback */
  .category-list {
    min-height: 100px;
    padding: 10px;
    border: 2px dashed transparent;
    transition: border-color 0.2s ease;
  }
  
  .category-list.drag-over {
    border-color: #007bff;
    background-color: rgba(0, 123, 255, 0.05);
  }
</style>
<h2>Simbologia: {{ layer.name }}</h2>
<div class="row">
  <div class="col-lg-6">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">Configurações de Simbologia</h5>
      </div>
      <div class="card-body">
        <!-- Abas para organizar simbologia e rótulos -->
        <ul class="nav nav-tabs" id="symbologyTabs" role="tablist">
          <li class="nav-item" role="presentation">
            <button class="nav-link active" id="symbology-tab" data-bs-toggle="tab" data-bs-target="#symbology-content" type="button" role="tab">
              <i class="fas fa-palette"></i> Simbologia
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="labels-tab" data-bs-toggle="tab" data-bs-target="#labels-content" type="button" role="tab">
              <i class="fas fa-font"></i> Rótulos
            </button>
          </li>
        </ul>
        
        <div class="tab-content mt-3" id="symbologyTabsContent">
          <!-- Aba de Simbologia -->
          <div class="tab-pane fade show active" id="symbology-content" role="tabpanel">
            <div class="row g-3">
              <div class="col-md-6">
                <label class="form-label">Tipo de Geometria</label>
                <select id="geom-type" class="form-select">
                  <option value="point">Ponto</option>
                  <option value="line">Linha</option>
                  <option value="polygon">Polígono</option>
                  <option value="raster">Raster</option>
                </select>
              </div>
              <div class="col-md-6">
                <label class="form-label">Campo para Simbologia</label>
                <select id="field-select" class="form-select">
                  <option value="">Selecione uma coluna...</option>
                </select>
              </div>
              <div class="col-md-12">
                <label for="style-type" class="form-label">Tipo de Simbologia</label>
                <select class="form-select" id="style-type">
                  <option value="single">Símbolo Único</option>
                  <option value="categorized">Categorizada</option>
                  <option value="graduated">Graduada</option>
                  <option value="raster">Raster</option>
                </select>
              </div>
              
              <!-- Blocos condicionais de simbologia -->
              <div class="col-md-4 d-none" id="block-classes">
                <label class="form-label">Número de classes</label>
                <input id="classes" type="number" class="form-control" min="2" max="20" value="5">
              </div>
              <div class="col-md-4 d-none" id="block-method">
                <label class="form-label">Método de Classificação</label>
                <select id="method" class="form-select">
                  <option value="equal">Intervalos Iguais</option>
                  <option value="quantiles">Quantis (Equal Count)</option>
                  <option value="jenks">Quebras Naturais (Jenks)</option>
                  <option value="log">Logarítmica</option>
                  <option value="stddev">Desvio Padrão</option>
                  <option value="arithmetic">Progressão Aritmética</option>
                  <option value="geometric">Progressão Geométrica</option>
                  <option value="manual">Manual</option>
                </select>
              </div>
              <div class="col-md-12 d-none" id="block-manual">
                <label class="form-label">Intervalos (separados por vírgula)</label>
                <input id="manual-breaks" class="form-control" placeholder="ex.: 0, 10, 25, 50, 100">
              </div>
              
              <!-- Caixa explicativa independente - APENAS para simbologia graduada -->
              <div id="method-info" class="method-info-compact d-none">
                <!-- As informações aparecerão aqui dinamicamente -->
              </div>
              
              <!-- Paleta de cores -->
              <div class="col-md-12" id="block-palette">
                <label class="form-label">Paleta de Cores</label>
                <small class="text-muted d-block mb-2">
                  <i class="fas fa-info-circle"></i> 
                  <strong>Distribuição Otimizada:</strong> A primeira classe sempre recebe a primeira cor da paleta, 
                  a última classe sempre recebe a última cor, e as classes intermediárias são distribuídas uniformemente 
                  entre os extremos para máxima variação visual.
                </small>
                <!-- Select customizado com previews de cores -->
                <div class="custom-palette-select mb-3">
                  <div class="palette-select-header" id="palette-select-header">
                    <div class="d-flex align-items-center justify-content-between w-100">
                      <span id="palette-select-text">Selecione uma paleta...</span>
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                  <div class="palette-select-dropdown d-none" id="palette-select-dropdown">
                    <div class="palette-options">
                      <div class="palette-optgroup" data-type="sequential">
                        <div class="palette-optgroup-label">Sequencial (Dados Quantitativos Ordenados)</div>
                        <div class="palette-option" data-value="Blues" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="Blues"></div>
                          <span>Blues - Água/Precipitação</span>
                        </div>
                        <div class="palette-option" data-value="Greens" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="Greens"></div>
                          <span>Greens - Vegetação/Agricultura</span>
                        </div>
                        <div class="palette-option" data-value="YlOrRd" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="YlOrRd"></div>
                          <span>YlOrRd - Calor/Densidade</span>
                        </div>
                        <div class="palette-option" data-value="Purples" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="Purples"></div>
                          <span>Purples - Magnitude</span>
                        </div>
                        <div class="palette-option" data-value="Greys" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="Greys"></div>
                          <span>Greys - Mapa Base</span>
                        </div>
                      </div>
                      <div class="palette-optgroup" data-type="divergent">
                        <div class="palette-optgroup-label">Divergente (Dados com Ponto Central)</div>
                        <div class="palette-option" data-value="Viridis" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="Viridis"></div>
                          <span>Viridis - Científica Moderna</span>
                        </div>
                        <div class="palette-option" data-value="Cividis" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="Cividis"></div>
                          <span>Cividis - Daltonismo Seguro</span>
                        </div>
                        <div class="palette-option" data-value="RdYlBu" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="RdYlBu"></div>
                          <span>RdYlBu - Anomalias (Seguro)</span>
                        </div>
                        <div class="palette-option" data-value="RdYlGn" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="RdYlGn"></div>
                          <span>RdYlGn - Clássica</span>
                        </div>
                        <div class="palette-option" data-value="BrBG" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="BrBG"></div>
                          <span>BrBG - Vegetação vs Solo</span>
                        </div>
                        <div class="palette-option" data-value="PiYG" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="PiYG"></div>
                          <span>PiYG - Alternativa Verde</span>
                        </div>
                        <div class="palette-option" data-value="Coolwarm" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="Coolwarm"></div>
                          <span>Coolwarm - Azul-Vermelho</span>
                        </div>
                        <div class="palette-option" data-value="Spectral" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="Spectral"></div>
                          <span>Spectral - Topografia</span>
                        </div>
                      </div>
                      <div class="palette-optgroup" data-type="qualitative">
                        <div class="palette-optgroup-label">Qualitativo (Dados Categóricos)</div>
                        <div class="palette-option" data-value="Vivid (Início Verde)" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="Vivid (Início Verde)"></div>
                          <span>Vivid (Início Verde) - Personalizada</span>
                        </div>
                        <div class="palette-option" data-value="Vivid (Início Azul)" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="Vivid (Início Azul)"></div>
                          <span>Vivid (Início Azul) - Personalizada</span>
                        </div>
                        <div class="palette-option" data-value="Tableau Tab10" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="Tableau Tab10"></div>
                          <span>Tableau Tab10 - Moderna</span>
                        </div>
                        <div class="palette-option" data-value="ColorBrewer Paired" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="ColorBrewer Paired"></div>
                          <span>ColorBrewer Paired - Pares</span>
                        </div>
                        <div class="palette-option" data-value="ColorBrewer Set3" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="ColorBrewer Set3"></div>
                          <span>ColorBrewer Set3 - Suave</span>
                        </div>
                      </div>
                      <div class="palette-optgroup" id="custom-palettes-group" data-type="custom">
                        <div class="palette-optgroup-label">Paletas Criadas pelo Usuário</div>
                        <!-- Paletas personalizadas serão adicionadas aqui dinamicamente -->
                      </div>
                    </div>
                  </div>
                  <!-- Input hidden para manter compatibilidade -->
                  <input type="hidden" id="palette-select" value="">
                </div>
                
                <!-- Controles para paletas personalizadas -->
                <div class="d-flex gap-2 mb-3">
                  <button type="button" id="btn-create-palette" class="btn btn-outline-primary btn-sm">
                    <i class="fas fa-plus"></i> Criar Nova Paleta
                  </button>
                  <button type="button" id="btn-save-current-palette" class="btn btn-outline-success btn-sm">
                    <i class="fas fa-save"></i> Salvar Paleta Atual
                  </button>
                  <button type="button" id="btn-manage-palettes" class="btn btn-outline-info btn-sm">
                    <i class="fas fa-cog"></i> Gerenciar Paletas
                  </button>
                </div>
                
                <!-- Visualização da paleta selecionada com nome -->
                <div id="palette-preview" class="palette-preview-container">
                  <div class="d-flex align-items-center gap-2 mb-2">
                    <label class="form-label mb-0 fw-bold">Paleta Selecionada:</label>
                    <span id="palette-name" class="badge bg-primary fs-6"></span>
                  </div>
                  <div class="mb-2">
                    <small class="text-muted">Clique nas cores para copiar o valor HEX</small>
                  </div>
                  <div id="palette-colors" class="d-flex gap-1 flex-wrap"></div>
                </div>
                

                
                <div class="row g-2">
                  <div class="col-md-6">
                    <label class="form-label">Opacidade da paleta</label>
                    <input id="palette-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="1">
                    <small class="text-muted">Valor: <span id="opacity-value">1.0</span></small>
                  </div>
                  <div class="col-md-6">
                    <div class="form-check form-switch mt-4">
                      <input class="form-check-input" type="checkbox" id="palette-invert">
                      <label class="form-check-label" for="palette-invert">Inverter ordem das cores</label>
                    </div>
                    <small class="text-muted d-block">Inverte a ordem das cores da paleta selecionada</small>
                  </div>
                </div>
                <div class="row g-2 mt-2">
                  <div class="col-md-6 d-none" id="block-polygon-border">
                    <label class="form-label">Cor da borda</label>
                    <input type="color" id="polygon-border-color" class="form-control form-control-color" value="#333333">
                    <label class="form-label mt-2">Espessura da borda</label>
                    <input type="number" id="polygon-border-width" class="form-control" min="0" max="10" value="2">
                    <div class="form-check form-switch mt-2">
                      <input class="form-check-input" type="checkbox" id="polygon-border-toggle" checked>
                      <label class="form-check-label" for="polygon-border-toggle">Exibir borda dos polígonos</label>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Editor de categorias -->
              <div class="col-md-12 d-none" id="block-category-editor">
                <div class="d-flex justify-content-between align-items-center mb-2">
                  <label class="form-label mb-0">Cores e Nomes das Classes</label>
                  <button type="button" class="btn btn-outline-warning btn-sm" onclick="resetCategorizedLegend()" title="Resetar legenda para o estado inicial">
                    <i class="fas fa-undo"></i> Resetar Legenda
                  </button>
                </div>
                <div class="alert alert-info">
                  <i class="fas fa-info-circle"></i>
                  <strong>Dica:</strong> Clique no nome da classe para editá-lo. As mudanças são aplicadas automaticamente ao mapa.
                </div>
                
                <!-- Controles específicos para linhas (apenas quando geom-type = line) -->
                <div class="col-md-12 d-none" id="block-line-specific-controls">
                  <div class="card border-info mb-3">
                    <div class="card-header bg-info text-white">
                      <h6 class="mb-0"><i class="fas fa-minus"></i> Controles Específicos para Linhas</h6>
                    </div>
                    <div class="card-body">
                      <div class="row g-3">
                        <div class="col-md-4">
                          <label class="form-label">Espessura Padrão das Linhas</label>
                          <input type="number" id="line-weight-default" class="form-control" value="2" min="1" max="10" step="0.5">
                          <small class="text-muted">Espessura padrão para todas as linhas (pode ser personalizada por categoria)</small>
                        </div>
                        <div class="col-md-4">
                          <label class="form-label">Opacidade Padrão das Linhas</label>
                          <input type="range" id="line-opacity-default" class="form-range" min="0" max="1" step="0.05" value="1">
                          <small class="text-muted">Valor: <span id="line-opacity-value">1.0</span></small>
                        </div>
                        <div class="col-md-4">
                          <label class="form-label">Estilo Padrão das Linhas</label>
                          <select id="line-style-default" class="form-select">
                            <option value="">Contínua (padrão)</option>
                            <option value="5,5">Tracejada (5,5)</option>
                            <option value="10,5">Tracejada Longa (10,5)</option>
                            <option value="2,2">Pontilhada (2,2)</option>
                            <option value="1,1">Pontilhada Fina (1,1)</option>
                            <option value="5,2,1,2">Traço-Ponto (5,2,1,2)</option>
                            <option value="10,2,1,2">Traço-Ponto Longo (10,2,1,2)</option>
                          </select>
                          <small class="text-muted">Estilo padrão para todas as linhas</small>
                        </div>
                      </div>
                      <div class="row g-3 mt-2">
                        <div class="col-md-12">
                          <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="line-allow-custom-per-category" checked>
                            <label class="form-check-label" for="line-allow-custom-per-category">
                              <strong>Permitir personalização individual por categoria</strong>
                            </label>
                            <small class="text-muted d-block">Quando marcado, cada categoria pode ter espessura, opacidade e estilo próprios</small>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <div id="category-list" class="d-flex flex-column gap-2"></div>
              </div>
              
              <!-- Editor de classes para simbologia graduada -->
              <div class="col-md-12 d-none" id="block-graduated-classes">
                <label class="form-label">Editor de Classes da Simbologia Graduada</label>
                <div class="alert alert-info">
                  <i class="fas fa-info-circle"></i>
                  <strong>Dica:</strong> Edite os nomes das classes para personalizar a legenda. As mudanças são aplicadas automaticamente.
                </div>
                
                <!-- Opção de legenda composta -->
                <div class="form-check form-switch mb-3">
                  <input class="form-check-input" type="checkbox" id="composite-legend-toggle" checked>
                  <label class="form-check-label" for="composite-legend-toggle">
                    <strong>Legenda Composta:</strong> Nome da classe + intervalo de valores
                  </label>
                  <small class="text-muted d-block">Exemplo: "Muito Bom - 1,0 a 1,80" (quando marcado) ou "1,0 a 1,80" (quando desmarcado)</small>
                </div>
                
                <div id="graduated-classes-list" class="d-flex flex-column gap-2"></div>
              </div>
              
              <!-- Cor personalizada (apenas Símbolo Único) -->
              <div class="col-md-12 d-none" id="block-custom-color">
                <label class="form-label">Cor Personalizada (apenas Símbolo Único)</label>
                <div class="row g-3">
                  <div class="col-md-6">
                    <label class="form-label">Borda</label>
                    <input id="stroke-color" type="color" class="form-control form-control-color" value="#333333">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Preenchimento</label>
                    <input id="fill-color" type="color" class="form-control form-control-color" value="#38bdf8">
                  </div>
                </div>
                <div class="row g-3 mt-2">
                  <div class="col-md-6">
                    <label class="form-label">Espessura</label>
                    <input id="stroke-weight" type="number" class="form-control" value="2" min="0" max="10">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Opacidade</label>
                    <input id="fill-opacity" type="number" class="form-control" value="0.3" step="0.05" min="0" max="1">
                  </div>
                </div>
                <div class="row g-3 mt-2" id="block-point-only">
                  <div class="col-md-6">
                    <label class="form-label">Raio (ponto)</label>
                    <input id="point-radius" type="number" class="form-control" value="6" min="1" max="50">
                  </div>
                </div>
                <div class="row g-3 mt-2 d-none" id="block-line-only">
                  <div class="col-md-6">
                    <label class="form-label">Opacidade da linha</label>
                    <input id="line-opacity" type="number" class="form-control" value="1" step="0.05" min="0" max="1">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Tracejado</label>
                    <input id="line-dash" class="form-control" placeholder="ex.: 4,2 (padrão: contínua)">
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Aba de Rótulos -->
          <div class="tab-pane fade" id="labels-content" role="tabpanel">
            <div class="row g-3">
              <!-- Configurações Gerais -->
              <div class="col-md-12">
                <div class="card border-primary">
                  <div class="card-header bg-primary text-white">
                    <h6 class="mb-0"><i class="fas fa-font"></i> Configurações Gerais</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="labels-enabled" checked>
                          <label class="form-check-label" for="labels-enabled">
                            <strong>Habilitar Rótulos</strong>
                          </label>
                          <small class="text-muted d-block">Marque para exibir rótulos na camada</small>
                        </div>
                      </div>
                      
                      <div class="col-md-6">
                        <label class="form-label">Campo para Rótulo</label>
                        <select id="label-field-select" class="form-select">
                          <option value="">Selecione uma coluna...</option>
                        </select>
                      </div>
                      <div class="col-md-6">
                        <label class="form-label">Fonte</label>
                        <select id="label-font" class="form-select">
                          <option value="Arial">Arial</option>
                          <option value="Helvetica">Helvetica</option>
                          <option value="Times New Roman">Times New Roman</option>
                          <option value="Georgia">Georgia</option>
                          <option value="Verdana">Verdana</option>
                          <option value="Courier New">Courier New</option>
                          <option value="Roboto">Roboto</option>
                          <option value="Open Sans">Open Sans</option>
                          <option value="Lato">Lato</option>
                          <option value="Montserrat">Montserrat</option>
                        </select>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Aparência do Texto -->
              <div class="col-md-12">
                <div class="card border-info">
                  <div class="card-header bg-info text-white">
                    <h6 class="mb-0"><i class="fas fa-palette"></i> Aparência do Texto</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-4">
                        <label class="form-label">Tamanho da Fonte</label>
                        <input id="label-size" type="number" class="form-control" min="8" max="72" value="12">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Cor do Texto</label>
                        <input id="label-color" type="color" class="form-control form-control-color" value="#000000">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Opacidade do Texto</label>
                        <input id="label-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="1">
                        <small class="text-muted">Valor: <span id="text-opacity-value">1.0</span></small>
                      </div>
                      
                      <div class="col-md-3">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-bold">
                          <label class="form-check-label" for="label-bold">Negrito</label>
                        </div>
                      </div>
                      <div class="col-md-3">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-italic">
                          <label class="form-check-label" for="label-italic">Itálico</label>
                        </div>
                      </div>
                      <div class="col-md-3">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-underline">
                          <label class="form-check-label" for="label-underline">Sublinhado</label>
                        </div>
                      </div>
                      <div class="col-md-3">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-uppercase">
                          <label class="form-check-label" for="label-uppercase">MAIÚSCULA</label>
                        </div>
                      </div>

                      <div class="col-md-6">
                        <label class="form-label">Rotação do Texto (graus)</label>
                        <input id="label-rotation" type="range" class="form-range" min="0" max="360" step="5" value="0">
                        <small class="text-muted">Valor: <span id="rotation-value">0°</span></small>
                      </div>
                      <div class="col-md-6">
                        <label class="form-label">Alinhamento</label>
                        <select id="label-alignment" class="form-select">
                          <option value="center">Centro</option>
                          <option value="left">Esquerda</option>
                          <option value="right">Direita</option>
                          <option value="top">Superior</option>
                          <option value="bottom">Inferior</option>
                          <option value="top-left">Superior Esquerda</option>
                          <option value="top-right">Superior Direita</option>
                          <option value="bottom-left">Inferior Esquerda</option>
                          <option value="bottom-right">Inferior Direita</option>
                        </select>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Buffer e Contorno -->
              <div class="col-md-12">
                <div class="card border-warning">
                  <div class="card-header bg-warning text-dark">
                    <h6 class="mb-0"><i class="fas fa-circle-notch"></i> Buffer e Contorno</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-buffer-enabled" checked>
                          <label class="form-check-label" for="label-buffer-enabled">
                            <strong>Habilitar Buffer</strong>
                          </label>
                          <small class="text-muted d-block">Buffer melhora a legibilidade do texto sobre fundos complexos</small>
                        </div>
                      </div>
                      
                      <div class="col-md-4">
                        <label class="form-label">Cor do Buffer</label>
                        <input id="label-buffer-color" type="color" class="form-control form-control-color" value="#ffffff">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Tamanho do Buffer</label>
                        <input id="label-buffer-size" type="number" class="form-control" min="0" max="20" value="2" step="0.5">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Opacidade do Buffer</label>
                        <input id="label-buffer-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="0.8">
                        <small class="text-muted">Valor: <span id="buffer-opacity-value">0.8</span></small>
                      </div>

                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-stroke-enabled">
                          <label class="form-check-label" for="label-stroke-enabled">
                            <strong>Habilitar Contorno</strong>
                          </label>
                          <small class="text-muted d-block">Contorno adiciona uma borda ao redor do texto</small>
                        </div>
                      </div>

                      <div class="col-md-4">
                        <label class="form-label">Cor do Contorno</label>
                        <input id="label-stroke-color" type="color" class="form-control form-control-color" value="#000000">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Espessura do Contorno</label>
                        <input id="label-stroke-width" type="number" class="form-control" min="0" max="10" value="1" step="0.5">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Opacidade do Contorno</label>
                        <input id="label-stroke-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="1">
                        <small class="text-muted">Valor: <span id="stroke-opacity-value">1.0</span></small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Posicionamento e Deslocamento -->
              <div class="col-md-12">
                <div class="card border-success">
                  <div class="card-header bg-success text-white">
                    <h6 class="mb-0"><i class="fas fa-arrows-alt"></i> Posicionamento e Deslocamento</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-6">
                        <label class="form-label">Deslocamento X (pixels)</label>
                        <input id="label-offset-x" type="number" class="form-control" min="-100" max="100" value="0">
                        <small class="text-muted">Valores negativos movem para esquerda, positivos para direita</small>
                      </div>
                      <div class="col-md-6">
                        <label class="form-label">Deslocamento Y (pixels)</label>
                        <input id="label-offset-y" type="number" class="form-control" min="-100" max="100" value="0">
                        <small class="text-muted">Valores negativos movem para cima, positivos para baixo</small>
                      </div>

                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-collision-detection" checked>
                          <label class="form-check-label" for="label-collision-detection">
                            <strong>Detecção de Sobreposição</strong>
                          </label>
                          <small class="text-muted d-block">Evita sobreposição automática de rótulos</small>
                        </div>
                      </div>

                      <div class="col-md-4">
                        <label class="form-label">Distância Mínima (pixels)</label>
                        <input id="label-min-distance" type="number" class="form-control" min="0" max="100" value="10">
                        <small class="text-muted">Distância mínima entre rótulos</small>
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Prioridade</label>
                        <select id="label-priority" class="form-select">
                          <option value="high">Alta</option>
                          <option value="medium" selected>Média</option>
                          <option value="low">Baixa</option>
                        </select>
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Máximo por Tela</label>
                        <input id="label-max-per-screen" type="number" class="form-control" min="0" max="1000" value="100">
                        <small class="text-muted">0 = ilimitado</small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Setas e Linhas de Chamada -->
              <div class="col-md-12">
                <div class="card border-secondary">
                  <div class="card-header bg-secondary text-white">
                    <h6 class="mb-0"><i class="fas fa-long-arrow-alt-right"></i> Setas e Linhas de Chamada</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-callout-enabled">
                          <label class="form-check-label" for="label-callout-enabled">
                            <strong>Habilitar Linhas de Chamada</strong>
                          </label>
                          <small class="text-muted d-block">Conecta rótulos deslocados ao ponto original com setas</small>
                        </div>
                      </div>

                      <div class="col-md-3">
                        <label class="form-label">Cor da Linha</label>
                        <input id="label-callout-color" type="color" class="form-control form-control-color" value="#666666">
                      </div>
                      <div class="col-md-3">
                        <label class="form-label">Espessura da Linha</label>
                        <input id="label-callout-width" type="number" class="form-control" min="0.5" max="10" value="1" step="0.5">
                      </div>
                      <div class="col-md-3">
                        <label class="form-label">Estilo da Linha</label>
                        <select id="label-callout-style" class="form-select">
                          <option value="solid">Sólida</option>
                          <option value="dashed">Tracejada</option>
                          <option value="dotted">Pontilhada</option>
                        </select>
                      </div>
                      <div class="col-md-3">
                        <label class="form-label">Opacidade da Linha</label>
                        <input id="label-callout-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="0.7">
                        <small class="text-muted">Valor: <span id="callout-opacity-value">0.7</span></small>
                      </div>

                      <div class="col-md-4">
                        <label class="form-label">Tipo de Seta</label>
                        <select id="label-arrow-type" class="form-select">
                          <option value="none">Sem Seta</option>
                          <option value="simple" selected>Seta Simples</option>
                          <option value="filled">Seta Preenchida</option>
                          <option value="double">Seta Dupla</option>
                          <option value="circle">Círculo</option>
                        </select>
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Tamanho da Seta</label>
                        <input id="label-arrow-size" type="number" class="form-control" min="2" max="20" value="6">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Distância Máxima</label>
                        <input id="label-callout-max-distance" type="number" class="form-control" min="10" max="200" value="50">
                        <small class="text-muted">Distância máxima da linha de chamada</small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Filtros e Condições -->
              <div class="col-md-12">
                <div class="card border-dark">
                  <div class="card-header bg-dark text-white">
                    <h6 class="mb-0"><i class="fas fa-filter"></i> Filtros e Condições</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-6">
                        <label class="form-label">Zoom Mínimo</label>
                        <input id="label-min-zoom" type="number" class="form-control" min="1" max="20" value="1">
                        <small class="text-muted">Zoom mínimo para exibir rótulos</small>
                      </div>
                      <div class="col-md-6">
                        <label class="form-label">Zoom Máximo</label>
                        <input id="label-max-zoom" type="number" class="form-control" min="1" max="20" value="20">
                        <small class="text-muted">Zoom máximo para exibir rótulos</small>
                      </div>

                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-filter-enabled">
                          <label class="form-check-label" for="label-filter-enabled">
                            <strong>Habilitar Filtro por Expressão</strong>
                          </label>
                          <small class="text-muted d-block">Exibe rótulos apenas para features que atendem a condição</small>
                        </div>
                      </div>

                      <div class="col-md-12">
                        <label class="form-label">Expressão de Filtro</label>
                        <textarea id="label-filter-expression" class="form-control" rows="2" placeholder="Ex: valor > 100 OR categoria = 'importante'"></textarea>
                        <small class="text-muted">Use operadores: >, <, =, !=, AND, OR, LIKE</small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Botões de Ação -->
              <div class="col-md-12 mt-4">
                <div class="d-flex gap-2">
                  <button type="button" id="btn-apply-labels" class="btn btn-success">
                    <i class="fas fa-font"></i> Aplicar Rótulos
                  </button>
                  <button type="button" id="btn-preview-labels" class="btn btn-info">
                    <i class="fas fa-eye"></i> Pré-visualizar
                  </button>
                  <button type="button" id="btn-reset-labels" class="btn btn-warning">
                    <i class="fas fa-undo"></i> Resetar
                  </button>
                </div>
                <small class="text-muted d-block mt-1">Clique em "Aplicar Rótulos" para salvar as configurações no mapa</small>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    <div class="col-lg-6">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0">Pré-visualização</h5>
        </div>
        <div class="card-body">
          <div class="d-flex justify-content-between align-items-center mb-3">
            <button id="btn-apply" class="btn btn-primary btn-sm">Aplicar Simbologia</button>
            <a class="btn btn-secondary btn-sm" href="{{ url_for('admin_dashboard') }}">Cancelar</a>
          </div>
          <div class="mb-2">
            <label class="form-label">Basemap:</label>
            <select id="basemap-select" class="form-select form-select-sm">
              <option value="osm">OpenStreetMap</option>
              <option value="google-streets">Google Streets</option>
              <option value="google-satellite">Google Satellite</option>
              <option value="google-hybrid">Google Hybrid</option>
              <option value="google-terrain">Google Terrain</option>
            </select>
          </div>
          <div id="symbology-map" style="height: 50vh; min-height: 400px; width: 100%;" class="mb-3 border rounded"></div>
          <div id="preview-legend" class="mb-2"></div>
          <div class="text-muted small">A legenda acima reflete a configuração atual e será exibida no portal.</div>
        </div>
      </div>
    </div>
  </div>


  </div>
</div>
{% endblock %}
{% block scripts %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  let map, layerData, currentLayer, currentBasemap;
  const layerId = {{ layer.id }};
  
  // Paletas de Cores Aprovadas para WebGIS
  const paletasAprovadas = {
    "sequencial": {
      "Viridis": ['#440154', '#472d7b', '#3b528b', '#2c728e', '#21918c', '#28ae80', '#5ec962', '#addc30', '#fde725'],
      "Cividis": ['#00224e', '#1a386f', '#434e6c', '#61656f', '#7d7c78', '#9b9476', '#bcae6c', '#dec958', '#fee838'],
      "Blues": ['#f7fbff', '#deebf7', '#c6dbef', '#9dcae1', '#6aaed6', '#4191c6', '#2070b4', '#08509b', '#08306b'],
      "Greens": ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a0d99b', '#73c476', '#40aa5d', '#228a44', '#006c2c', '#00441b'],
      "YlOrRd": ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8c3c', '#fc4d2a', '#e2191c', '#bb0026', '#800026'],
      "Purples": ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807cba', '#6950a3', '#53268f', '#3f007d'],
      "Greys": ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#959595', '#727272', '#515151', '#242424', '#000000']
    },
    "divergente": {
      "RdYlBu": ['#a50026', '#d62f27', '#f46d43', '#fdad60', '#fee090', '#feffc0', '#e0f3f8', '#aad8e9', '#74add1', '#4574b3', '#313695'],
      "RdYlGn": ['#a50026', '#d62f27', '#f46d43', '#fdad60', '#fee08b', '#feffbe', '#d9ef8b', '#a5d86a', '#66bd63', '#199750', '#006837'],
      "BrBG": ['#543005', '#8b500a', '#bf812d', '#dec17b', '#f6e8c3', '#f4f5f5', '#c7eae5', '#7fccc0', '#35978f', '#01655d', '#003c30'],
      "PiYG": ['#8e0152', '#c41a7c', '#de77ae', '#f1b5d9', '#fde0ef', '#f7f7f6', '#e6f5d0', '#b7e085', '#7fbc41', '#4c9121', '#276419'],
      "Coolwarm": ['#3b4cc0', '#5977e3', '#7b9ff9', '#9ebeff', '#c0d4f5', '#dddcdc', '#f2cbb7', '#f7ac8e', '#ee8468', '#d65244', '#b40426'],
      "Spectral": ['#9e0142', '#d43d4f', '#f46d43', '#fdad60', '#fee08b', '#ffffbe', '#e6f598', '#abdda4', '#66c2a5', '#3387bc', '#5e4fa2']
    },
    "qualitativo": {
      "Vivid (Início Verde)": ['#16d916', '#16d98b', '#16b2d9', '#163dd9', '#6416d9', '#d916d9', '#d91664', '#d93d16', '#d9b216', '#8bd916'],
      "Vivid (Início Azul)": ['#1616d9', '#8b16d9', '#d916b2', '#d9163d', '#d96416', '#d9d916', '#64d916', '#16d93d', '#16d9b2', '#168bd9'],
      "Tableau Tab10": ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
      "ColorBrewer Paired": ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a6a6a', '#ffff99', '#b15928'],
      "ColorBrewer Set3": ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f']
    }
  };

  // Paletas ColorBrewer expandidas (mantidas para compatibilidade)
  const colorBrewer = {
    sequential: ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'BuGn', 'BuPu', 'GnBu', 'OrRd', 'PuBu', 'PuRd', 'RdPu', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd'],
    diverging: ['RdBu', 'RdYlBu', 'RdYlGn', 'BrBG', 'PiYG', 'PRGn', 'PuOr', 'Spectral'],
    qualitative: ['Set1', 'Set2', 'Set3', 'Paired', 'Accent', 'Dark2', 'Pastel1', 'Pastel2', 'tab10', 'tab20', 'tab20b', 'tab20c']
  };

  // Função para gerar cores únicas baseadas em HSL
  function generateUniqueColors(count) {
    // Limitar a 1000 cores para performance
    const maxCount = Math.min(count, 1000);
    const colors = [];
    const hueStep = 360 / maxCount;
    const saturation = 70; // 70% saturation
    const lightness = 60;  // 60% lightness
    
    for (let i = 0; i < maxCount; i++) {
      const hue = (i * hueStep) % 360;
      colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
    }
    return colors;
  }
  
  // Função para expandir paleta para qualquer número de cores usando interpolação
  function expandPalette(paletteColors, targetCount) {
    // Limitar a 1000 cores para performance
    const maxTargetCount = Math.min(targetCount, 1000);
    
    if (maxTargetCount <= paletteColors.length) {
      return paletteColors;
    }
    
    const colors = [];
    const step = (paletteColors.length - 1) / (maxTargetCount - 1);
    
    for (let i = 0; i < maxTargetCount; i++) {
      const index = i * step;
      const lowerIndex = Math.floor(index);
      const upperIndex = Math.min(lowerIndex + 1, paletteColors.length - 1);
      const fraction = index - lowerIndex;
      
      if (fraction === 0) {
        colors.push(paletteColors[lowerIndex]);
      } else {
        const lowerColor = hexToRgb(paletteColors[lowerIndex]);
        const upperColor = hexToRgb(paletteColors[upperIndex]);
        
        if (lowerColor && upperColor) {
          const r = Math.round(lowerColor.r + (upperColor.r - lowerColor.r) * fraction);
          const g = Math.round(lowerColor.g + (upperColor.g - lowerColor.g) * fraction);
          const b = Math.round(lowerColor.b + (upperColor.b - lowerColor.b) * fraction);
          colors.push(rgbToHex(r, g, b));
        } else {
          colors.push(paletteColors[lowerIndex]);
        }
      }
    }
    
    return colors;
  }

  // Função para converter HSL para HEX
  function hslToHex(h, s, l) {
    s /= 100;
    l /= 100;
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h / 60) % 2 - 1));
    const m = l - c/2;
    let r = 0, g = 0, b = 0;
    if (0 <= h && h < 60) {
      r = c; g = x; b = 0;
    } else if (60 <= h && h < 120) {
      r = x; g = c; b = 0;
    } else if (120 <= h && h < 180) {
      r = 0; g = c; b = x;
    } else if (180 <= h && h < 240) {
      r = 0; g = x; b = c;
    } else if (240 <= h && h < 300) {
      r = x; g = 0; b = c;
    } else if (300 <= h && h < 360) {
      r = c; g = 0; b = x;
    }
    const rHex = Math.round((r + m) * 255).toString(16).padStart(2, '0');
    const gHex = Math.round((g + m) * 255).toString(16).padStart(2, '0');
    const bHex = Math.round((b + m) * 255).toString(16).padStart(2, '0');
    return `#${rHex}${gHex}${bHex}`;
  }

  // Função para converter HEX para RGB
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  // Função para converter RGB para HEX
  function rgbToHex(r, g, b) {
    const toHex = (n) => {
      const hex = Math.max(0, Math.min(255, n)).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }

  // Função para validar código HEX
  function isValidHex(hex) {
    return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);
  }

  // Função para limpar cores personalizadas de um campo
  function clearCustomColors(field) {
    if (field) {
      let clearedCount = 0;
      
      // Limpar cores personalizadas da simbologia graduada
      for (let i = 0; i < 20; i++) { // Limpar até 20 classes para garantir
        if (localStorage.getItem(`graduated_class_color_${layerId}_${field}_${i}`)) {
          localStorage.removeItem(`graduated_class_color_${layerId}_${field}_${i}`);
          clearedCount++;
        }
      }
      
      // Limpar cores personalizadas das categorias da legenda composta
      const categoryColors = Object.keys(localStorage).filter(key => 
        key.startsWith(`category_color_${layerId}_`)
      );
      
      categoryColors.forEach(key => {
        localStorage.removeItem(key);
        clearedCount++;
      });
      
      // Mostrar notificação se cores foram limpas
      if (clearedCount > 0) {
        showToast(`Cores personalizadas resetadas para a nova paleta selecionada`, 'info');
      }
    }
  }

  // Função para atualizar cor de uma classe
  function updateClassColor(index, newColor) {
    // Atualizar preview da cor
    const colorPreview = document.querySelector(`.color-preview[data-index="${index}"]`);
    if (colorPreview) {
      colorPreview.style.backgroundColor = newColor;
    }
    
    // Atualizar seletor de cor
    const colorInput = document.querySelector(`.graduated-class-color[data-index="${index}"]`);
    if (colorInput) {
      colorInput.value = newColor;
    }
    
    // Atualizar campo HEX
    const hexInput = document.querySelector(`.graduated-class-hex[data-index="${index}"]`);
    if (hexInput) {
      hexInput.value = newColor;
    }
    
    // Atualizar campos RGB
    const rgb = hexToRgb(newColor);
    if (rgb) {
      const rgbInputs = document.querySelector(`.graduated-class-rgb-inputs[data-index="${index}"]`);
      if (rgbInputs) {
        const rInput = rgbInputs.querySelector('input[placeholder="R"]');
        const gInput = rgbInputs.querySelector('input[placeholder="G"]');
        const bInput = rgbInputs.querySelector('input[placeholder="B"]');
        if (rInput) rInput.value = rgb.r;
        if (gInput) gInput.value = rgb.g;
        if (bInput) bInput.value = rgb.b;
      }
    }
    
    // Salvar cor personalizada no localStorage
    const field = document.getElementById('field-select').value;
    localStorage.setItem(`graduated_class_color_${layerId}_${field}_${index}`, newColor);
    
    // Atualizar preview do mapa
    renderMapPreview();
    
    // Forçar atualização da legenda
    setTimeout(() => {
      renderPreview();
    }, 100);
    
    // Salvar configuração
    saveUserConfig();
  }

  // Função para gerar cores da paleta com distribuição otimizada (usando paletas aprovadas primeiro)
  function brewer(palette, count, invert = false) {
    // Função auxiliar para distribuir cores de forma otimizada
    function distributeColorsOptimally(paletteColors, numClasses) {
      if (numClasses <= 0) return [];
      if (numClasses === 1) return [paletteColors[0]];
      if (numClasses === 2) return [paletteColors[0], paletteColors[paletteColors.length - 1]];
      
      // Limitar a 1000 classes para performance
      const maxClasses = Math.min(numClasses, 1000);
      
      const result = [];
      result.push(paletteColors[0]); // Primeira classe sempre recebe primeira cor
      
      // Distribuir cores intermediárias uniformemente
      if (maxClasses > 2) {
        const step = (paletteColors.length - 1) / (maxClasses - 1);
        for (let i = 1; i < maxClasses - 1; i++) {
          const index = Math.round(i * step);
          result.push(paletteColors[index]);
        }
      }
      
      result.push(paletteColors[paletteColors.length - 1]); // Última classe sempre recebe última cor
      
      return result;
    }
    
    // Primeiro, tentar usar as paletas aprovadas
    for (const category in paletasAprovadas) {
      if (paletasAprovadas[category][palette]) {
        const paletteColors = paletasAprovadas[category][palette];
        // Expandir paleta para o número de cores solicitado (até 1000)
        const expandedColors = expandPalette(paletteColors, Math.min(count, 1000));
        let selectedColors = distributeColorsOptimally(expandedColors, Math.min(count, 1000));
        if (invert) {
          selectedColors = selectedColors.reverse();
        }
        return selectedColors;
      }
    }
    
    // Segundo, tentar usar paletas personalizadas
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    const customPalette = customPalettes.find(p => p.name === palette);
    if (customPalette) {
      const paletteColors = customPalette.colors;
      // Expandir paleta para o número de cores solicitado (até 1000)
      const expandedColors = expandPalette(paletteColors, Math.min(count, 1000));
      let selectedColors = distributeColorsOptimally(expandedColors, Math.min(count, 1000));
      if (invert) {
        selectedColors = selectedColors.reverse();
      }
      return selectedColors;
    }
    
    // Fallback para paletas ColorBrewer originais
    const palettes = {
      // Sequential palettes
      'viridis': ['#440154', '#482878', '#3e4989', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6ece58', '#b5de2b', '#fde725'],
      'plasma': ['#0d0887', '#41049d', '#6a00a8', '#8f0aa4', '#b12a90', '#cc4778', '#e16462', '#f1834b', '#fca636', '#fcce25'],
      'inferno': ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c5c', '#cf4446', '#ed6925', '#f58b49', '#fdb42f', '#fce762'],
      'magma': ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c5c', '#cf4446', '#ed6925', '#f58b49', '#fdb42f', '#fce762'],
      'cividis': ['#00224f', '#123a5a', '#2d4f69', '#446475', '#5b7a7c', '#729083', '#8aa68a', '#a3bc93', '#bdd3a8', '#d8e5be'],
      'Blues': ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
      'Greens': ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
      'Reds': ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
      'Oranges': ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#e6550d', '#a63603', '#7f2704'],
      'Purples': ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
      
      // Diverging palettes
      'RdBu': ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
      'RdYlBu': ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
      'RdYlGn': ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
      'BrBG': ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
      'PiYG': ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
      'PRGn': ['#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
      'PuOr': ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
      'Spectral': ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
      
      // Qualitative palettes
      'Set1': ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
      'Set2': ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
      'Set3': ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
      'Paired': ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a6a6a', '#ffff99', '#b15928'],
      'Accent': ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
      'Dark2': ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
      'Pastel1': ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
      'Pastel2': ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
      'tab10': ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
      'tab20': ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'],
      'tab20b': ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'],
      'tab20c': ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9']
    };
    
    if (palettes[palette]) {
      const paletteColors = palettes[palette];
      // Expandir paleta para o número de cores solicitado (até 1000)
      const expandedColors = expandPalette(paletteColors, Math.min(count, 1000));
      let selectedColors = distributeColorsOptimally(expandedColors, Math.min(count, 1000));
      if (invert) {
        selectedColors = selectedColors.reverse();
        // Manter a lógica de extremos mesmo após inversão
        if (count > 2) {
          const temp = selectedColors[0];
          selectedColors[0] = selectedColors[selectedColors.length - 1];
          selectedColors[selectedColors.length - 1] = temp;
        }
      }
      return selectedColors;
    }
    
    // Fallback para cores únicas (limitado a 1000 cores)
    const maxCount = Math.min(count, 1000);
    let fallbackColors = generateUniqueColors(maxCount).map(color => {
      const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
      if (match) {
        return hslToHex(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
      }
      return color;
    });
    
    if (invert) {
      fallbackColors = fallbackColors.reverse();
    }
    
    return fallbackColors;
  }

  // Função para carregar paletas personalizadas
  function loadCustomPalettes() {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    const customGroup = document.getElementById('custom-palettes-group');
    
    // Limpar opções existentes mas manter o label
    customGroup.innerHTML = '<div class="palette-optgroup-label">Paletas Criadas pelo Usuário</div>';
    
    if (customPalettes.length === 0) {
      // Se não há paletas, mostrar mensagem informativa
      const emptyMessage = document.createElement('div');
      emptyMessage.className = 'palette-empty-message';
      emptyMessage.innerHTML = `
        <div style="padding: 10px; color: #6c757d; font-style: italic; text-align: center;">
          <i class="fas fa-palette"></i> Nenhuma paleta personalizada criada ainda.
          <br><small>Use "Criar Nova Paleta" para começar!</small>
        </div>
      `;
      customGroup.appendChild(emptyMessage);
      return;
    }
    
    customPalettes.forEach(palette => {
      const option = document.createElement('div');
      option.className = 'palette-option';
      option.dataset.value = palette.name;
      option.dataset.type = 'custom';
      
      // Criar preview da paleta
      const preview = document.createElement('div');
      preview.className = 'palette-preview-mini';
      preview.dataset.palette = palette.name;
      
      // Aplicar cores da paleta ao preview
      if (palette.colors && palette.colors.length > 0) {
        const gradientColors = palette.colors.map(color => color).join(', ');
        preview.style.background = `linear-gradient(to right, ${gradientColors})`;
      }
      
      // Criar texto da opção
      const text = document.createElement('span');
      text.textContent = `${palette.name} - ${palette.description}`;
      
      // Adicionar elementos à opção
      option.appendChild(preview);
      option.appendChild(text);
      
      // Adicionar evento de clique
      option.addEventListener('click', function() {
        // Selecionar a paleta
        document.getElementById('palette-select').value = palette.name;
        document.getElementById('palette-select-text').textContent = `${palette.name} - ${palette.description}`;
        
        // Fechar dropdown
        document.getElementById('palette-select-dropdown').classList.add('d-none');
        
        // Atualizar preview da paleta imediatamente
        updatePalettePreview();
        
        // Disparar evento de mudança após a atualização visual
        setTimeout(() => {
          const changeEvent = new Event('change', { bubbles: true });
          document.getElementById('palette-select').dispatchEvent(changeEvent);
        }, 50);
      });
      
      customGroup.appendChild(option);
    });
    
    // Atualizar previews das paletas personalizadas
    updateCustomPalettePreviews();
  }
  
  // Função para atualizar previews das paletas personalizadas
  function updateCustomPalettePreviews() {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    
    customPalettes.forEach(palette => {
      const previewElement = document.querySelector(`[data-palette="${palette.name}"]`);
      if (previewElement && palette.colors && palette.colors.length > 0) {
        const gradientColors = palette.colors.map(color => color).join(', ');
        previewElement.style.background = `linear-gradient(to right, ${gradientColors})`;
      }
    });
  }

  // Função para exibir modal de confirmação customizado
  function showConfirmDialog(message, onConfirm, onCancel = null) {
    // Remover modal existente se houver
    const existingModal = document.querySelector('.confirm-dialog-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Criar modal de confirmação
    const modal = document.createElement('div');
    modal.className = 'confirm-dialog-modal';
    modal.innerHTML = `
      <div class="confirm-dialog-content">
        <div class="confirm-dialog-header">
          <i class="fas fa-exclamation-triangle"></i>
          <h4>Confirmação</h4>
        </div>
        <div class="confirm-dialog-body">
          <p>${message}</p>
        </div>
        <div class="confirm-dialog-footer">
          <button type="button" class="btn-cancel" id="btn-cancel-confirm">
            <i class="fas fa-times"></i> Cancelar
          </button>
          <button type="button" class="btn-confirm" id="btn-confirm-ok">
            <i class="fas fa-check"></i> Confirmar
          </button>
        </div>
      </div>
    `;
    
    // Adicionar ao DOM
    document.body.appendChild(modal);
    
    // Event listeners
    const confirmBtn = modal.querySelector('#btn-confirm-ok');
    const cancelBtn = modal.querySelector('#btn-cancel-confirm');
    
    confirmBtn.addEventListener('click', () => {
      modal.remove();
      if (onConfirm) onConfirm();
    });
    
    cancelBtn.addEventListener('click', () => {
      modal.remove();
      if (onCancel) onCancel();
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
        if (onCancel) onCancel();
      }
    });
    
    // Escape para fechar
    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        modal.remove();
        if (onCancel) onCancel();
      }
    });
    
    // Foco automático no botão de confirmação
    setTimeout(() => confirmBtn.focus(), 100);
  }
  
  // Função para salvar paleta personalizada
  function saveCustomPalette(name, description, colors, paletteData = null) {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    
    // Verificar se já existe uma paleta com esse nome
    const existingIndex = customPalettes.findIndex(p => p.name === name);
    
    if (existingIndex !== -1) {
      // Usar modal customizado em vez de confirm padrão
      showConfirmDialog(
        `Paleta <strong>"${name}"</strong> já existe. Deseja substituir?`,
        () => {
          // Usuário confirmou - substituir paleta
          customPalettes.splice(existingIndex, 1);
          savePaletteAndContinue();
        },
        () => {
          // Usuário cancelou
          return;
        }
      );
      return;
    }
    
    // Se não existe, salvar diretamente
    savePaletteAndContinue();
    
    // Função auxiliar para salvar a paleta
    function savePaletteAndContinue() {
      // Usar paletteData se fornecido, senão criar um novo
      const finalPaletteData = paletteData || {
        name: name,
        description: description,
        colors: colors,
        created: new Date().toISOString()
      };
      
      customPalettes.push(finalPaletteData);
      localStorage.setItem('custom_palettes', JSON.stringify(customPalettes));
      loadCustomPalettes();
      
      // Selecionar a paleta recém-criada
      document.getElementById('palette-select').value = name;
      updatePalettePreview();
    }
  }

  // Função para criar nova paleta
  function createNewPalette() {
    // Criar modal moderno
    const modal = document.createElement('div');
    modal.className = 'custom-palette-modal';
    modal.innerHTML = `
      <div class="custom-palette-modal-content">
        <div class="custom-palette-modal-header">
          <h3><i class="fas fa-palette"></i> Criar Nova Paleta de Cores</h3>
          <button type="button" class="btn-close-modal">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="custom-palette-modal-body">
          <div class="form-group">
            <label for="palette-name">
              <i class="fas fa-tag"></i> Nome da Paleta *
            </label>
            <input type="text" id="palette-name" placeholder="Ex: Minha Paleta Personalizada" maxlength="50">
          </div>
          
          <div class="form-group">
            <label for="palette-description">
              <i class="fas fa-info-circle"></i> Descrição
            </label>
            <textarea id="palette-description" placeholder="Descreva o uso ou tema da paleta..." maxlength="200" rows="2"></textarea>
          </div>
          
          <div class="form-group">
            <label for="palette-type">
              <i class="fas fa-layer-group"></i> Tipo de Paleta
            </label>
            <select id="palette-type">
              <option value="custom">Personalizada</option>
              <option value="sequential">Sequencial</option>
              <option value="divergent">Divergente</option>
              <option value="qualitative">Qualitativa</option>
            </select>
          </div>
          
          <div class="form-group">
            <label>
              <i class="fas fa-paint-brush"></i> Quantidade de Cores
            </label>
            <div class="color-count-controls">
              <button type="button" class="btn-count" data-action="decrease">-</button>
              <span id="color-count-display">5</span>
              <button type="button" class="btn-count" data-action="increase">+</button>
              <span class="color-count-info">(3-1000 cores)</span>
            </div>
            <div class="mt-2">
              <input type="number" id="color-count-input" class="form-control" placeholder="Digite um número específico" min="3" max="1000" value="5">
            </div>
          </div>
          
          <div class="form-group">
            <label>
              <i class="fas fa-palette"></i> Cores da Paleta
            </label>
            <div id="palette-colors-container">
              <!-- Cores serão geradas dinamicamente -->
            </div>
          </div>
          
          <div class="form-group">
            <label>
              <i class="fas fa-palette"></i> Paleta Personalizada
            </label>
            <div class="palette-preview-container">
              <div id="palette-preview" class="palette-preview">
                <!-- Preview da paleta será gerado dinamicamente -->
              </div>
              <div class="palette-preview-info">
                <small class="text-muted">
                  <i class="fas fa-info-circle"></i> 
                  Preview em tempo real da sua paleta personalizada
                </small>
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label>
              <i class="fas fa-magic"></i> Ferramentas Rápidas
            </label>
            <div class="quick-tools">
              <button type="button" class="btn-quick-tool" data-action="generate-harmonious">
                <i class="fas fa-magic"></i> Divergente
              </button>
              <button type="button" class="btn-quick-tool" data-action="generate-gradient">
                <i class="fas fa-gradient"></i> Gradiente
              </button>
              <button type="button" class="btn-quick-tool" data-action="randomize">
                <i class="fas fa-random"></i> Aleatória
              </button>
              <button type="button" class="btn-quick-tool" data-action="clear-all">
                <i class="fas fa-trash"></i> Limpar
              </button>
            </div>
          </div>
        </div>
        
        <div class="custom-palette-modal-footer">
          <button type="button" class="btn btn-secondary" id="btn-cancel-palette">
            <i class="fas fa-times"></i> Cancelar
          </button>
          <button type="button" class="btn btn-primary" id="btn-save-palette">
            <i class="fas fa-save"></i> Salvar Paleta
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Inicializar controles
    let colorCount = 5;
    const colorCountDisplay = modal.querySelector('#color-count-display');
    const colorsContainer = modal.querySelector('#palette-colors-container');
    
    // Função para gerar interface de cores
    function generateColorInputs(count) {
      colorsContainer.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const colorItem = document.createElement('div');
        colorItem.className = 'palette-color-item';
        colorItem.innerHTML = `
          <div class="color-item-header">
            <span class="color-number">Cor ${i + 1}</span>
          </div>
          <div class="color-inputs">
            <div class="color-input-group">
              <label>Seletor:</label>
              <input type="color" class="color-picker" value="#007bff" data-index="${i}">
            </div>
            <div class="color-input-group">
              <label>HEX:</label>
              <input type="text" class="color-hex" value="#007bff" placeholder="#000000" maxlength="7" data-index="${i}">
            </div>
            <div class="color-input-group">
              <label>RGB:</label>
              <div class="rgb-inputs">
                <input type="number" class="rgb-r" placeholder="R" min="0" max="255" value="0" data-index="${i}">
                <input type="number" class="rgb-g" placeholder="G" min="0" max="255" value="123" data-index="${i}">
                <input type="number" class="rgb-b" placeholder="B" min="0" max="255" value="255" data-index="${i}">
              </div>
            </div>
          </div>
        `;
        colorsContainer.appendChild(colorItem);
      }
      
      // Adicionar event listeners para as cores
      addColorEventListeners();
    }
    
    // Função para adicionar event listeners das cores
    function addColorEventListeners() {
      const colorPickers = colorsContainer.querySelectorAll('.color-picker');
      const hexInputs = colorsContainer.querySelectorAll('.color-hex');
      const rgbInputs = colorsContainer.querySelectorAll('.rgb-r, .rgb-g, .rgb-b');
      
      colorPickers.forEach((picker, index) => {
        picker.addEventListener('input', (e) => {
          const color = e.target.value;
          updateColorFromPicker(index, color);
        });
      });
      
      hexInputs.forEach((hexInput, index) => {
        hexInput.addEventListener('input', (e) => {
          const color = e.target.value;
          if (isValidHex(color)) {
            updateColorFromHex(index, color);
          }
        });
      });
      
      rgbInputs.forEach((rgbInput) => {
        rgbInput.addEventListener('input', (e) => {
          const index = parseInt(e.target.dataset.index);
          updateColorFromRGB(index);
        });
      });
    }
    
    // Funções de atualização de cores
    function updateColorFromPicker(index, color) {
      const hexInput = colorsContainer.querySelector(`.color-hex[data-index="${index}"]`);
      const colorPicker = colorsContainer.querySelector(`.color-picker[data-index="${index}"]`);
      
      if (hexInput) hexInput.value = color;
      if (colorPicker) colorPicker.value = color;
      
      const rgb = hexToRgb(color);
      if (rgb) {
        const rInput = colorsContainer.querySelector(`.rgb-r[data-index="${index}"]`);
        const gInput = colorsContainer.querySelector(`.rgb-g[data-index="${index}"]`);
        const bInput = colorsContainer.querySelector(`.rgb-b[data-index="${index}"]`);
        if (rInput) rInput.value = rgb.r;
        if (gInput) gInput.value = rgb.g;
        if (bInput) bInput.value = rgb.b;
      }
      
      // NÃO atualizar preview aqui - será feito pela função chamadora
    }
    
    function updateColorFromHex(index, color) {
      if (!isValidHex(color)) return;
      
      const colorPicker = colorsContainer.querySelector(`.color-picker[data-index="${index}"]`);
      
      if (colorPicker) colorPicker.value = color;
      
      const rgb = hexToRgb(color);
      if (rgb) {
        const rInput = colorsContainer.querySelector(`.rgb-r[data-index="${index}"]`);
        const gInput = colorsContainer.querySelector(`.rgb-g[data-index="${index}"]`);
        const bInput = colorsContainer.querySelector(`.rgb-b[data-index="${index}"]`);
        if (rInput) rInput.value = rgb.r;
        if (gInput) gInput.value = rgb.g;
        if (bInput) bInput.value = rgb.b;
      }
      
      // Atualizar preview da paleta dentro do modal
      updateModalPalettePreview();
    }
    
    function updateColorFromRGB(index) {
      const rInput = colorsContainer.querySelector(`.rgb-r[data-index="${index}"]`);
      const gInput = colorsContainer.querySelector(`.rgb-g[data-index="${index}"]`);
      const bInput = colorsContainer.querySelector(`.rgb-b[data-index="${index}"]`);
      
      if (!rInput || !gInput || !bInput) return;
      
      const r = parseInt(rInput.value) || 0;
      const g = parseInt(gInput.value) || 0;
      const b = parseInt(bInput.value) || 0;
      
      if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) return;
      
      const hex = rgbToHex(r, g, b);
      const colorPicker = colorsContainer.querySelector(`.color-picker[data-index="${index}"]`);
      const hexInput = colorsContainer.querySelector(`.color-hex[data-index="${index}"]`);
      
      if (colorPicker) colorPicker.value = hex;
      if (hexInput) hexInput.value = hex;
      
      // Atualizar preview da paleta dentro do modal
      updateModalPalettePreview();
    }
    
    // Controles de quantidade
    modal.querySelectorAll('.btn-count').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const action = e.target.dataset.action;
        if (action === 'increase' && colorCount < 1000) {
          colorCount++;
        } else if (action === 'decrease' && colorCount > 3) {
          colorCount--;
        }
        colorCountDisplay.textContent = colorCount;
        generateColorInputs(colorCount);
      });
    });
    
    // Input direto para quantidade de cores
    const colorCountInput = modal.querySelector('#color-count-input');
    colorCountInput.addEventListener('input', (e) => {
      const newCount = parseInt(e.target.value) || 5;
      if (newCount >= 3 && newCount <= 1000) {
        colorCount = newCount;
        colorCountDisplay.textContent = colorCount;
        generateColorInputs(colorCount);
      }
    });
    
    // Ferramentas rápidas
    modal.querySelectorAll('.btn-quick-tool').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const action = e.target.dataset.action;
        
        switch(action) {
          case 'generate-harmonious':
            generateHarmoniousColors(colorCount);
            break;
          case 'generate-gradient':
            generateGradientColors(colorCount);
            break;
          case 'randomize':
            generateRandomColors(colorCount);
            break;
          case 'clear-all':
            clearAllColors(colorCount);
            break;
        }
      });
    });
    
    // Funções das ferramentas rápidas - Versões Avançadas com Grande Variabilidade
    function generateHarmoniousColors(count) {
      console.log('generateHarmoniousColors (divergente) chamada com count:', count);
      
      // Escolher um esquema divergente aleatoriamente com grande variedade
      const schemes = [
        // PALETAS QUENTES (Vermelho/Laranja → Neutro → Frio)
        {
          name: 'Vermelho → Branco → Azul',
          startColor: '#67001f',    // Vermelho escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        },
        {
          name: 'Vermelho → Amarelo → Azul',
          startColor: '#a50026',    // Vermelho escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#313695'       // Azul escuro
        },
        {
          name: 'Vermelho → Amarelo → Verde',
          startColor: '#a50026',    // Vermelho escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#006837'       // Verde escuro
        },
        {
          name: 'Rosa → Amarelo → Azul',
          startColor: '#9e0142',    // Rosa escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#5e4fa2'       // Azul escuro
        },
        {
          name: 'Laranja → Branco → Roxo',
          startColor: '#7f3b08',    // Laranja escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#2d004b'       // Roxo escuro
        },
        {
          name: 'Vermelho → Branco → Cinza',
          startColor: '#67001f',    // Vermelho escuro
          middleColor: '#ffffff',   // Branco
          endColor: '#1a1a1a'       // Cinza escuro
        },
        
        // PALETAS NEUTRAS (Marrom/Terra → Neutro → Verde)
        {
          name: 'Marrom → Branco → Verde',
          startColor: '#543005',    // Marrom escuro
          middleColor: '#f5f5f5',   // Branco
          endColor: '#003c30'       // Verde escuro
        },
        {
          name: 'Rosa → Branco → Verde',
          startColor: '#8e0152',    // Rosa escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Roxo → Branco → Verde',
          startColor: '#40004b',    // Roxo escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        
        // PALETAS FRIAS (Azul/Ciano → Neutro → Verde)
        {
          name: 'Azul → Branco → Verde',
          startColor: '#053061',    // Azul escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Ciano → Branco → Verde',
          startColor: '#01665e',    // Ciano escuro
          middleColor: '#f5f5f5',   // Branco
          endColor: '#003c30'       // Verde escuro
        },
        {
          name: 'Azul → Amarelo → Verde',
          startColor: '#313695',    // Azul escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#006837'       // Verde escuro
        },
        
        // PALETAS ESPECIAIS (Divergentes únicas)
        {
          name: 'Dourado → Branco → Azul',
          startColor: '#b35806',    // Dourado escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        },
        {
          name: 'Violeta → Branco → Verde',
          startColor: '#762a83',    // Violeta escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        {
          name: 'Coral → Branco → Azul',
          startColor: '#d53e4f',    // Coral escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#5e4fa2'       // Azul escuro
        },
        {
          name: 'Oliva → Branco → Roxo',
          startColor: '#7fbc41',    // Oliva
          middleColor: '#f7f7f7',   // Branco
          endColor: '#2d004b'       // Roxo escuro
        },
        {
          name: 'Esmeralda → Branco → Rosa',
          startColor: '#1a9850',    // Esmeralda
          middleColor: '#f7f7f7',   // Branco
          endColor: '#8e0152'       // Rosa escuro
        },
        {
          name: 'Safira → Branco → Laranja',
          startColor: '#4575b4',    // Safira
          middleColor: '#f7f7f7',   // Branco
          endColor: '#b35806'       // Laranja escuro
        },
        {
          name: 'Rubi → Branco → Verde',
          startColor: '#d73027',    // Rubi
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Turquesa → Branco → Vermelho',
          startColor: '#66c2a5',    // Turquesa
          middleColor: '#f7f7f7',   // Branco
          endColor: '#a50026'       // Vermelho escuro
        },
        {
          name: 'Lavanda → Branco → Verde',
          startColor: '#9970ab',    // Lavanda
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        {
          name: 'Âmbar → Branco → Azul',
          startColor: '#fdae61',    // Âmbar
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        }
      ];
      
      const selectedScheme = schemes[Math.floor(Math.random() * schemes.length)];
      console.log('Esquema divergente selecionado:', selectedScheme.name);
      
      const colors = [];
      
      // Gerar sequência contínua: início → meio → fim
      for (let i = 0; i < count; i++) {
        const ratio = i / (count - 1);
        let color;
        
        if (ratio <= 0.5) {
          // Primeira metade: início → meio
          const localRatio = ratio * 2; // 0 → 1
          color = interpolateColors(selectedScheme.startColor, selectedScheme.middleColor, localRatio);
        } else {
          // Segunda metade: meio → fim
          const localRatio = (ratio - 0.5) * 2; // 0 → 1
          color = interpolateColors(selectedScheme.middleColor, selectedScheme.endColor, localRatio);
        }
        
        colors.push(color);
      }
      
      console.log('Paleta divergente contínua gerada:', colors);
      applyGeneratedColors(colors);
    }
    
    // Função para converter HSL para HEX
    function hslToHex(h, s, l) {
      l /= 100;
      const a = s * Math.min(l, 1 - l) / 100;
      const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
      };
      return `#${f(0)}${f(8)}${f(4)}`;
    }
    
    function generateGradientColors(count) {
      console.log('generateGradientColors chamada com count:', count);
      
      // Escolher aleatoriamente entre cores primárias e secundárias
      const gradientTypes = [
        // Cores primárias
        'red', 'green', 'blue', 'yellow', 'cyan', 'magenta',
        // Cores secundárias
        'orange', 'purple', 'pink', 'brown', 'teal', 'lime',
        // Cores terciárias
        'indigo', 'violet', 'gold', 'silver', 'copper', 'emerald',
        'sapphire', 'ruby', 'coral', 'olive', 'navy', 'maroon'
      ];
      
      const type = gradientTypes[Math.floor(Math.random() * gradientTypes.length)];
      const colors = [];
      
      // Gerar gradiente SEQUENCIAL (uma cor do claro ao escuro)
      for (let i = 0; i < count; i++) {
        const ratio = i / (count - 1);
        let hue, saturation, lightness;
        
        switch(type) {
          case 'red':
            hue = 0;
            saturation = 85; // Saturação fixa para consistência
            lightness = Math.round(90 - (ratio * 60)); // 90% (claro) → 30% (escuro)
            break;
          case 'green':
            hue = 120;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'blue':
            hue = 240;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'yellow':
            hue = 60;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'cyan':
            hue = 180;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'magenta':
            hue = 300;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'orange':
            hue = 30;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'purple':
            hue = 270;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'pink':
            hue = 330;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'brown':
            hue = 20;
            saturation = 75;
            lightness = Math.round(85 - (ratio * 65));
            break;
          case 'teal':
            hue = 180;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'lime':
            hue = 120;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'indigo':
            hue = 240;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'violet':
            hue = 270;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'gold':
            hue = 45;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'silver':
            hue = 0;
            saturation = 0;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'copper':
            hue = 20;
            saturation = 75;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'emerald':
            hue = 150;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'sapphire':
            hue = 210;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'ruby':
            hue = 0;
            saturation = 90;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'coral':
            hue = 15;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'olive':
            hue = 60;
            saturation = 60;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'navy':
            hue = 240;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'maroon':
            hue = 0;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          default:
            hue = Math.round(Math.random() * 360);
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
        }
        
        const color = hslToHex(hue, saturation, lightness);
        colors.push(color);
      }
      
      console.log('Gradiente SEQUENCIAL gerado:', colors);
      applyGeneratedColors(colors);
    }
    
    function generateRandomColors(count) {
      console.log('generateRandomColors chamada com count:', count);
      
      const colors = [];
      for (let i = 0; i < count; i++) {
        const hue = Math.round(Math.random() * 360);
        const saturation = Math.round(60 + Math.random() * 30);
        const lightness = Math.round(40 + Math.random() * 30);
        const color = hslToHex(hue, saturation, lightness);
        colors.push(color);
      }
      
      console.log('Cores aleatórias geradas:', colors);
      applyGeneratedColors(colors);
    }
    
    function clearAllColors(count) {
      const colors = [];
      for (let i = 0; i < count; i++) {
        colors.push('#cccccc');
      }
      applyGeneratedColors(colors);
    }
    
    function applyGeneratedColors(colors) {
      console.log('applyGeneratedColors chamada com:', colors);
      
      // Verificar se estamos no modal de criação de paletas
      const modal = document.querySelector('.custom-palette-modal');
      if (modal) {
        console.log('Estamos no modal de criação de paletas');
        
        // Estamos no modal - aplicar cores usando a função original
        colors.forEach((color, index) => {
          updateColorFromPicker(index, color);
        });
        
        // Atualizar preview da paleta após aplicar todas as cores
        updateModalPalettePreview();
      } else {
        // Estamos fora do modal - aplicar cores diretamente aos inputs existentes
        const colorPickers = document.querySelectorAll('.color-picker');
        const hexInputs = document.querySelectorAll('.color-hex');
        const rgbInputs = document.querySelectorAll('.rgb-r, .rgb-g, .rgb-b');
        
        colors.forEach((color, index) => {
          // Atualizar color picker
          if (colorPickers[index]) {
            colorPickers[index].value = color;
          }
          
          // Atualizar input HEX
          if (hexInputs[index]) {
            hexInputs[index].value = color;
          }
          
          // Atualizar inputs RGB
          if (rgbInputs[index * 3]) {
            const rgb = hexToRgb(color);
            if (rgb) {
              rgbInputs[index * 3].value = rgb.r;     // R
              rgbInputs[index * 3 + 1].value = rgb.g; // G
              rgbInputs[index * 3 + 2].value = rgb.b; // B
            }
          }
        });
        
        // Atualizar preview da paleta se existir
        const palettePreview = document.querySelector('#palette-preview');
        if (palettePreview) {
          updatePalettePreview();
        }
      }
    }
    
    // Botões de ação
    modal.querySelector('#btn-cancel-palette').addEventListener('click', () => {
      modal.remove();
    });
    
    modal.querySelector('#btn-save-palette').addEventListener('click', () => {
      const name = modal.querySelector('#palette-name').value.trim();
      const description = modal.querySelector('#palette-description').value.trim();
      const type = modal.querySelector('#palette-type').value;
      
      if (!name) {
        showToast('Nome da paleta é obrigatório!', 'error');
        return;
      }
      
      // Coletar cores
      const colors = [];
      const colorPickers = colorsContainer.querySelectorAll('.color-picker');
      colorPickers.forEach(picker => {
        colors.push(picker.value);
      });
      
      if (colors.length < 3) {
        showToast('Mínimo de 3 cores é necessário!', 'error');
        return;
      }
      
      // Salvar paleta
      const paletteData = {
        name: name,
        description: description,
        type: type,
        colors: colors,
        created: new Date().toISOString()
      };
      
      saveCustomPalette(name, description, colors, paletteData);
      showToast('Paleta criada com sucesso!', 'success');
      modal.remove();
      
      // Recarregar paletas
      loadCustomPalettes();
    });
    
    // Fechar modal com ESC ou clicando fora
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
    
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        modal.remove();
      }
    });
    
    // Função para atualizar preview da paleta dentro do modal
    function updateModalPalettePreview() {
      console.log('updateModalPalettePreview chamada');
      
      const previewContainer = modal.querySelector('#palette-preview');
      if (!previewContainer) {
        console.log('Preview container não encontrado');
        return;
      }
      
      const colorPickers = colorsContainer.querySelectorAll('.color-picker');
      const colors = Array.from(colorPickers).map(picker => picker.value);
      
      console.log('Cores encontradas nos color pickers:', colors);
      
      if (colors.length === 0) {
        console.log('Nenhuma cor encontrada');
        return;
      }
      
      // Limitar a exibição para não sobrecarregar visualmente
      const maxDisplayColors = Math.min(colors.length, 50);
      const step = Math.max(1, Math.floor(colors.length / maxDisplayColors));
      
      let previewHTML = '';
      for (let i = 0; i < maxDisplayColors; i++) {
        const colorIndex = i * step;
        const color = colors[colorIndex];
        previewHTML += `<div class="preview-color" style="background-color: ${color};" title="Cor ${colorIndex + 1}: ${color}"></div>`;
      }
      
      console.log('Preview HTML gerado:', previewHTML.substring(0, 100) + '...');
      previewContainer.innerHTML = previewHTML;
      
      // Adicionar contador de cores
      const colorCount = colors.length;
      const previewInfo = modal.querySelector('.palette-preview-info small');
      if (previewInfo) {
        previewInfo.innerHTML = `
          <i class="fas fa-info-circle"></i> 
          Preview em tempo real da sua paleta personalizada (${colorCount} cores)
        `;
      }
      
      console.log('Preview atualizado com sucesso');
    }
    
    // Gerar interface inicial
    generateColorInputs(colorCount);
    
    // Inicializar preview da paleta
    updateModalPalettePreview();
  }

  // Função global para gerar cores gradiente (disponível para todos os modais)
  function generateGradientColors(count) {
    console.log('generateGradientColors called with count:', count);
    
    // Escolher aleatoriamente entre diferentes tipos de gradientes baseados em cores predefinidas
    const gradientTypes = [
      'red',           // Vermelho: claro para escuro
      'green',         // Verde: claro para escuro
      'blue',          // Azul: claro para escuro
      'yellow',        // Amarelo: claro para escuro
      'cyan',          // Ciano: claro para escuro
      'magenta',       // Magenta: claro para escuro
      'orange',        // Laranja: claro para escuro
      'purple',        // Roxo: claro para escuro
      'pink',          // Rosa: claro para escuro
      'brown',         // Marrom: claro para escuro
      'teal',          // Verde-azulado: claro para escuro
      'lime',          // Lima: claro para escuro
      'indigo',        // Índigo: claro para escuro
      'violet',        // Violeta: claro para escuro
      'gold',          // Dourado: claro para escuro
      'silver',        // Prateado: claro para escuro
      'copper',        // Cobre: claro para escuro
      'emerald',       // Esmeralda: claro para escuro
      'sapphire',      // Safira: claro para escuro
      'ruby'           // Rubi: claro para escuro
    ];
    
    const type = gradientTypes[Math.floor(Math.random() * gradientTypes.length)];
    const colors = [];
    
    switch(type) {
      case 'red':
        // Vermelho: do mais claro ao mais escuro
        const redGradient = ['#FFE6E6', '#FFCCCC', '#FFB3B3', '#FF9999', '#FF8080', '#FF6666', '#FF4D4D', '#FF3333', '#FF1A1A', '#FF0000', '#E60000', '#CC0000', '#B30000', '#990000', '#800000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (redGradient.length - 1));
          colors.push(redGradient[colorIndex]);
        }
        break;
        
      case 'green':
        // Verde: do mais claro ao mais escuro
        const greenGradient = ['#E6FFE6', '#CCFFCC', '#B3FFB3', '#99FF99', '#80FF80', '#66FF66', '#4DFF4D', '#33FF33', '#1AFF1A', '#00FF00', '#00E600', '#00CC00', '#00B300', '#009900', '#008000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (greenGradient.length - 1));
          colors.push(greenGradient[colorIndex]);
        }
        break;
        
      case 'blue':
        // Azul: do mais claro ao mais escuro
        const blueGradient = ['#E6E6FF', '#CCCCFF', '#B3B3FF', '#9999FF', '#8080FF', '#6666FF', '#4D4DFF', '#3333FF', '#1A1AFF', '#0000FF', '#0000E6', '#0000CC', '#0000B3', '#000099', '#000080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (blueGradient.length - 1));
          colors.push(blueGradient[colorIndex]);
        }
        break;
        
      case 'yellow':
        // Amarelo: do mais claro ao mais escuro
        const yellowGradient = ['#FFFFE6', '#FFFFCC', '#FFFFB3', '#FFFF99', '#FFFF80', '#FFFF66', '#FFFF4D', '#FFFF33', '#FFFF1A', '#FFFF00', '#E6E600', '#CCCC00', '#B3B300', '#999900', '#808000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (yellowGradient.length - 1));
          colors.push(yellowGradient[colorIndex]);
        }
        break;
        
      case 'cyan':
        // Ciano: do mais claro ao mais escuro
        const cyanGradient = ['#E6FFFF', '#CCFFFF', '#B3FFFF', '#99FFFF', '#80FFFF', '#66FFFF', '#4DFFFF', '#33FFFF', '#1AFFFF', '#00FFFF', '#00E6E6', '#00CCCC', '#00B3B3', '#009999', '#008080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (cyanGradient.length - 1));
          colors.push(cyanGradient[colorIndex]);
        }
        break;
        
      case 'magenta':
        // Magenta: do mais claro ao mais escuro
        const magentaGradient = ['#FFE6FF', '#FFCCFF', '#FFB3FF', '#FF99FF', '#FF80FF', '#FF66FF', '#FF4DFF', '#FF33FF', '#FF1AFF', '#FF00FF', '#E600E6', '#CC00CC', '#B300B3', '#990099', '#800080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (magentaGradient.length - 1));
          colors.push(magentaGradient[colorIndex]);
        }
        break;
        
      case 'orange':
        // Laranja: do mais claro ao mais escuro
        const orangeGradient = ['#FFE6CC', '#FFCC99', '#FFB366', '#FF9933', '#FF8000', '#E67300', '#CC6600', '#B35900', '#994D00', '#804000', '#663300', '#4D2600', '#331900', '#1A0D00'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (orangeGradient.length - 1));
          colors.push(orangeGradient[colorIndex]);
        }
        break;
        
      case 'purple':
        // Roxo: do mais claro ao mais escuro
        const purpleGradient = ['#F0E6FF', '#E1CCFF', '#D2B3FF', '#C399FF', '#B480FF', '#A566FF', '#964DFF', '#8733FF', '#781AFF', '#6900FF', '#5E00E6', '#5200CC', '#4700B3', '#3B0099', '#300080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (purpleGradient.length - 1));
          colors.push(purpleGradient[colorIndex]);
        }
        break;
        
      case 'pink':
        // Rosa: do mais claro ao mais escuro
        const pinkGradient = ['#FFE6F0', '#FFCCE1', '#FFB3D2', '#FF99C3', '#FF80B4', '#FF66A5', '#FF4D96', '#FF3387', '#FF1A78', '#FF0069', '#E6005E', '#CC0052', '#B30047', '#99003B', '#800030'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (pinkGradient.length - 1));
          colors.push(pinkGradient[colorIndex]);
        }
        break;
        
      case 'brown':
        // Marrom: do mais claro ao mais escuro
        const brownGradient = ['#F5E6D3', '#EBD4B3', '#E1C293', '#D7B073', '#CD9E53', '#C38C33', '#B97A13', '#A66800', '#8C5600', '#734400', '#5A3200', '#412000', '#280E00', '#0F0000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (brownGradient.length - 1));
          colors.push(brownGradient[colorIndex]);
        }
        break;
        
      case 'teal':
        // Verde-azulado: do mais claro ao mais escuro
        const tealGradient = ['#E6FFFF', '#CCFFFF', '#B3FFFF', '#99FFFF', '#80FFFF', '#66FFFF', '#4DFFFF', '#33FFFF', '#1AFFFF', '#00FFFF', '#00E6E6', '#00CCCC', '#00B3B3', '#009999', '#008080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (tealGradient.length - 1));
          colors.push(tealGradient[colorIndex]);
        }
        break;
        
      case 'lime':
        // Lima: do mais claro ao mais escuro
        const limeGradient = ['#F0FFE6', '#E0FFCC', '#D0FFB3', '#C0FF99', '#B0FF80', '#A0FF66', '#90FF4D', '#80FF33', '#70FF1A', '#60FF00', '#56E600', '#4CCC00', '#42B300', '#389900', '#2E8000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (limeGradient.length - 1));
          colors.push(limeGradient[colorIndex]);
        }
        break;
        
      case 'indigo':
        // Índigo: do mais claro ao mais escuro
        const indigoGradient = ['#E6E6FF', '#CCCCFF', '#B3B3FF', '#9999FF', '#8080FF', '#6666FF', '#4D4DFF', '#3333FF', '#1A1AFF', '#0000FF', '#0000E6', '#0000CC', '#0000B3', '#000099', '#000080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (indigoGradient.length - 1));
          colors.push(indigoGradient[colorIndex]);
        }
        break;
        
      case 'violet':
        // Violeta: do mais claro ao mais escuro
        const violetGradient = ['#F0E6FF', '#E1CCFF', '#D2B3FF', '#C399FF', '#B480FF', '#A566FF', '#964DFF', '#8733FF', '#781AFF', '#6900FF', '#5E00E6', '#5200CC', '#4700B3', '#3B0099', '#300080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (violetGradient.length - 1));
          colors.push(violetGradient[colorIndex]);
        }
        break;
        
      case 'gold':
        // Dourado: do mais claro ao mais escuro
        const goldGradient = ['#FFF8E6', '#FFF0CC', '#FFE8B3', '#FFE099', '#FFD880', '#FFD066', '#FFC84D', '#FFC033', '#FFB81A', '#FFB000', '#E69E00', '#CC8C00', '#B37A00', '#996800', '#805600'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (goldGradient.length - 1));
          colors.push(goldGradient[colorIndex]);
        }
        break;
        
      case 'silver':
        // Prateado: do mais claro ao mais escuro
        const silverGradient = ['#FFFFFF', '#F2F2F2', '#E6E6E6', '#D9D9D9', '#CCCCCC', '#BFBFBF', '#B3B3B3', '#A6A6A6', '#999999', '#8C8C8C', '#808080', '#737373', '#666666', '#595959', '#4D4D4D'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (silverGradient.length - 1));
          colors.push(silverGradient[colorIndex]);
        }
        break;
        
      case 'copper':
        // Cobre: do mais claro ao mais escuro
        const copperGradient = ['#F5E6D3', '#EBD4B3', '#E1C293', '#D7B073', '#CD9E53', '#C38C33', '#B97A13', '#A66800', '#8C5600', '#734400', '#5A3200', '#412000', '#280E00', '#0F0000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (copperGradient.length - 1));
          colors.push(copperGradient[colorIndex]);
        }
        break;
        
      case 'emerald':
        // Esmeralda: do mais claro ao mais escuro
        const emeraldGradient = ['#E6FFE6', '#CCFFCC', '#B3FFB3', '#99FF99', '#80FF80', '#66FF66', '#4DFF4D', '#33FF33', '#1AFF1A', '#00FF00', '#00E600', '#00CC00', '#00B300', '#009900', '#008000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (emeraldGradient.length - 1));
          colors.push(emeraldGradient[colorIndex]);
        }
        break;
        
      case 'sapphire':
        // Safira: do mais claro ao mais escuro
        const sapphireGradient = ['#E6E6FF', '#CCCCFF', '#B3B3FF', '#9999FF', '#8080FF', '#6666FF', '#4D4DFF', '#3333FF', '#1A1AFF', '#0000FF', '#0000E6', '#0000CC', '#0000B3', '#000099', '#000080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (sapphireGradient.length - 1));
          colors.push(sapphireGradient[colorIndex]);
        }
        break;
        
      case 'ruby':
        // Rubi: do mais claro ao mais escuro
        const rubyGradient = ['#FFE6E6', '#FFCCCC', '#FFB3B3', '#FF9999', '#FF8080', '#FF6666', '#FF4D4D', '#FF3333', '#FF1A1A', '#FF0000', '#E60000', '#CC0000', '#B30000', '#990000', '#800000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (rubyGradient.length - 1));
          colors.push(rubyGradient[colorIndex]);
        }
        break;
    }
    
    console.log('generateGradientColors returning:', colors);
    return colors;
  }
  
  // Função global para gerar cores aleatórias (disponível para todos os modais)
  function generateRandomColors(count) {
    console.log('generateRandomColors called with count:', count);
    
    const colors = [];
    for (let i = 0; i < count; i++) {
      const hue = Math.random() * 360;
      const saturation = 60 + Math.random() * 30;
      const lightness = 40 + Math.random() * 30;
      const color = hslToHex(hue, saturation, lightness);
      colors.push(color);
    }
    
    console.log('generateRandomColors returning:', colors);
    return colors;
  }

  // Função para interpolar cores (usada nas ferramentas rápidas)
  function interpolateColors(color1, color2, ratio) {
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);
    
    if (!rgb1 || !rgb2) return color1;
    
    const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * ratio);
    const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * ratio);
    const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * ratio);
    
    return rgbToHex(r, g, b);
  }

  // Função para salvar paleta atual
  function saveCurrentPalette() {
    const currentPalette = document.getElementById('palette-select').value;
    const currentColors = brewer(currentPalette, 8, document.getElementById('palette-invert').checked);
    
    // Verificar se já existe um modal
    let existingModal = document.querySelector('.save-palette-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Criar modal moderno
    const modal = document.createElement('div');
    modal.className = 'save-palette-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      backdrop-filter: blur(5px);
    `;
    
    modal.innerHTML = `
      <div class="save-palette-content" style="
        background: white;
        border-radius: 15px;
        padding: 0;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        border: 2px solid var(--bs-primary);
        overflow: hidden;
        animation: modalSlideIn 0.3s ease-out;
      ">
        <div class="save-palette-header" style="
          background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary-rgb, 0.8));
          color: white;
          padding: 20px;
          text-align: center;
          position: relative;
        ">
          <h4 style="margin: 0; font-weight: 600; font-size: 1.3rem;">
            <i class="fas fa-save"></i> Salvar Paleta Atual
          </h4>
          <button class="close-modal-btn" style="
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
          ">&times;</button>
        </div>
        
        <div class="save-palette-body" style="padding: 25px;">
          <div style="margin-bottom: 20px;">
            <label style="
              display: block;
              margin-bottom: 8px;
              font-weight: 600;
              color: #333;
              font-size: 0.95rem;
            ">Nome da Paleta:</label>
            <input type="text" id="palette-name-input" placeholder="Digite um nome para a paleta" style="
              width: 100%;
              padding: 12px 15px;
              border: 2px solid #e1e5e9;
              border-radius: 8px;
              font-size: 1rem;
              transition: border-color 0.2s;
              box-sizing: border-box;
            " value="${currentPalette}">
          </div>
          
          <div style="margin-bottom: 25px;">
            <label style="
              display: block;
              margin-bottom: 8px;
              font-weight: 600;
              color: #333;
              font-size: 0.95rem;
            ">Descrição:</label>
            <textarea id="palette-description-input" placeholder="Descreva a paleta" rows="3" style="
              width: 100%;
              padding: 12px 15px;
              border: 2px solid #e1e5e9;
              border-radius: 8px;
              font-size: 1rem;
              transition: border-color 0.2s;
              box-sizing: border-box;
              resize: vertical;
              font-family: inherit;
            ">Paleta baseada em ${currentPalette}</textarea>
          </div>
          
          <div style="margin-bottom: 25px;">
            <label style="
              display: block;
              margin-bottom: 8px;
              font-weight: 600;
              color: #333;
              font-size: 0.95rem;
            ">Preview da Paleta:</label>
            <div id="current-palette-preview" style="
              height: 40px;
              border-radius: 8px;
              border: 2px solid #e1e5e9;
              background: linear-gradient(to right, ${currentColors.join(', ')});
              display: flex;
              align-items: center;
              justify-content: center;
              color: white;
              font-weight: 600;
              text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
              font-size: 0.9rem;
            ">${currentColors.length} cores</div>
          </div>
          
          <div style="display: flex; gap: 15px; justify-content: flex-end;">
            <button id="cancel-save-palette" style="
              padding: 12px 25px;
              border: 2px solid #6c757d;
              background: white;
              color: #6c757d;
              border-radius: 8px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              font-size: 0.95rem;
            ">Cancelar</button>
            <button id="confirm-save-palette" style="
              padding: 12px 25px;
              border: none;
              background: var(--bs-primary);
              color: white;
              border-radius: 8px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              font-size: 0.95rem;
            ">Salvar Paleta</button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Focar no primeiro input
    const nameInput = modal.querySelector('#palette-name-input');
    nameInput.focus();
    nameInput.select();
    
    // Event listeners
    modal.querySelector('.close-modal-btn').addEventListener('click', () => modal.remove());
    modal.querySelector('#cancel-save-palette').addEventListener('click', () => modal.remove());
    
    modal.querySelector('#confirm-save-palette').addEventListener('click', () => {
      const name = nameInput.value.trim();
      const description = modal.querySelector('#palette-description-input').value.trim();
      
      if (!name) {
        nameInput.style.borderColor = '#dc3545';
        nameInput.focus();
        return;
      }
      
      saveCustomPalette(name, description, currentColors);
      showToast(`Paleta "${name}" salva com sucesso!`, 'success');
      modal.remove();
    });
    
    // Enter para salvar, Escape para cancelar
    nameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        modal.querySelector('#confirm-save-palette').click();
      }
    });
    
    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        modal.remove();
      }
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
  }

  // Função para gerenciar paletas
  function managePalettes() {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    
    // Verificar se já existe um modal
    let existingModal = document.querySelector('.manage-palettes-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Criar modal moderno
    const modal = document.createElement('div');
    modal.className = 'manage-palettes-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      backdrop-filter: blur(5px);
    `;
    
    modal.innerHTML = `
      <div class="manage-palettes-content" style="
        background: white;
        border-radius: 15px;
        padding: 0;
        max-width: 700px;
        width: 90%;
        max-height: 80vh;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        border: 2px solid var(--bs-primary);
        overflow: hidden;
        animation: modalSlideIn 0.3s ease-out;
        display: flex;
        flex-direction: column;
      ">
        <div class="manage-palettes-header" style="
          background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary-rgb, 0.8));
          color: white;
          padding: 20px;
          text-align: center;
          position: relative;
          flex-shrink: 0;
        ">
          <h4 style="margin: 0; font-weight: 600; font-size: 1.3rem;">
            <i class="fas fa-cogs"></i> Gerenciar Paletas Personalizadas
          </h4>
          <button class="close-modal-btn" style="
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
          ">&times;</button>
        </div>
        
        <div class="manage-palettes-body" style="
          padding: 25px;
          flex: 1;
          overflow-y: auto;
          display: flex;
          flex-direction: column;
        ">
          ${customPalettes.length === 0 ? `
            <div style="
              text-align: center;
              padding: 40px 20px;
              color: #6c757d;
              font-style: italic;
            ">
              <i class="fas fa-palette" style="font-size: 3rem; margin-bottom: 20px; opacity: 0.5;"></i>
              <h5 style="margin: 0 0 10px 0; color: #495057;">Nenhuma paleta personalizada encontrada</h5>
              <p style="margin: 0; font-size: 0.95rem;">Crie sua primeira paleta usando "Criar Nova Paleta"</p>
            </div>
          ` : `
            <div style="margin-bottom: 20px;">
              <h6 style="margin: 0 0 15px 0; color: #333; font-weight: 600; font-size: 1.1rem;">
                <i class="fas fa-list"></i> Paletas Disponíveis (${customPalettes.length})
              </h6>
            </div>
            
            <div class="palettes-list" style="
              display: flex;
              flex-direction: column;
              gap: 15px;
              flex: 1;
            ">
              ${customPalettes.map((palette, index) => `
                <div class="palette-item" data-palette-index="${index}" style="
                  border: 2px solid #e1e5e9;
                  border-radius: 12px;
                  padding: 20px;
                  background: #f8f9fa;
                  transition: all 0.2s;
                  position: relative;
                ">
                  <div style="
                    display: flex;
                    justify-content: space-between;
                    align-items: flex-start;
                    margin-bottom: 15px;
                  ">
                    <div style="flex: 1;">
                      <h6 style="
                        margin: 0 0 8px 0;
                        color: #333;
                        font-weight: 600;
                        font-size: 1.1rem;
                      ">${palette.name}</h6>
                      <p style="
                        margin: 0;
                        color: #6c757d;
                        font-size: 0.95rem;
                        line-height: 1.4;
                      ">${palette.description}</p>
                    </div>
                    
                    <div style="
                      display: flex;
                      gap: 10px;
                      flex-shrink: 0;
                    ">
                      <button class="edit-palette-btn" data-palette-index="${index}" style="
                        padding: 8px 16px;
                        border: 2px solid var(--bs-primary);
                        background: white;
                        color: var(--bs-primary);
                        border-radius: 6px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.2s;
                        font-size: 0.85rem;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                      ">
                        <i class="fas fa-edit"></i> Editar
                      </button>
                      <button class="delete-palette-btn" data-palette-index="${index}" style="
                        padding: 8px 16px;
                        border: 2px solid #dc3545;
                        background: white;
                        color: #dc3545;
                        border-radius: 6px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.2s;
                        font-size: 0.85rem;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                      ">
                        <i class="fas fa-trash"></i> Excluir
                      </button>
                    </div>
                  </div>
                  
                  <div style="
                    display: flex;
                    align-items: center;
                    gap: 15px;
                  ">
                    <div style="
                      height: 35px;
                      border-radius: 8px;
                      border: 2px solid #e1e5e9;
                      background: linear-gradient(to right, ${palette.colors.join(', ')});
                      flex: 1;
                      position: relative;
                    ">
                      <div style="
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 600;
                        text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
                        font-size: 0.85rem;
                      ">${palette.colors.length} cores</div>
                    </div>
                    
                    <div style="
                      color: #6c757d;
                      font-size: 0.9rem;
                      font-weight: 500;
                      min-width: 80px;
                      text-align: center;
                    ">
                      ${palette.colors.length} cores
                    </div>
                  </div>
                </div>
              `).join('')}
            </div>
          `}
          
          <div style="
            display: flex;
            justify-content: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #e1e5e9;
          ">
            <button id="close-manage-palettes" style="
              padding: 12px 30px;
              border: 2px solid var(--bs-primary);
              background: white;
              color: var(--bs-primary);
              border-radius: 8px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              font-size: 1rem;
            ">Fechar</button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Event listeners
    modal.querySelector('.close-modal-btn').addEventListener('click', () => modal.remove());
    modal.querySelector('#close-manage-palettes').addEventListener('click', () => modal.remove());
    
    // Botões de editar
    modal.querySelectorAll('.edit-palette-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const index = parseInt(btn.dataset.paletteIndex);
        const palette = customPalettes[index];
        modal.remove();
        editCustomPalette(palette);
      });
    });
    
    // Botões de excluir
    modal.querySelectorAll('.delete-palette-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const index = parseInt(btn.dataset.paletteIndex);
        const palette = customPalettes[index];
        
        if (confirm(`Tem certeza que deseja excluir a paleta "${palette.name}"?\n\nEsta ação não pode ser desfeita.`)) {
          customPalettes.splice(index, 1);
          localStorage.setItem('custom_palettes', JSON.stringify(customPalettes));
          loadCustomPalettes();
          showToast(`Paleta "${palette.name}" excluída com sucesso!`, 'success');
          
          // Recarregar o modal para atualizar a lista
          modal.remove();
          managePalettes();
        }
      });
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
    
    // Escape para fechar
    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        modal.remove();
      }
    });
  }
  
  // Função para editar paleta personalizada - REUTILIZA O MODAL "CRIAR NOVA PALETA"
  function editCustomPalette(palette) {
    // Remove qualquer modal existente
    let existingModal = document.querySelector('.custom-palette-modal');
    if (existingModal) {
      existingModal.remove();
    }

    // Chama a função createNewPalette para reutilizar toda a interface
    createNewPalette();
    
    // Aguarda o modal ser criado e pré-preenche os dados
    setTimeout(() => {
      const modal = document.querySelector('.custom-palette-modal');
      if (modal) {
        // Alterar título para "Editar Paleta"
        const header = modal.querySelector('.custom-palette-modal-header h3');
        if (header) {
          header.innerHTML = '<i class="fas fa-edit"></i> Editar Paleta: ' + palette.name;
        }
        
        // Pré-preencher campos com dados existentes
        const nameInput = modal.querySelector('#palette-name');
        const descInput = modal.querySelector('#palette-description');
        const countDisplay = modal.querySelector('#color-count-display');
        const countInput = modal.querySelector('#color-count-input');
        
        if (nameInput) nameInput.value = palette.name;
        if (descInput) descInput.value = palette.description || '';
        if (countDisplay) countDisplay.textContent = palette.colors.length;
        if (countInput) countInput.value = palette.colors.length;
        
        // Pré-preencher cores existentes
        const colorsContainer = modal.querySelector('#palette-colors-container');
        if (colorsContainer) {
          // Limpar container
          colorsContainer.innerHTML = '';
          
          // Gerar inputs com cores existentes
          palette.colors.forEach((color, index) => {
            const rgb = hexToRgb(color);
            const colorItem = document.createElement('div');
            colorItem.className = 'palette-color-item';
            colorItem.innerHTML = `
              <div class="color-item-header">
                <span class="color-number">Cor ${index + 1}</span>
              </div>
              <div class="color-inputs">
                <div class="color-input-group">
                  <label>Seletor:</label>
                  <input type="color" class="color-picker" value="${color}" data-index="${index}">
                </div>
                <div class="color-input-group">
                  <label>HEX:</label>
                  <input type="text" class="color-hex" value="${color}" placeholder="#000000" maxlength="7" data-index="${index}">
                </div>
                <div class="color-input-group">
                  <label>RGB:</label>
                  <div class="rgb-inputs">
                    <input type="number" class="rgb-r" placeholder="R" min="0" max="255" value="${rgb ? rgb.r : 0}" data-index="${index}">
                    <input type="number" class="rgb-g" placeholder="G" min="0" max="255" value="${rgb ? rgb.g : 0}" data-index="${index}">
                    <input type="number" class="rgb-b" placeholder="B" min="0" max="255" value="${rgb ? rgb.b : 0}" data-index="${index}">
                  </div>
                </div>
              </div>
            `;
            colorsContainer.appendChild(colorItem);
          });
          
          // Reativar event listeners das cores
          addColorEventListeners();
        }
        
        // Atualizar preview com cores existentes
        const preview = modal.querySelector('#palette-preview');
        if (preview && palette.colors.length > 0) {
          preview.style.background = `linear-gradient(to right, ${palette.colors.join(', ')})`;
          preview.textContent = `${palette.colors.length} cores`;
        }
        
        // Alterar botão de salvar para "Atualizar Paleta"
        const saveBtn = modal.querySelector('#btn-save-palette');
        if (saveBtn) {
          saveBtn.innerHTML = '<i class="fas fa-save"></i> Atualizar Paleta';
          
          // Substituir event listener para atualização
          const newSaveBtn = saveBtn.cloneNode(true);
          saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
          
          newSaveBtn.addEventListener('click', () => {
            const updatedName = modal.querySelector('#palette-name').value.trim();
            const updatedDescription = modal.querySelector('#palette-description').value.trim();
            
            if (!updatedName) {
              alert('Por favor, digite um nome para a paleta.');
              return;
            }
            
            // Coletar cores atuais
            const updatedColors = [];
            modal.querySelectorAll('.color-picker').forEach(picker => {
              updatedColors.push(picker.value);
            });
            
            // Atualizar paleta no localStorage
            let customPalettes = JSON.parse(localStorage.getItem('customPalettes') || '[]');
            const paletteIndex = customPalettes.findIndex(p => p.name === palette.name);
            
            if (paletteIndex !== -1) {
              customPalettes[paletteIndex] = {
                name: updatedName,
                description: updatedDescription,
                colors: updatedColors,
                type: 'custom',
                createdAt: customPalettes[paletteIndex].createdAt,
                updatedAt: new Date().toISOString()
              };
              
              localStorage.setItem('customPalettes', JSON.stringify(customPalettes));
              
              // Mostrar sucesso
              alert('Paleta atualizada com sucesso!');
              
              // Fechar modal
              modal.remove();
              
              // Recarregar lista de paletas se estiver aberta
              loadCustomPalettes();
            }
          });
        }
      }
    }, 100);
  }
  
  // Função para gerar cores divergentes (sequência contínua sem repetições)
  function generateHarmonicColors(count) {
    console.log('generateHarmonicColors (divergente - edit) chamada com count:', count);
    
          // Escolher um esquema divergente aleatoriamente com grande variedade
      const schemes = [
        // PALETAS QUENTES (Vermelho/Laranja → Neutro → Frio)
        {
          name: 'Vermelho → Branco → Azul',
          startColor: '#67001f',    // Vermelho escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        },
        {
          name: 'Vermelho → Amarelo → Azul',
          startColor: '#a50026',    // Vermelho escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#313695'       // Azul escuro
        },
        {
          name: 'Vermelho → Amarelo → Verde',
          startColor: '#a50026',    // Vermelho escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#006837'       // Verde escuro
        },
        {
          name: 'Rosa → Amarelo → Azul',
          startColor: '#9e0142',    // Rosa escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#5e4fa2'       // Azul escuro
        },
        {
          name: 'Laranja → Branco → Roxo',
          startColor: '#7f3b08',    // Laranja escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#2d004b'       // Roxo escuro
        },
        {
          name: 'Vermelho → Branco → Cinza',
          startColor: '#67001f',    // Vermelho escuro
          middleColor: '#ffffff',   // Branco
          endColor: '#1a1a1a'       // Cinza escuro
        },
        
        // PALETAS NEUTRAS (Marrom/Terra → Neutro → Verde)
        {
          name: 'Marrom → Branco → Verde',
          startColor: '#543005',    // Marrom escuro
          middleColor: '#f5f5f5',   // Branco
          endColor: '#003c30'       // Verde escuro
        },
        {
          name: 'Rosa → Branco → Verde',
          startColor: '#8e0152',    // Rosa escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Roxo → Branco → Verde',
          startColor: '#40004b',    // Roxo escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        
        // PALETAS FRIAS (Azul/Ciano → Neutro → Verde)
        {
          name: 'Azul → Branco → Verde',
          startColor: '#053061',    // Azul escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Ciano → Branco → Verde',
          startColor: '#01665e',    // Ciano escuro
          middleColor: '#f5f5f5',   // Branco
          endColor: '#003c30'       // Verde escuro
        },
        {
          name: 'Azul → Amarelo → Verde',
          startColor: '#313695',    // Azul escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#006837'       // Verde escuro
        },
        
        // PALETAS ESPECIAIS (Divergentes únicas)
        {
          name: 'Dourado → Branco → Azul',
          startColor: '#b35806',    // Dourado escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        },
        {
          name: 'Violeta → Branco → Verde',
          startColor: '#762a83',    // Violeta escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        {
          name: 'Coral → Amarelo → Azul',
          startColor: '#d53e4f',    // Coral escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#5e4fa2'       // Azul escuro
        },
        {
          name: 'Oliva → Branco → Roxo',
          startColor: '#7fbc41',    // Oliva
          middleColor: '#f7f7f7',   // Branco
          endColor: '#2d004b'       // Roxo escuro
        },
        {
          name: 'Esmeralda → Branco → Rosa',
          startColor: '#1a9850',    // Esmeralda
          middleColor: '#f7f7f7',   // Branco
          endColor: '#8e0152'       // Rosa escuro
        },
        {
          name: 'Safira → Branco → Laranja',
          startColor: '#4575b4',    // Safira
          middleColor: '#f7f7f7',   // Branco
          endColor: '#b35806'       // Laranja escuro
        },
        {
          name: 'Rubi → Amarelo → Verde',
          startColor: '#d73027',    // Rubi
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Turquesa → Branco → Vermelho',
          startColor: '#66c2a5',    // Turquesa
          middleColor: '#f7f7f7',   // Branco
          endColor: '#a50026'       // Vermelho escuro
        },
        {
          name: 'Lavanda → Branco → Verde',
          startColor: '#9970ab',    // Lavanda
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        {
          name: 'Âmbar → Branco → Azul',
          startColor: '#fdae61',    // Âmbar
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        }
      ];
    
    const selectedScheme = schemes[Math.floor(Math.random() * schemes.length)];
    console.log('Esquema divergente selecionado:', selectedScheme.name);
    
    const colors = [];
    
    // Gerar sequência contínua: início → meio → fim
    for (let i = 0; i < count; i++) {
      const ratio = i / (count - 1);
      let color;
      
      if (ratio <= 0.5) {
        // Primeira metade: início → meio
        const localRatio = ratio * 2; // 0 → 1
        color = interpolateColors(selectedScheme.startColor, selectedScheme.middleColor, localRatio);
      } else {
        // Segunda metade: meio → fim
        const localRatio = (ratio - 0.5) * 2; // 0 → 1
        color = interpolateColors(selectedScheme.middleColor, selectedScheme.endColor, localRatio);
      }
      
      colors.push(color);
    }
    
    console.log('Paleta divergente contínua gerada:', colors);
    return colors;
  }
  
  // Função para aplicar cores geradas ao modal de edição
  function applyGeneratedColorsToEdit(colors, modal) {
    if (!colors || colors.length === 0) {
      console.log('No colors provided to applyGeneratedColorsToEdit');
      return;
    }
    
    console.log('Applying colors:', colors);
    
    // Primeiro, ajustar a quantidade de cores se necessário
    const currentQuantity = modal.querySelectorAll('.edit-color-picker').length;
    console.log('Current quantity:', currentQuantity, 'New quantity:', colors.length);
    
    if (colors.length !== currentQuantity) {
      resizeColorList(modal, colors.length);
      modal.querySelector('#edit-palette-quantity').value = colors.length;
    }
    
    // Pequeno delay para garantir que os elementos foram criados
    setTimeout(() => {
      // Aplicar as cores
      const colorPickers = modal.querySelectorAll('.edit-color-picker');
      const hexInputs = modal.querySelectorAll('.edit-color-hex');
      
      console.log('Found color pickers:', colorPickers.length);
      
      colors.forEach((color, index) => {
        if (colorPickers[index]) {
          colorPickers[index].value = color;
        }
        if (hexInputs[index]) {
          hexInputs[index].value = color;
        }
        
        // Atualizar RGB inputs
        const rgbRInput = modal.querySelector(`.edit-rgb-r[data-index="${index}"]`);
        const rgbGInput = modal.querySelector(`.edit-rgb-g[data-index="${index}"]`);
        const rgbBInput = modal.querySelector(`.edit-rgb-b[data-index="${index}"]`);
        
        if (rgbRInput && rgbGInput && rgbBInput) {
          const rgb = hexToRgb(color);
          if (rgb) {
            rgbRInput.value = rgb.r;
            rgbGInput.value = rgb.g;
            rgbBInput.value = rgb.b;
          }
        }
      });
    }, 100);
  }
  
  // Função para redimensionar a lista de cores
  function resizeColorList(modal, newQuantity) {
    const container = modal.querySelector('#edit-colors-container');
    const currentColors = container.querySelectorAll('.edit-color-item');
    const currentQuantity = currentColors.length;
    
    if (newQuantity === currentQuantity) return;
    
    if (newQuantity > currentQuantity) {
      // Adicionar novas cores
      for (let i = currentQuantity; i < newQuantity; i++) {
        const colorItem = document.createElement('div');
        colorItem.className = 'edit-color-item';
        colorItem.style.cssText = `
          display: flex;
          align-items: center;
          gap: 15px;
          margin-bottom: 15px;
          padding: 15px;
          background: white;
          border-radius: 8px;
          border: 1px solid #e1e5e9;
        `;
        
        const randomColor = generateRandomColors(1)[0];
        const rgb = hexToRgb(randomColor);
        
        colorItem.innerHTML = `
          <div style="
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 200px;
          ">
            <span style="
              font-weight: 600;
              color: #333;
              min-width: 60px;
            ">Cor ${i + 1}:</span>
            <input type="color" class="edit-color-picker" data-index="${i}" value="${randomColor}" style="
              width: 50px;
              height: 40px;
              border: none;
              border-radius: 6px;
              cursor: pointer;
            ">
          </div>
          
          <input type="text" class="edit-color-hex" data-index="${i}" placeholder="#000000" value="${randomColor}" style="
            width: 100px;
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: monospace;
            text-transform: uppercase;
          ">
          
          <div style="
            display: flex;
            align-items: center;
            gap: 5px;
          ">
            <input type="number" class="edit-rgb-r" data-index="${i}" placeholder="R" min="0" max="255" value="${rgb ? rgb.r : 0}" style="
              width: 60px;
              padding: 8px 12px;
              border: 2px solid #e1e5e9;
              border-radius: 6px;
              font-size: 0.9rem;
              text-align: center;
            ">
            <input type="number" class="edit-rgb-g" data-index="${i}" placeholder="G" min="0" max="255" value="${rgb ? rgb.g : 0}" style="
              width: 60px;
              padding: 8px 12px;
              border: 2px solid #e1e5e9;
              border-radius: 6px;
              font-size: 0.9rem;
              text-align: center;
            ">
            <input type="number" class="edit-rgb-b" data-index="${i}" placeholder="B" min="0" max="255" value="${rgb ? rgb.b : 0}" style="
              width: 60px;
              padding: 8px 12px;
              border: 2px solid #e1e5e9;
              border-radius: 6px;
              font-size: 0.9rem;
              text-align: center;
            ">
          </div>
        `;
        
        container.appendChild(colorItem);
        
        // Adicionar event listeners para a nova cor
        const picker = colorItem.querySelector('.edit-color-picker');
        const hexInput = colorItem.querySelector('.edit-color-hex');
        const rgbInputs = colorItem.querySelectorAll('.edit-rgb-r, .edit-rgb-g, .edit-rgb-b');
        
        picker.addEventListener('input', () => {
          const color = picker.value;
          hexInput.value = color;
          const rgb = hexToRgb(color);
          if (rgb) {
            rgbInputs[0].value = rgb.r;
            rgbInputs[1].value = rgb.g;
            rgbInputs[2].value = rgb.b;
          }
          updateEditPalettePreview(modal);
        });
        
        hexInput.addEventListener('input', () => {
          const color = hexInput.value;
          if (isValidHex(color)) {
            picker.value = color;
            const rgb = hexToRgb(color);
            if (rgb) {
              rgbInputs[0].value = rgb.r;
              rgbInputs[1].value = rgb.g;
              rgbInputs[2].value = rgb.b;
            }
            updateEditPalettePreview(modal);
          }
        });
        
        rgbInputs.forEach((rgbInput, rgbIndex) => {
          rgbInput.addEventListener('input', () => {
            const r = parseInt(rgbInputs[0].value) || 0;
            const g = parseInt(rgbInputs[1].value) || 0;
            const b = parseInt(rgbInputs[2].value) || 0;
            
            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
              const color = rgbToHex(r, g, b);
              picker.value = color;
              hexInput.value = color;
              updateEditPalettePreview(modal);
            }
          });
        });
      }
    } else {
      // Remover cores extras
      for (let i = currentQuantity - 1; i >= newQuantity; i--) {
        const colorItem = container.querySelector(`.edit-color-item:nth-child(${i + 1})`);
        if (colorItem) {
          colorItem.remove();
        }
      }
    }
    
    // Reindexar as cores restantes
    container.querySelectorAll('.edit-color-item').forEach((item, index) => {
      item.querySelector('.edit-color-picker').dataset.index = index;
      item.querySelector('.edit-color-hex').dataset.index = index;
      item.querySelectorAll('.edit-rgb-r, .edit-rgb-g, .edit-rgb-b').forEach(input => {
        input.dataset.index = index;
      });
      item.querySelector('span').textContent = `Cor ${index + 1}:`;
    });
  }
  
  // Função para atualizar preview da paleta no modal de edição
  function updateEditPalettePreview(modal) {
    const colors = [];
    modal.querySelectorAll('.edit-color-picker').forEach(picker => {
      colors.push(picker.value);
    });
    
    const preview = modal.querySelector('#edit-palette-preview');
    if (preview && colors.length > 0) {
      preview.style.background = `linear-gradient(to right, ${colors.join(', ')})`;
      preview.textContent = `${colors.length} cores`;
    }
  }
  
  // Função para salvar configurações do usuário
  function saveUserConfig() {
    const config = {
      field: document.getElementById('field-select').value,
      styleType: document.getElementById('style-type').value,
      geomType: document.getElementById('geom-type').value,
      palette: document.getElementById('palette-select').value,
      paletteOpacity: document.getElementById('palette-opacity').value,
      paletteInvert: document.getElementById('palette-invert').checked,
      classes: document.getElementById('classes').value,
      method: document.getElementById('method').value,
      manualBreaks: document.getElementById('manual-breaks').value,
      strokeColor: document.getElementById('stroke-color').value,
      fillColor: document.getElementById('fill-color').value,
      strokeWeight: document.getElementById('stroke-weight').value,
      fillOpacity: document.getElementById('fill-opacity').value,
      pointRadius: document.getElementById('point-radius').value,
      lineOpacity: document.getElementById('line-opacity').value,
      lineDash: document.getElementById('line-dash').value,
      polygonBorderColor: document.getElementById('polygon-border-color').value,
      polygonBorderWidth: document.getElementById('polygon-border-width').value,
      polygonBorderToggle: document.getElementById('polygon-border-toggle').checked,
      labelField: document.getElementById('label-field-select').value,
      labelFont: document.getElementById('label-font').value,
      labelSize: document.getElementById('label-size').value,
      labelColor: document.getElementById('label-color').value,
      labelBold: document.getElementById('label-bold').checked,
      labelItalic: document.getElementById('label-italic').checked,
      labelBufferColor: document.getElementById('label-buffer-color').value,
      labelBufferSize: document.getElementById('label-buffer-size').value,
      labelBufferOpacity: document.getElementById('label-buffer-opacity').value,
      labelOffsetX: document.getElementById('label-offset-x').value,
      labelOffsetY: document.getElementById('label-offset-y').value,
      labelsEnabled: document.getElementById('labels-enabled').checked,
      compositeLegend: document.getElementById('composite-legend-toggle')?.checked || false,
      timestamp: Date.now() // Adicionar timestamp
    };
    
    localStorage.setItem(`symbology_config_${layerId}`, JSON.stringify(config));
  }
  
  // Função para verificar se um campo é numérico
  function isNumericField(field) {
    if (!layerData || !layerData.features || layerData.features.length === 0) {
      return false;
    }
    
    // Verificar os primeiros valores do campo para determinar se é numérico
    const sampleValues = layerData.features.slice(0, 10).map(f => f.properties[field]);
    
    return sampleValues.every(value => {
      if (value === null || value === undefined || value === '') return false;
      // Aceitar tanto vírgula quanto ponto como separador decimal
      const normalizedValue = value.toString().replace(',', '.');
      const num = parseFloat(normalizedValue);
      return !isNaN(num) && isFinite(num);
    });
  }

  // Função para mostrar aviso sobre campo não numérico
  function showNumericFieldWarning(field) {
    // Verificar se já existe um modal
    let existingModal = document.querySelector('.numeric-validation-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Criar modal estilizado
    const modal = document.createElement('div');
    modal.className = 'numeric-validation-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(5px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease-out;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      background: linear-gradient(135deg, #ffffff, #f8f9fa);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.15);
      max-width: 500px;
      width: 90%;
      position: relative;
      animation: slideInScale 0.3s ease-out;
      border: 1px solid #e9ecef;
    `;
    
    modalContent.innerHTML = `
      <div style="text-align: center; margin-bottom: 20px;">
        <div style="
          width: 60px;
          height: 60px;
          background: linear-gradient(135deg, #ffc107, #fd7e14);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          margin: 0 auto 15px;
          box-shadow: 0 8px 16px rgba(255, 193, 7, 0.3);
        ">
          <i class="fas fa-exclamation-triangle" style="font-size: 24px; color: white;"></i>
        </div>
        <h4 style="color: #212529; margin: 0; font-weight: 600;">Campo Não Numérico Detectado</h4>
      </div>
      
      <div style="margin-bottom: 25px;">
        <p style="color: #6c757d; margin-bottom: 15px; font-size: 16px; line-height: 1.5;">
          O campo <strong style="color: #dc3545;">"${field}"</strong> não contém valores numéricos válidos.
        </p>
        
        <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; border-left: 4px solid #28a745;">
          <p style="margin: 0 0 15px 0; color: #495057; font-weight: 500;">
            <i class="fas fa-info-circle" style="color: #17a2b8; margin-right: 8px;"></i>
            Para simbologia graduada, selecione um campo com:
          </p>
          <ul style="margin: 0; padding-left: 20px; color: #6c757d;">
            <li style="margin-bottom: 8px;">
              <strong>Números inteiros:</strong> 1, 2, 100, 500
            </li>
            <li style="margin-bottom: 8px;">
              <strong>Números decimais:</strong> 1,5 • 23,7 • 99,99
            </li>
          </ul>
        </div>
        
        <div style="background: #e7f3ff; padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #007bff;">
          <p style="margin: 0; color: #495057; font-size: 14px;">
            <i class="fas fa-lightbulb" style="color: #ffc107; margin-right: 8px;"></i>
            <strong>Dica:</strong> A simbologia graduada representa variação numérica através de cores, 
            criando uma representação visual da intensidade dos dados.
          </p>
        </div>
      </div>
      
      <div style="text-align: center;">
        <button id="close-numeric-modal" style="
          background: linear-gradient(135deg, #007bff, #0056b3);
          color: white;
          border: none;
          padding: 12px 30px;
          border-radius: 8px;
          font-size: 16px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 123, 255, 0.4)';" 
           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0, 123, 255, 0.3)';">
          <i class="fas fa-check" style="margin-right: 8px;"></i>
          Entendi
        </button>
      </div>
    `;
    
    // Adicionar CSS de animações se não existir
    if (!document.querySelector('#numeric-modal-animations')) {
      const style = document.createElement('style');
      style.id = 'numeric-modal-animations';
      style.textContent = `
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideInScale {
          from { 
            opacity: 0;
            transform: scale(0.8) translateY(-20px);
          }
          to { 
            opacity: 1;
            transform: scale(1) translateY(0);
          }
        }
        @keyframes fadeOut {
          from { opacity: 1; }
          to { opacity: 0; }
        }
        @keyframes slideOutScale {
          from { 
            opacity: 1;
            transform: scale(1) translateY(0);
          }
          to { 
            opacity: 0;
            transform: scale(0.8) translateY(-20px);
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Event listener para fechar modal
    const closeBtn = modal.querySelector('#close-numeric-modal');
    const closeModal = () => {
      modal.style.animation = 'fadeOut 0.3s ease-out';
      modalContent.style.animation = 'slideOutScale 0.3s ease-out';
      setTimeout(() => {
        if (modal.parentNode) {
          modal.remove();
        }
      }, 300);
    };
    
    closeBtn.addEventListener('click', closeModal);
    
    // Fechar ao clicar no fundo
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeModal();
      }
    });
    
    // Fechar com ESC
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        closeModal();
        document.removeEventListener('keydown', handleEsc);
      }
    };
    document.addEventListener('keydown', handleEsc);
  }

  // Função para mostrar mensagem de sucesso da simbologia com timeout
  function showSymbologySuccessMessage() {
    // Verificar se já existe uma mensagem ativa
    let existingMessage = document.querySelector('.symbology-success-message');
    if (existingMessage) {
      existingMessage.remove();
    }
    
    // Criar nova mensagem
    const message = document.createElement('div');
    message.className = 'alert alert-success symbology-success-message';
    message.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border: none;
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      font-weight: 500;
      max-width: 400px;
      animation: slideInRight 0.3s ease-out;
    `;
    
    message.innerHTML = `
      <div style="display: flex; align-items: center; gap: 10px;">
        <i class="fas fa-check-circle" style="font-size: 18px;"></i>
        <div>
          <strong>Simbologia aplicada com sucesso!</strong><br>
          <small>A camada será exibida com o novo estilo no portal.</small><br>
          <small style="opacity: 0.8;">Esta mensagem se fechará em <span id="countdown">5</span>s</small>
        </div>
        <button type="button" class="btn-close btn-close-white ms-auto" style="font-size: 12px;"></button>
      </div>
    `;
    
    // Adicionar CSS de animação se não existir
    if (!document.querySelector('#symbology-animations')) {
      const style = document.createElement('style');
      style.id = 'symbology-animations';
      style.textContent = `
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
          from { transform: translateX(0); opacity: 1; }
          to { transform: translateX(100%); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Event listener para o botão de fechar
    const closeBtn = message.querySelector('.btn-close');
    closeBtn.addEventListener('click', () => {
      message.style.animation = 'slideOutRight 0.3s ease-out';
      setTimeout(() => message.remove(), 300);
    });
    
    // Adicionar ao documento
    document.body.appendChild(message);
    
    // Implementar contador regressivo
    let countdown = 5;
    const countdownElement = message.querySelector('#countdown');
    
    const countdownInterval = setInterval(() => {
      countdown--;
      if (countdownElement) {
        countdownElement.textContent = countdown;
      }
      
      if (countdown <= 0) {
        clearInterval(countdownInterval);
        if (message.parentNode) {
          message.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => {
            if (message.parentNode) {
              message.remove();
            }
          }, 300);
        }
      }
    }, 1000);
    
    // Limpar interval se a mensagem for fechada manualmente
    const originalCloseHandler = closeBtn.onclick;
    closeBtn.addEventListener('click', () => {
      clearInterval(countdownInterval);
    });
  }

  // Função para salvar simbologia no banco de dados
  async function saveSymbologyToDatabase(config) {
    try {
      const style = computeStyle();
      
      // Adicionar nomes personalizados das classes
      if (style.classes) {
        style.custom_class_names = [];
        for (let i = 0; i < style.classes; i++) {
          const className = localStorage.getItem(`graduated_class_${layerId}_${style.field}_${i}`) || `Classe ${i + 1}`;
          style.custom_class_names.push(className);
        }
      }
      
      // Adicionar configuração da legenda composta
      style.composite_legend = document.getElementById('composite-legend-toggle')?.checked || false;
      
      // Adicionar informações de faixas de valores para a legenda
      if (style.field && layerData) {
        const values = layerData.features
          .map(f => parseFloat(f.properties[style.field]))
          .filter(v => !isNaN(v))
          .sort((a, b) => a - b);
        
        if (values.length > 0) {
          const min = values[0];
          const max = values[values.length - 1];
          const classes = style.classes || 5;
          
          // Gerar breaks baseado no método
          let breaks = [];
          if (style.method === 'equal') {
            const step = (max - min) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(min + (i * step));
            }
          } else if (style.method === 'quantile') {
            const step = values.length / classes;
            for (let i = 0; i <= classes; i++) {
              const index = Math.floor(i * step);
              breaks.push(values[Math.min(index, values.length - 1)]);
            }
          } else if (style.method === 'jenks') {
            const step = values.length / classes;
            for (let i = 0; i <= classes; i++) {
              const index = Math.floor(i * step);
              breaks.push(values[Math.min(index, values.length - 1)]);
            }
          } else if (style.method === 'log') {
            const logMin = Math.log(Math.max(min, 0.1));
            const logMax = Math.log(max);
            const step = (logMax - logMin) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(Math.exp(logMin + (i * step)));
            }
          } else if (style.method === 'stddev') {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            const stddev = Math.sqrt(variance);
            const stddevStep = (2 * stddev) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(mean - stddev + (i * stddevStep));
            }
          } else if (style.method === 'arithmetic') {
            const step = (max - min) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(min + (i * step));
            }
          } else if (style.method === 'geometric') {
            const ratio = Math.pow(max / min, 1 / classes);
            for (let i = 0; i <= classes; i++) {
              breaks.push(min * Math.pow(ratio, i));
            }
          } else if (style.method === 'manual' && style.breaks) {
            breaks = style.breaks;
          }
          
          style.class_breaks = breaks;
        }
      }
      
      console.log('Enviando simbologia para o banco:', style);
      
      const response = await fetch(`/admin/layer/${layerId}/symbology/save`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(style)
      });
      
      if (response.ok) {
        console.log('Simbologia salva no banco de dados com sucesso');
        showSymbologySuccessMessage();
        return true;
      } else {
        const errorData = await response.json();
        console.error('Erro ao salvar simbologia no banco de dados:', errorData);
        showToast(`Erro ao salvar simbologia: ${errorData.message || 'Erro desconhecido'}`, 'error');
      }
    } catch (error) {
      console.error('Erro ao salvar simbologia:', error);
      showToast('Erro ao salvar simbologia no portal', 'error');
    }
  }

  // Função para carregar configurações salvas do usuário
  function loadUserConfig() {
    try {
      const savedConfig = localStorage.getItem(`symbology_config_${layerId}`);
      if (savedConfig) {
        const config = JSON.parse(savedConfig);
        
        // Restaurar configurações básicas
        if (config.field) {
          document.getElementById('field-select').value = config.field;
        }
        if (config.styleType) {
          document.getElementById('style-type').value = config.styleType;
        }
        if (config.geomType) {
          document.getElementById('geom-type').value = config.geomType;
        }
        if (config.palette) {
          document.getElementById('palette-select').value = config.palette;
        }
        if (config.paletteOpacity) {
          document.getElementById('palette-opacity').value = config.paletteOpacity || 1;
          document.getElementById('opacity-value').textContent = config.paletteOpacity;
        }
        if (config.paletteInvert !== undefined) {
          document.getElementById('palette-invert').checked = config.paletteInvert;
        }
        
        // Restaurar configurações de classes e método
        if (config.classes) {
          document.getElementById('classes').value = config.classes;
        }
        if (config.method) {
          document.getElementById('method').value = config.method;
        }
        if (config.manualBreaks) {
          document.getElementById('manual-breaks').value = config.manualBreaks;
        }
        
        // Restaurar configurações de cor personalizada
        if (config.strokeColor) {
          document.getElementById('stroke-color').value = config.strokeColor;
        }
        if (config.fillColor) {
          document.getElementById('fill-color').value = config.fillColor;
        }
        if (config.strokeWeight) {
          document.getElementById('stroke-weight').value = config.strokeWeight;
        }
        if (config.fillOpacity) {
          document.getElementById('fill-opacity').value = config.fillOpacity;
        }
        if (config.pointRadius) {
          document.getElementById('point-radius').value = config.pointRadius;
        }
        if (config.lineOpacity) {
          document.getElementById('line-opacity').value = config.lineOpacity;
        }
        if (config.lineDash) {
          document.getElementById('line-dash').value = config.lineDash;
        }
        
        // Restaurar configurações de polígono
        if (config.polygonBorderColor) {
          document.getElementById('polygon-border-color').value = config.polygonBorderColor;
        }
        if (config.polygonBorderWidth) {
          document.getElementById('polygon-border-width').value = config.polygonBorderWidth;
        }
        if (config.polygonBorderToggle !== undefined) {
          document.getElementById('polygon-border-toggle').checked = config.polygonBorderToggle;
        }
        
        // Restaurar configurações de rótulos
        if (config.labelField) {
          document.getElementById('label-field-select').value = config.labelField;
        }
        if (config.labelFont) {
          document.getElementById('label-font').value = config.labelFont;
        }
        if (config.labelSize) {
          document.getElementById('label-size').value = config.labelSize;
        }
        if (config.labelColor) {
          document.getElementById('label-color').value = config.labelColor;
        }
        if (config.labelBold !== undefined) {
          document.getElementById('label-bold').checked = config.labelBold;
        }
        if (config.labelItalic !== undefined) {
          document.getElementById('label-italic').checked = config.labelItalic;
        }
        if (config.labelBufferColor) {
          document.getElementById('label-buffer-color').value = config.labelBufferColor;
        }
        if (config.labelBufferSize) {
          document.getElementById('label-buffer-size').value = config.labelBufferSize;
        }
        if (config.labelBufferOpacity) {
          document.getElementById('label-buffer-opacity').value = config.labelBufferOpacity;
          document.getElementById('buffer-opacity-value').textContent = config.labelBufferOpacity;
        }
        if (config.labelOffsetX) {
          document.getElementById('label-offset-x').value = config.labelOffsetX;
        }
        if (config.labelOffsetY) {
          document.getElementById('label-offset-y').value = config.labelOffsetY;
        }
        if (config.labelsEnabled !== undefined) {
          document.getElementById('labels-enabled').checked = config.labelsEnabled;
        }
        
        // Restaurar configuração da legenda composta
        if (config.compositeLegend !== undefined) {
          const compositeToggle = document.getElementById('composite-legend-toggle');
          if (compositeToggle) {
            compositeToggle.checked = config.compositeLegend;
          }
        }
        
        return true;
      }
    } catch (error) {
      console.error('Erro ao carregar configurações salvas:', error);
    }
    return false;
  }

  // Função para limpar configurações antigas (mais de 30 dias)
  function clearOldConfigs() {
    const now = Date.now();
    const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
    
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('symbology_config_')) {
        try {
          const config = JSON.parse(localStorage.getItem(key));
          if (config.timestamp && config.timestamp < thirtyDaysAgo) {
            localStorage.removeItem(key);
          }
        } catch (e) {
          // Se não conseguir parsear, remove o item corrompido
          localStorage.removeItem(key);
        }
      }
    });
  }

  // Função para adicionar timestamp às configurações
  function addTimestampToConfig(config) {
    config.timestamp = Date.now();
    return config;
  }

  // Função para mostrar toast de feedback
  function showToast(message, type = 'info') {
    // Criar toast
    const toastDiv = document.createElement('div');
    toastDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
    toastDiv.style.cssText = `
      top: 20px;
      right: 20px;
      z-index: 9999;
      min-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    `;
    
    const iconClass = type === 'success' ? 'fa-check-circle' : 
                     type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle';
    
    toastDiv.innerHTML = `
      <i class="fas ${iconClass}"></i>
      <strong>${type === 'success' ? 'Sucesso!' : type === 'error' ? 'Erro!' : 'Info!'}</strong> ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(toastDiv);
    
    // Auto-remover após 3 segundos
    setTimeout(() => {
      if (toastDiv.parentNode) {
        toastDiv.remove();
      }
    }, 3000);
  }

  // Função para mostrar feedback visual de configurações carregadas
  function showConfigLoadedFeedback() {
    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'alert alert-info alert-dismissible fade show';
    feedbackDiv.innerHTML = `
      <i class="fas fa-info-circle"></i>
      <strong>Configurações restauradas!</strong> Suas últimas configurações foram carregadas automaticamente.
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    const container = document.querySelector('.container-fluid');
    container.insertBefore(feedbackDiv, container.firstChild);
    
    // Auto-remover após 5 segundos
    setTimeout(() => {
      if (feedbackDiv.parentNode) {
        feedbackDiv.remove();
      }
    }, 5000);
  }

  // Função para limpar configurações da camada atual
  function clearCurrentConfig() {
    if (confirm('Tem certeza que deseja limpar todas as configurações salvas para esta camada?')) {
      localStorage.removeItem(`symbology_config_${layerId}`);
      alert('Configurações salvas limpas com sucesso!');
      location.reload(); // Recarrega a página para mostrar que as configurações foram removidas
    }
  }

  // Função para inicializar o mapa
  function initMap() {
    console.log('Inicializando mapa...');
    
    // Verificar se o container existe
    const mapContainer = document.getElementById('symbology-map');
    if (!mapContainer) {
      console.error('Container do mapa não encontrado!');
      return;
    }
    
    // Inicializar mapa Leaflet com coordenadas do Brasil
    map = L.map('symbology-map').setView([-15.7801, -47.9292], 4); // Centro do Brasil
    
    console.log('Mapa criado:', map);
    
    // Adicionar basemap padrão (OpenStreetMap)
    currentBasemap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);
    
    console.log('Basemap padrão adicionado:', currentBasemap);
    
    // Event listener para mudança de basemap
    document.getElementById('basemap-select').addEventListener('change', function() {
      const basemapType = this.value;
      console.log('Mudando basemap para:', basemapType);
      
      // Remover basemap atual
      if (currentBasemap) {
        map.removeLayer(currentBasemap);
      }
      
      // Adicionar novo basemap
      switch (basemapType) {
        case 'osm':
          currentBasemap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
          }).addTo(map);
          break;
        case 'google-streets':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
        case 'google-satellite':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
        case 'google-hybrid':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
        case 'google-terrain':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
      }
      
      console.log('Novo basemap aplicado:', currentBasemap);
    });
    
    // Forçar atualização do mapa
    setTimeout(() => {
      if (map) {
        map.invalidateSize();
        console.log('Mapa atualizado com sucesso');
      }
    }, 100);
  }

  // Função para inicializar a página
  async function initializePage() {
    console.log('Inicializando página...');
    
    // Limpar configurações antigas
    clearOldConfigs();
    
    // Aguardar um pouco para garantir que o DOM esteja pronto
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Inicializar mapa
    initMap();
    
    // Aguardar um pouco para o mapa ser inicializado
    await new Promise(resolve => setTimeout(resolve, 200));
    
    // Carregar campos da camada
    await loadLayerFields();
    
    // Carregar dados da camada (que também restaura configurações)
    await loadLayerData();
    
    // Inicializar visualização da paleta
    updatePalettePreview();
    
    // Forçar atualização do mapa novamente
    if (map) {
      setTimeout(() => {
        map.invalidateSize();
        console.log('Mapa finalizado com sucesso');
      }, 300);
    }
    
    // Mostrar feedback se configurações foram carregadas
    if (localStorage.getItem(`symbology_config_${layerId}`)) {
      showConfigLoadedFeedback();
    }
    
    console.log('Página inicializada com sucesso');
  }

  // Função para aplicar visibilidade dos blocos
  function applyVisibility() {
    const styleType = document.getElementById('style-type').value;
    const geomType = document.getElementById('geom-type').value;
    
    // Blocos condicionais
    document.getElementById('block-classes').classList.toggle('d-none', !['graduated', 'raster'].includes(styleType));
    document.getElementById('block-method').classList.toggle('d-none', !['graduated'].includes(styleType));
    document.getElementById('block-manual').classList.toggle('d-none', !(styleType === 'graduated' && document.getElementById('method').value === 'manual'));
    document.getElementById('block-category-editor').classList.toggle('d-none', styleType !== 'categorized');
    document.getElementById('block-custom-color').classList.toggle('d-none', styleType !== 'single');
    document.getElementById('block-polygon-border').classList.toggle('d-none', geomType !== 'polygon');
    document.getElementById('block-point-only').classList.toggle('d-none', geomType !== 'point');
    document.getElementById('block-line-only').classList.toggle('d-none', geomType !== 'line');
    
    // Controles específicos para linhas na simbologia categorizada
    const lineSpecificControls = document.getElementById('block-line-specific-controls');
    if (lineSpecificControls) {
      lineSpecificControls.classList.toggle('d-none', !(styleType === 'categorized' && geomType === 'line'));
    }
    
    // Mostrar paleta de cores para simbologia categorizada e graduada, ocultar para símbolo único
    document.getElementById('block-palette').classList.toggle('d-none', styleType === 'single');
    
    // Mostrar editor de classes para simbologia graduada
    document.getElementById('block-graduated-classes').classList.toggle('d-none', styleType !== 'graduated');
    
    // Controlar visibilidade do modal method-info - APENAS para simbologia graduada
    const methodInfoContainer = document.getElementById('method-info');
    if (methodInfoContainer) {
      if (styleType === 'graduated') {
        // Mostrar modal method-info APENAS para simbologia graduada
        methodInfoContainer.classList.remove('d-none');
        showMethodInfo();
      } else {
        // Ocultar para TODOS os outros tipos de simbologia (categorized, single, etc.)
        methodInfoContainer.classList.add('d-none');
      }
    }
  }
  
  // Função para mostrar informações padrão quando nenhum método está selecionado
  function showDefaultMethodInfo() {
    const infoContainer = document.getElementById('method-info');
    if (!infoContainer) return;
    
    infoContainer.innerHTML = `
      <div class="method-header">
        <div class="method-icon">
          <i class="fas fa-info-circle"></i>
        </div>
        <div class="method-title-section">
          <div class="method-title">Métodos de Classificação</div>
          <div class="method-description">Escolha um método para ver informações detalhadas</div>
        </div>
      </div>
      <div class="method-content-grid">
        <div class="method-detail-card">
          <div class="detail-header">
            <span class="detail-icon">🔵</span>
            <span class="detail-label">Como funciona</span>
          </div>
          <div class="detail-text">Selecione um método de classificação para visualizar informações detalhadas sobre como ele funciona, quando usá-lo e exemplos práticos.</div>
        </div>
        <div class="method-detail-card">
          <div class="detail-header">
            <span class="detail-icon">🟢</span>
            <span class="detail-label">Ideal para</span>
          </div>
          <div class="detail-text">Cada método tem suas características específicas. Escolha baseado no tipo de dados e objetivo da análise.</div>
        </div>
        <div class="method-detail-card">
          <div class="detail-header">
            <span class="detail-icon">🟡</span>
            <span class="detail-label">Exemplo</span>
          </div>
          <div class="detail-text">Após selecionar um método, você verá exemplos práticos de como ele classifica os dados.</div>
        </div>
      </div>
    `;
  }
  
  // Função para mostrar informações do método de classificação
  function showMethodInfo() {
    const methodSelect = document.getElementById('method');
    const infoContainer = document.getElementById('method-info');
    
    if (!methodSelect || !infoContainer) return;
    
    const selectedMethod = methodSelect.value;
    
    if (!selectedMethod) {
      // Se não há método selecionado, mostra informações padrão
      showDefaultMethodInfo();
      return;
    }
    
    const methodInfos = {
      'equal': {
        icon: 'fa-equals',
        title: 'Intervalos Iguais',
        description: 'Divide o range em classes de mesmo tamanho',
        howItWorks: 'O valor máximo menos o mínimo é dividido pelo número de classes',
        idealFor: 'Dados uniformemente distribuídos',
        example: 'Se os dados vão de 0 a 100 com 5 classes: 0-20, 20-40, 40-60, 60-80, 80-100'
      },
      'quantiles': {
        icon: 'fa-chart-pie',
        title: 'Quantis (Equal Count)',
        description: 'Cada classe tem o mesmo número de elementos',
        howItWorks: 'Os dados são ordenados e divididos em grupos com igual quantidade de registros',
        idealFor: 'Comparações percentuais e dados com distribuição desigual',
        example: 'Com 100 registros e 4 classes: 25 registros por classe (0-25%, 25-50%, 50-75%, 75-100%)'
      },
      'jenks': {
        icon: 'fa-chart-line',
        title: 'Quebras Naturais (Jenks)',
        description: 'Otimiza a separação natural dos dados',
        howItWorks: 'Algoritmo que minimiza variância dentro das classes e maximiza entre classes',
        idealFor: 'Dados com padrões naturais de agrupamento',
        example: 'Identifica automaticamente onde os dados "quebram" naturalmente, como mudanças bruscas de tendência'
      },
      'log': {
        icon: 'fa-chart-area',
        title: 'Classificação Logarítmica',
        description: 'Aplica escala logarítmica antes da classificação',
        howItWorks: 'Transforma os dados usando logaritmo (ln ou log10) antes de aplicar a classificação',
        idealFor: 'Dados com crescimento exponencial ou distribuição log-normal',
        example: 'Para dados de 1 a 1000: log(1)=0, log(10)=1, log(100)=2, log(1000)=3'
      },
      'stddev': {
        icon: 'fa-chart-bar',
        title: 'Desvio Padrão',
        description: 'Cria classes baseadas na média ± múltiplos do desvio padrão',
        howItWorks: 'Calcula a média e desvio padrão, criando classes como: média±1σ, média±2σ, etc.',
        idealFor: 'Destacar valores extremos, anomalias e distribuições normais',
        example: 'Se média=50 e σ=10: 40-60 (1σ), 30-40 e 60-70 (2σ), <30 e >70 (3σ)'
      },
      'arithmetic': {
        icon: 'fa-plus',
        title: 'Progressão Aritmética',
        description: 'Cada classe aumenta por uma diferença constante',
        howItWorks: 'Define uma razão constante (ex: +10) para cada classe subsequente',
        idealFor: 'Dados com crescimento linear constante',
        example: 'Com razão +15: 0-15, 15-30, 30-45, 45-60, 60-75'
      },
      'geometric': {
        icon: 'fa-times',
        title: 'Progressão Geométrica',
        description: 'Cada classe multiplica por uma razão constante',
        howItWorks: 'Define uma razão multiplicativa constante (ex: ×2) para cada classe',
        idealFor: 'Dados com crescimento exponencial ou multiplicativo',
        example: 'Com razão ×2: 1-2, 2-4, 4-8, 8-16, 16-32'
      },
      'manual': {
        icon: 'fa-edit',
        title: 'Classificação Manual',
        description: 'Defina exatamente onde cada classe começa e termina',
        howItWorks: 'Você especifica manualmente os valores de corte para cada classe',
        idealFor: 'Controle total sobre os intervalos e conhecimento específico do domínio',
        example: 'Defina classes como: 0-5, 5-10, 10-20, 20-50, >50'
      }
    };
    
    const info = methodInfos[selectedMethod];
    if (info) {
      infoContainer.innerHTML = `
        <div class="method-header">
          <div class="method-icon">
            <i class="fas ${info.icon}"></i>
          </div>
          <div class="method-title-section">
            <div class="method-title">${info.title}</div>
            <div class="method-description">${info.description}</div>
          </div>
        </div>
        <div class="method-content-grid">
          <div class="method-detail-card">
            <div class="detail-header">
              <span class="detail-icon">🔵</span>
              <span class="detail-label">Como funciona</span>
            </div>
            <div class="detail-text">${info.howItWorks}</div>
          </div>
          <div class="method-detail-card">
            <div class="detail-header">
              <span class="detail-icon">🟢</span>
              <span class="detail-label">Ideal para</span>
            </div>
            <div class="detail-text">${info.idealFor}</div>
          </div>
          <div class="method-detail-card">
            <div class="detail-header">
              <span class="detail-icon">🟡</span>
              <span class="detail-label">Exemplo</span>
            </div>
            <div class="detail-text">${info.example}</div>
          </div>
        </div>
      `;
      infoContainer.classList.remove('d-none');
    } else {
      infoContainer.classList.add('d-none');
    }
  }

  // Função para detectar tipo de geometria da camada
  function detectGeometryType(layerData) {
    if (!layerData || !layerData.features || layerData.features.length === 0) {
      return 'polygon'; // padrão
    }
    
    const firstFeature = layerData.features[0];
    if (!firstFeature.geometry) {
      return 'polygon'; // padrão
    }
    
    const geomType = firstFeature.geometry.type;
    
    switch (geomType.toLowerCase()) {
      case 'point':
      case 'multipoint':
        return 'point';
      case 'linestring':
      case 'multilinestring':
        return 'line';
      case 'polygon':
      case 'multipolygon':
        return 'polygon';
      default:
        return 'polygon'; // padrão
    }
  }

  // Função para carregar campos da camada
  async function loadLayerFields() {
    try {
      const response = await fetch(`/admin/layer/${layerId}/fields`);
      const data = await response.json();
      
      const fieldSelect = document.getElementById('field-select');
      const labelFieldSelect = document.getElementById('label-field-select');
      
      fieldSelect.innerHTML = '<option value="">Selecione uma coluna...</option>';
      labelFieldSelect.innerHTML = '<option value="">Selecione uma coluna...</option>';
      
      data.fields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.name;
        option.textContent = `${field.name} (${field.dtype})`;
        fieldSelect.appendChild(option);
        
        const labelOption = document.createElement('option');
        labelOption.value = field.name;
        labelOption.textContent = `${field.name} (${field.dtype})`;
        labelFieldSelect.appendChild(labelOption);
      });
    } catch (error) {
      console.error('Erro ao carregar campos:', error);
    }
  }

  // Função para carregar categorias para um campo
  async function loadCategoriesForField(field) {
    try {
      console.log(`loadCategoriesForField: Carregando categorias para campo ${field}`);
      
      const response = await fetch(`/admin/layer/${layerId}/classify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ field, mode: 'categorized' })
      });
      
      const data = await response.json();
      console.log(`loadCategoriesForField: Resposta do backend:`, data);
      
      if (data.categories) {
        // Filtrar valores nulos/undefined e tratar campos numéricos de forma robusta
        const cleanCategories = data.categories
          .filter(cat => cat !== null && cat !== undefined && cat !== '')
          .map(cat => {
            // Para campos numéricos, preservar o valor original se possível
            if (typeof cat === 'number' || !isNaN(parseFloat(cat))) {
              // Se for número ou string numérica, converter para número para preservar precisão
              const num = parseFloat(cat);
              return isFinite(num) ? num : cat;
            }
            // Para outros tipos, converter para string para consistência
            return String(cat);
          });
        
        console.log(`loadCategoriesForField: Categorias limpas:`, cleanCategories);
        return cleanCategories;
      } else if (data.error) {
        console.error(`loadCategoriesForField: Erro do backend:`, data.error);
      }
    } catch (error) {
      console.error('loadCategoriesForField: Erro ao carregar categorias:', error);
    }
    return [];
  }



  // Função para distribuir cores de forma inteligente (primeira, última e intermediárias)
  function distributeColorsIntelligently(paletteColors, numClasses) {
    console.log(`distributeColorsIntelligently chamada: ${paletteColors.length} cores da paleta para ${numClasses} classes`);
    
    if (numClasses <= 0) return [];
    if (paletteColors.length === 0) return [];
    
    // Se há apenas uma classe, usar a primeira cor
    if (numClasses === 1) {
      return [paletteColors[0]];
    }
    
    // Se há apenas duas classes, usar primeira e última
    if (numClasses === 2) {
      return [paletteColors[0], paletteColors[paletteColors.length - 1]];
    }
    
    // Para mais de duas classes, distribuir de forma inteligente
    const distributedColors = [];
    
    // Primeira classe: primeira cor da paleta
    distributedColors.push(paletteColors[0]);
    
    // Classes intermediárias: cores distribuídas uniformemente
    if (numClasses > 2) {
      for (let i = 1; i < numClasses - 1; i++) {
        // Calcular índice para distribuição uniforme
        const paletteIndex = Math.floor((i / (numClasses - 1)) * (paletteColors.length - 1));
        const color = paletteColors[paletteIndex];
        distributedColors.push(color);
        console.log(`Classe intermediária ${i}: usando cor da paleta no índice ${paletteIndex} = ${color}`);
      }
    }
    
    // Última classe: última cor da paleta
    distributedColors.push(paletteColors[paletteColors.length - 1]);
    
    console.log(`Cores distribuídas: ${distributedColors.join(' -> ')}`);
    return distributedColors;
  }
  
  // Função para criar interface de classes categorizadas com edição manual
  function createCategorizedClassesInterface(categories) {
    console.log('createCategorizedClassesInterface: Iniciando criação da interface');
    console.log('createCategorizedClassesInterface: Categorias recebidas:', categories);
    
    const container = document.getElementById('category-list');
    if (!container) {
      console.error('createCategorizedClassesInterface: Container category-list não encontrado');
      return;
    }
    
    container.innerHTML = '';
    
    if (!categories || categories.length === 0) {
      console.warn('createCategorizedClassesInterface: Nenhuma categoria fornecida');
      container.innerHTML = '<div class="text-muted">Selecione um campo para editar as categorias.</div>';
      return;
    }
    
    console.log(`createCategorizedClassesInterface: Criando interface para ${categories.length} categorias`);
    
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    
    // Gerar cores da paleta
    let paletteColors;
    if (palette === 'custom') {
      const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
      const selectedPalette = customPalettes.find(p => p.name === palette);
      if (selectedPalette && selectedPalette.colors) {
        paletteColors = selectedPalette.colors;
      } else {
        paletteColors = brewer('Set3', Math.max(categories.length, 12), invert);
      }
    } else {
      paletteColors = brewer(palette, Math.max(categories.length, 12), invert);
    }
    
    // IMPORTANTE: Distribuir cores de forma inteligente (primeira, última e intermediárias)
    const distributedColors = distributeColorsIntelligently(paletteColors, categories.length);
    
    // Carregar cores personalizadas salvas ou usar cores distribuídas da paleta
    const customColors = [];
    const customNames = {};
    
    for (let i = 0; i < categories.length; i++) {
      const category = categories[i];
      const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
      
      // IMPORTANTE: Buscar por todos os índices possíveis para encontrar o nome salvo
      let savedName = null;
      for (let j = 0; j < categories.length; j++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${j}`);
        if (testName) {
          savedName = testName;
          break;
        }
      }
      
      // IMPORTANTE: Preservar cores personalizadas e usar cores distribuídas da paleta apenas se não houver cor salva
      if (savedColor) {
        customColors.push(savedColor);
        console.log(`createCategorizedClassesInterface - Usando cor personalizada para ${category}: ${savedColor}`);
      } else {
        // IMPORTANTE: Para campos numéricos, usar cor baseada no valor original, não na posição
        // Buscar cor salva por valor original da categoria
        let color = null;
        
        // Tentar encontrar cor salva por valor original (não por posição)
        if (typeof category === 'number' || !isNaN(parseFloat(category))) {
          // Para campos numéricos, buscar cor salva por valor
          const savedColorByValue = localStorage.getItem(`category_color_${layerId}_${category}`);
          if (savedColorByValue) {
            color = savedColorByValue;
            console.log(`createCategorizedClassesInterface - Usando cor salva por valor para ${category}: ${color}`);
          }
        }
        
        // Se não encontrou cor salva, usar cor distribuída da paleta baseada na posição original
        if (!color) {
          color = distributedColors[i];
          console.log(`createCategorizedClassesInterface - Gerando cor distribuída da paleta para ${category} na posição ${i}: ${color}`);
        }
        
        customColors.push(color);
      }
      
      if (savedName) {
        customNames[category] = savedName;
      }
    }
    
    // Criar interface para cada categoria
    customColors.forEach((color, index) => {
      const category = categories[index];
      const div = document.createElement('div');
      div.className = 'categorized-class-item p-3 border rounded mb-2 bg-light';
      div.setAttribute('draggable', 'true');
      div.setAttribute('data-index', index);
      div.setAttribute('data-category', category);
      
      div.innerHTML = `
        <!-- Header: Nome da categoria, preview e drag handle -->
        <div class="category-header d-flex align-items-center justify-content-between mb-2">
          <div class="d-flex align-items-center gap-2 flex-grow-1">
            <div class="drag-handle" style="cursor: move; color: #6c757d;">
              <i class="fas fa-grip-vertical"></i>
            </div>
            <div class="color-preview" style="width: 30px; height: 30px; background-color: ${color}; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;" data-index="${index}" data-category="${category}"></div>
            <input type="text" class="form-control form-control-sm categorized-class-name"
                   value="${customNames[category] || category}" data-index="${index}" data-category="${category}"
                   style="min-width: 150px;" placeholder="Nome da categoria">
            <span class="text-muted small ms-2">
              <span class="category-value" data-index="${index}">${category}</span>
            </span>
          </div>
          <button type="button" class="btn btn-outline-danger btn-sm remove-category-btn"
                  data-index="${index}" data-category="${category}" title="Remover categoria">
            <i class="fas fa-trash"></i>
          </button>
        </div>
        
        <!-- Corpo: Controles organizados em seções -->
        <div class="category-body">
          <!-- Seção de Cor -->
          <div class="control-section color-section mb-2">
            <div class="section-header d-flex align-items-center gap-2 mb-1">
              <i class="fas fa-palette text-primary"></i>
              <span class="small fw-bold">Cor</span>
            </div>
            <div class="d-flex align-items-center gap-2">
              <input type="color" class="form-control form-control-color categorized-class-color"
                     value="${color}" data-index="${index}" data-category="${category}" style="width: 40px; height: 30px;" title="Seletor de cor">
              <input type="text" class="form-control form-control-sm categorized-class-hex"
                     value="${color}" data-index="${index}" data-category="${category}" style="width: 80px;" placeholder="HEX" title="Código HEX">
              <button type="button" class="btn btn-outline-secondary btn-sm categorized-class-rgb-btn"
                      data-index="${index}" data-category="${category}" title="Mostrar/ocultar campos RGB">
                <i class="fas fa-sliders-h"></i> RGB
              </button>
            </div>
            
            <!-- Campos RGB (inicialmente ocultos) -->
            <div class="categorized-class-rgb-inputs d-none mt-2" data-index="${index}" data-category="${category}">
              <div class="d-flex align-items-center gap-2">
                <label class="form-label small mb-0 me-1">R:</label>
                <input type="number" class="form-control form-control-sm" min="0" max="255"
                       placeholder="R" style="width: 50px;" title="Valor Vermelho (0-255)">
                <label class="form-label small mb-0 me-1">G:</label>
                <input type="number" class="form-control form-control-sm" min="0" max="255"
                       placeholder="G" style="width: 50px;" title="Valor Verde (0-255)">
                <label class="form-label small mb-0 me-1">B:</label>
                <input type="number" class="form-control form-control-sm" min="0" max="255"
                       placeholder="B" style="width: 50px;" title="Valor Azul (0-255)">
              </div>
            </div>
          </div>
          
          <!-- Seção de Controles de Linha (apenas quando geom-type = line) -->
          ${document.getElementById('geom-type').value === 'line' ? `
          <div class="control-section line-section">
            <div class="section-header d-flex align-items-center gap-2 mb-1">
              <i class="fas fa-minus text-success"></i>
              <span class="small fw-bold">Propriedades da Linha</span>
            </div>
            <div class="line-controls-grid">
              <div class="control-group">
                <label class="form-label small mb-1">Espessura</label>
                <input type="number" class="form-control form-control-sm line-weight-input line-control-individual" 
                       value="2" min="1" max="10" step="0.5" style="width: 60px;" 
                       title="Espessura da linha para esta categoria">
              </div>
              
              <div class="control-group">
                <label class="form-label small mb-1">Opacidade</label>
                <input type="range" class="form-range form-range-sm line-opacity-input line-control-individual" 
                       min="0" max="1" step="0.05" value="1" style="width: 60px;" 
                       title="Opacidade da linha para esta categoria">
              </div>
              
              <div class="control-group">
                <label class="form-label small mb-1">Estilo</label>
                <select class="form-select form-select-sm line-style-select line-control-individual" 
                        style="width: 80px;" title="Estilo da linha para esta categoria">
                  <option value="">Contínua</option>
                  <option value="5,5">Tracejada</option>
                  <option value="10,5">Tracejada Longa</option>
                  <option value="2,2">Pontilhada</option>
                  <option value="1,1">Pontilhada Fina</option>
                  <option value="5,2,1,2">Traço-Ponto</option>
                  <option value="10,2,1,2">Traço-Ponto Longo</option>
                </select>
              </div>
              
              <!-- Controle de Espaçamento -->
              <div class="control-group line-spacing-controls" data-index="${index}" data-category="${category}">
                <label class="form-label small mb-1">Espaçamento</label>
                <div class="d-flex align-items-center gap-1">
                  <input type="range" class="form-range form-range-sm line-spacing-slider line-control-individual" 
                         value="10" min="1" max="30" step="0.5" style="width: 80px;" 
                         title="Ajustar espaçamento entre traços/pontos">
                  <span class="line-spacing-value small text-muted" style="min-width: 35px;">10px</span>
                </div>
              </div>
            </div>
          </div>
          ` : ''}
        </div>
      `;
      
      container.appendChild(div);
      
      // Adicionar event listeners
      addCategorizedClassEventListeners(div, index, category, color);
    });
    
    // Adicionar funcionalidade de drag & drop
    setupDragAndDrop();
    
    // Configurar event listeners para controles específicos de linha
    if (document.getElementById('geom-type').value === 'line') {
      setupLineSpecificControls();
    }
    
              // IMPORTANTE: Forçar sincronização da interface após criação completa
          setTimeout(() => {
            console.log('Forçando sincronização da interface após criação completa');
            forceCategorizedInterfaceSyncWithRetry(10, 200);
            
            // Verificar se ainda precisa de sincronização após um tempo
            setTimeout(() => {
              forceInterfaceSyncIfNeeded();
            }, 500);
            
            // IMPORTANTE: Forçar aplicação da ordem personalizada
            setTimeout(() => {
              forceApplySavedOrder();
            }, 400);
            
            // Configurar monitor de sincronização da interface
            setupInterfaceSyncMonitor();
          }, 300);
    
    console.log('Interface de classes categorizadas criada com', categories.length, 'categorias');
  }
  
  // Função para adicionar event listeners para uma classe categorizada
  function addCategorizedClassEventListeners(div, index, category, initialColor) {
    const colorPreview = div.querySelector('.color-preview');
    const colorInput = div.querySelector('.categorized-class-color');
    const hexInput = div.querySelector('.categorized-class-hex');
    const rgbBtn = div.querySelector('.categorized-class-rgb-btn');
    const rgbInputs = div.querySelector('.categorized-class-rgb-inputs');
    const nameInput = div.querySelector('.categorized-class-name');
    const removeBtn = div.querySelector('.remove-category-btn');
    
    // Converter cor inicial para RGB
    const rgb = hexToRgb(initialColor);
    if (rgb && rgbInputs) {
      const rInput = rgbInputs.querySelector('input[placeholder="R"]');
      const gInput = rgbInputs.querySelector('input[placeholder="G"]');
      const bInput = rgbInputs.querySelector('input[placeholder="B"]');
      if (rInput && gInput && bInput) {
        rInput.value = rgb.r;
        gInput.value = rgb.g;
        bInput.value = rgb.b;
      }
    }
    
    // Event listener para seletor de cor
    colorInput.addEventListener('input', function() {
      const newColor = this.value;
      updateCategorizedClassColor(index, category, newColor);
    });
    
    // Event listener para campo HEX
    hexInput.addEventListener('input', function() {
      const newColor = this.value;
      if (isValidHex(newColor)) {
        updateCategorizedClassColor(index, category, newColor);
      }
    });
    
    // Event listener para botão RGB
    rgbBtn.addEventListener('click', function() {
      rgbInputs.classList.toggle('d-none');
      this.classList.toggle('btn-secondary');
      this.classList.toggle('btn-outline-secondary');
    });
    
    // Event listeners para campos RGB
    const rInput = rgbInputs.querySelector('input[placeholder="R"]');
    const gInput = rgbInputs.querySelector('input[placeholder="G"]');
    const bInput = rgbInputs.querySelector('input[placeholder="B"]');
    
    [rInput, gInput, bInput].forEach(input => {
      input.addEventListener('input', function() {
        const r = parseInt(rInput.value) || 0;
        const g = parseInt(gInput.value) || 0;
        const b = parseInt(bInput.value) || 0;
        const newColor = rgbToHex(r, g, b);
        updateCategorizedClassColor(index, category, newColor);
      });
    });
    
    // Event listener para edição do nome da categoria
    nameInput.addEventListener('input', function() {
      const newName = this.value;
      updateCategorizedClassName(index, category, newName);
    });
    
    // Event listener para remover categoria
    removeBtn.addEventListener('click', function() {
      removeCategorizedClass(index, category);
    });
    
    // Limitar a 50 caracteres
    nameInput.setAttribute('maxlength', '50');
    
    // Event listeners para controles específicos de linha (se existirem)
    const lineWeightInput = div.querySelector('.line-weight-input');
    const lineOpacityInput = div.querySelector('.line-opacity-input');
    const lineStyleSelect = div.querySelector('.line-style-select');
    
    if (lineWeightInput) {
      lineWeightInput.addEventListener('change', function() {
        console.log(`Espessura da linha alterada para categoria ${category}:`, this.value);
        updatePreviewAndMapSynchronized();
      });
    }
    
    if (lineOpacityInput) {
      lineOpacityInput.addEventListener('input', function() {
        console.log(`Opacidade da linha alterada para categoria ${category}:`, this.value);
        updatePreviewAndMapSynchronized();
      });
    }
    
    if (lineStyleSelect) {
      lineStyleSelect.addEventListener('change', function() {
        console.log(`Estilo da linha alterado para categoria ${category}:`, this.value);
        
        // Mostrar/ocultar controles de espaçamento baseado na seleção
        const spacingControls = div.querySelector(`.line-spacing-controls[data-index="${index}"][data-category="${category}"]`);
        
        console.log(`Mudança de estilo para categoria ${category}: novo valor=${this.value}, controles encontrados=${!!spacingControls}`);
        
        if (spacingControls) {
          if (this.value === '') {
            // Estilo "Contínua" - ocultar completamente os controles
            spacingControls.classList.add('hidden');
            console.log(`Ocultando controles de espaçamento para categoria ${category}`);
          } else {
            // Outros estilos - mostrar controles
            spacingControls.classList.remove('hidden');
            console.log(`Mostrando controles de espaçamento para categoria ${category}`);
          }
        } else {
          console.warn(`Controles de espaçamento não encontrados para categoria ${category}`);
        }
        
        // Forçar atualização imediata do mapa
        setTimeout(() => {
          updatePreviewAndMapSynchronized();
        }, 100);
      });
    }
    
    // Event listener para o slider de espaçamento
    const spacingSlider = div.querySelector('.line-spacing-slider');
    if (spacingSlider) {
      spacingSlider.addEventListener('input', function() {
        // Atualizar valor exibido
        const valueDisplay = div.querySelector('.line-spacing-value');
        if (valueDisplay) {
          valueDisplay.textContent = this.value + 'px';
        }
        
        console.log(`Espaçamento da linha alterado para categoria ${category}:`, this.value);
        
        // Salvar valor no localStorage
        localStorage.setItem(`line_spacing_${layerId}_${category}`, this.value);
        
        // Forçar atualização imediata do mapa
        setTimeout(() => {
          updatePreviewAndMapSynchronized();
        }, 100);
      });
      
      // Carregar valor salvo se existir
      const savedSpacing = localStorage.getItem(`line_spacing_${layerId}_${category}`);
      if (savedSpacing) {
        spacingSlider.value = savedSpacing;
        const valueDisplay = div.querySelector('.line-spacing-value');
        if (valueDisplay) {
          valueDisplay.textContent = savedSpacing + 'px';
        }
      } else {
        // Se não houver valor salvo, usar padrão de 10px
        spacingSlider.value = 10;
        const valueDisplay = div.querySelector('.line-spacing-value');
        if (valueDisplay) {
          valueDisplay.textContent = '10px';
        }
      }
      
      // Definir estado inicial dos controles baseado no estilo selecionado
      const styleSelect = div.querySelector('.line-style-select');
      const spacingControls = div.querySelector(`.line-spacing-controls[data-index="${index}"][data-category="${category}"]`);
      
      if (styleSelect && spacingControls) {
        console.log(`Estado inicial para categoria ${category}: estilo=${styleSelect.value}, controles=${spacingControls ? 'encontrados' : 'não encontrados'}`);
        
        if (styleSelect.value === '') {
          // Estilo "Contínua" - ocultar controles
          spacingControls.classList.add('hidden');
          console.log(`Ocultando controles de espaçamento para categoria ${category} (estilo Contínua)`);
        } else {
          // Outros estilos - mostrar controles
          spacingControls.classList.remove('hidden');
          console.log(`Mostrando controles de espaçamento para categoria ${category}`);
        }
      } else {
        console.warn(`Elementos não encontrados para categoria ${category}: styleSelect=${!!styleSelect}, spacingControls=${!!spacingControls}`);
      }
    }
  }
  
  // Função para atualizar cor de uma classe categorizada
  function updateCategorizedClassColor(index, category, newColor) {
    // Atualizar preview visual
    const colorPreview = document.querySelector(`.color-preview[data-index="${index}"][data-category="${category}"]`);
    if (colorPreview) {
      colorPreview.style.backgroundColor = newColor;
    }
    
    // Atualizar campo HEX
    const hexInput = document.querySelector(`.categorized-class-hex[data-index="${index}"][data-category="${category}"]`);
    if (hexInput) {
      hexInput.value = newColor;
    }
    
    // Atualizar campos RGB se estiverem visíveis
    const rgbInputs = document.querySelector(`.categorized-class-rgb-inputs[data-index="${index}"][data-category="${category}"]`);
    if (rgbInputs && !rgbInputs.classList.contains('d-none')) {
      const rgb = hexToRgb(newColor);
      if (rgb) {
        const rInput = rgbInputs.querySelector('input[placeholder="R"]');
        const gInput = rgbInputs.querySelector('input[placeholder="G"]');
        const bInput = rgbInputs.querySelector('input[placeholder="B"]');
        if (rInput && gInput && bInput) {
          rInput.value = rgb.r;
          gInput.value = rgb.g;
          bInput.value = rgb.b;
        }
      }
    }
    
    // Salvar cor personalizada
    localStorage.setItem(`category_color_${layerId}_${category}`, newColor);
    
    // Atualizar preview e mapa INSTANTANEAMENTE
    updatePreviewAndMapSynchronized();
    
    // Salvar configuração
    saveUserConfig();
  }
  
  // Função para atualizar nome de uma classe categorizada
  function updateCategorizedClassName(index, category, newName) {
    console.log(`updateCategorizedClassName chamada: index=${index}, category=${category}, newName=${newName}`);
    
    // Verificar se o nome realmente mudou
    if (newName === category) {
      console.log('Nome não mudou, removendo entrada do localStorage');
      localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${index}`);
    } else {
      // Salvar nome personalizado
      const key = `categorized_class_name_${layerId}_${category}_${index}`;
      localStorage.setItem(key, newName);
      console.log(`Nome salvo no localStorage com chave: ${key} = ${newName}`);
      
      // Verificar se foi salvo corretamente
      const savedName = localStorage.getItem(key);
      console.log(`Nome verificado no localStorage: ${savedName}`);
    }
    
    // Limpar nomes duplicados e atualizar preview e mapa
    cleanupDuplicateNames();
    
    // IMPORTANTE: Forçar sincronização da legenda com a interface após edição (com retry)
    setTimeout(() => {
      forceCategorizedLegendSyncWithRetry();
    }, 100);
    
    updatePreviewAndMapSynchronized();
    
    // Salvar configuração
    saveUserConfig();
  }
  
  // Função para remover uma classe categorizada
  function removeCategorizedClass(index, category) {
    if (confirm(`Tem certeza que deseja remover a categoria "${category}"?`)) {
      // Remover do localStorage
      localStorage.removeItem(`category_color_${layerId}_${category}`);
      
      // Remover TODOS os nomes personalizados para esta categoria (todos os índices possíveis)
      for (let i = 0; i < 1000; i++) { // Limite alto para garantir que todos sejam removidos
        localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${i}`);
      }
      
      // Remover elemento do DOM
      const element = document.querySelector(`.categorized-class-item[data-index="${index}"][data-category="${category}"]`);
      if (element) {
        element.remove();
      }
      
      // Limpar nomes duplicados e atualizar preview e mapa
      cleanupDuplicateNames();
      
      // IMPORTANTE: Forçar sincronização da legenda com a interface após remoção (com retry)
      setTimeout(() => {
        forceCategorizedLegendSyncWithRetry();
      }, 100);
      
      updatePreviewAndMapSynchronized();
      
      // Salvar configuração
      saveUserConfig();
    }
  }
  
  // Função para reconectar event listeners dos controles de espaçamento após reordenação
  function reattachSpacingControlsEventListeners() {
    console.log('🔧 reattachSpacingControlsEventListeners: Reconectando controles de espaçamento...');
    
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    console.log(`🔧 Encontrados ${categoryItems.length} itens de categoria para reconectar`);
    
    categoryItems.forEach((item, index) => {
      const category = item.dataset.category;
      const lineStyleSelect = item.querySelector('.line-style-select');
      const spacingControls = item.querySelector('.line-spacing-controls');
      const spacingSlider = item.querySelector('.line-spacing-slider');
      const spacingValue = item.querySelector('.line-spacing-value');
      
      console.log(`🔧 Reconectando categoria ${category} (índice ${index}):`, {
        lineStyleSelect: !!lineStyleSelect,
        spacingControls: !!spacingControls,
        spacingSlider: !!spacingSlider,
        spacingValue: !!spacingValue
      });
      
      if (lineStyleSelect && spacingControls) {
        // Remover event listeners antigos (se existirem)
        const newLineStyleSelect = lineStyleSelect.cloneNode(true);
        lineStyleSelect.parentNode.replaceChild(newLineStyleSelect, lineStyleSelect);
        
        // Adicionar novo event listener
        newLineStyleSelect.addEventListener('change', function() {
          console.log(`🔧 Mudança de estilo para categoria ${category}: novo valor="${this.value}"`);
          
          if (this.value === '' || this.value === null || this.value === undefined) {
            // Estilo "Contínua" - ocultar controles
            spacingControls.classList.add('hidden');
            console.log(`✅ Ocultando controles de espaçamento para categoria ${category} (estilo Contínua)`);
          } else {
            // Outros estilos - mostrar controles
            spacingControls.classList.remove('hidden');
            console.log(`✅ Mostrando controles de espaçamento para categoria ${category} (estilo: ${this.value})`);
          }
          
          // Atualizar preview e mapa
          updatePreviewAndMapSynchronized();
        });
        
        // Definir estado inicial baseado no valor atual
        if (newLineStyleSelect.value === '' || newLineStyleSelect.value === null || newLineStyleSelect.value === undefined) {
          spacingControls.classList.add('hidden');
          console.log(`✅ Estado inicial: Ocultando controles de espaçamento para categoria ${category} (estilo Contínua)`);
        } else {
          spacingControls.classList.remove('hidden');
          console.log(`✅ Estado inicial: Mostrando controles de espaçamento para categoria ${category} (estilo: ${newLineStyleSelect.value})`);
        }
      }
      
      // Reconectar event listener do slider de espaçamento
      if (spacingSlider && spacingValue) {
        // Remover event listeners antigos
        const newSpacingSlider = spacingSlider.cloneNode(true);
        spacingSlider.parentNode.replaceChild(newSpacingSlider, spacingSlider);
        
        // Adicionar novo event listener
        newSpacingSlider.addEventListener('input', function() {
          spacingValue.textContent = this.value + 'px';
          
          // Salvar no localStorage
          const field = document.getElementById('field-select').value;
          if (field) {
            localStorage.setItem(`line_spacing_${layerId}_${field}_${category}`, this.value);
          }
          
          // Atualizar preview e mapa
          updatePreviewAndMapSynchronized();
        });
        
        // Carregar valor salvo
        const field = document.getElementById('field-select').value;
        if (field) {
          const savedSpacing = localStorage.getItem(`line_spacing_${layerId}_${field}_${category}`);
          if (savedSpacing) {
            newSpacingSlider.value = savedSpacing;
            spacingValue.textContent = savedSpacing + 'px';
          }
        }
      }
    });
    
    console.log('🔧 Reconexão dos controles de espaçamento concluída!');
  }
  
  // Função para configurar drag & drop
  function setupDragAndDrop() {
    const container = document.getElementById('category-list');
    if (!container) return;
    
    let draggedElement = null;
    let draggedIndex = null;
    
    // Event listeners para drag & drop
    container.addEventListener('dragstart', function(e) {
      if (e.target.closest('.categorized-class-item')) {
        draggedElement = e.target.closest('.categorized-class-item');
        draggedIndex = parseInt(draggedElement.dataset.index);
        draggedElement.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        
        // Adicionar classe de feedback visual
        container.classList.add('drag-over');
      }
    });
    
    container.addEventListener('dragend', function(e) {
      if (draggedElement) {
        draggedElement.classList.remove('dragging');
        draggedElement = null;
        draggedIndex = null;
        
        // Remover classe de feedback visual
        container.classList.remove('drag-over');
      }
    });
    
    container.addEventListener('dragover', function(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      
      // Adicionar feedback visual durante o drag
      if (!container.classList.contains('drag-over')) {
        container.classList.add('drag-over');
      }
    });
    
    container.addEventListener('dragleave', function(e) {
      // Só remover a classe se não estiver arrastando sobre um item filho
      if (!e.target.closest('.categorized-class-item')) {
        container.classList.remove('drag-over');
      }
    });
    
    container.addEventListener('drop', function(e) {
      e.preventDefault();
      
      if (!draggedElement) return;
      
      const targetElement = e.target.closest('.categorized-class-item');
      if (!targetElement || targetElement === draggedElement) return;
      
      const targetIndex = parseInt(targetElement.dataset.index);
      
      // Reordenar elementos
      reorderCategorizedClasses(draggedIndex, targetIndex);
      
      // Atualizar preview e mapa INSTANTANEAMENTE
      updatePreviewAndMapSynchronized();
      
      // Salvar configuração
      saveUserConfig();
      
      // Remover classe de feedback visual
      container.classList.remove('drag-over');
    });
  }
  
  // Função para reordenar classes categorizadas
  function reorderCategorizedClasses(fromIndex, toIndex) {
    const container = document.getElementById('category-list');
    if (!container) return;
    
    const items = Array.from(container.querySelectorAll('.categorized-class-item'));
    if (fromIndex < 0 || fromIndex >= items.length || toIndex < 0 || toIndex >= items.length) return;
    
    console.log(`Reordenando categoria do índice ${fromIndex} para ${toIndex}`);
    
    // Mover elemento
    const item = items[fromIndex];
    if (fromIndex < toIndex) {
      container.insertBefore(item, items[toIndex + 1]);
    } else {
      container.insertBefore(item, items[toIndex]);
    }
    
    // Atualizar índices e preservar nomes personalizados
    const updatedItems = Array.from(container.querySelectorAll('.categorized-class-item'));
    const field = document.getElementById('field-select').value;
    
    // Coletar todos os nomes personalizados e cores personalizadas antes de atualizar índices
    const savedNames = {};
    const savedColors = {};
    updatedItems.forEach((item, index) => {
      const category = item.dataset.category;
      const nameInput = item.querySelector('.categorized-class-name');
      const colorInput = item.querySelector('.categorized-class-color');
      
      if (nameInput && nameInput.value !== category) {
        savedNames[category] = nameInput.value;
      }
      
      if (colorInput) {
        savedColors[category] = colorInput.value;
      }
    });
    
    // Atualizar índices
    updatedItems.forEach((item, index) => {
      item.dataset.index = index;
      item.querySelectorAll('[data-index]').forEach(el => {
        el.dataset.index = index;
      });
    });
    
    // Salvar nova ordem no localStorage
    if (field) {
      const newOrder = updatedItems.map(item => item.dataset.category);
      localStorage.setItem(`categorized_order_${layerId}_${field}`, JSON.stringify(newOrder));
      console.log('Nova ordem salva:', newOrder);
    }
    
    // Reaplicar nomes personalizados e cores personalizadas com novos índices
    if (Object.keys(savedNames).length > 0 || Object.keys(savedColors).length > 0) {
      updatedItems.forEach((item, index) => {
        const category = item.dataset.category;
        
        // Reaplicar nome personalizado
        if (savedNames[category]) {
          // Salvar nome com novo índice
          localStorage.setItem(`categorized_class_name_${layerId}_${category}_${index}`, savedNames[category]);
          // Atualizar input
          const nameInput = item.querySelector('.categorized-class-name');
          if (nameInput) {
            nameInput.value = savedNames[category];
          }
        }
        
        // Reaplicar cor personalizada
        if (savedColors[category]) {
          // Salvar cor (não precisa de índice, é única por categoria)
          localStorage.setItem(`category_color_${layerId}_${category}`, savedColors[category]);
          // Atualizar inputs de cor
          const colorInput = item.querySelector('.categorized-class-color');
          const hexInput = item.querySelector('.categorized-class-hex');
          const colorPreview = item.querySelector('.color-preview');
          
          if (colorInput) colorInput.value = savedColors[category];
          if (hexInput) hexInput.value = savedColors[category];
          if (colorPreview) colorPreview.style.backgroundColor = savedColors[category];
        }
      });
      console.log('Nomes e cores personalizados reaplicados com novos índices');
    }
    
    console.log(`Categoria movida do índice ${fromIndex} para ${toIndex}`);
    
    // Limpar nomes duplicados e atualizar preview e mapa
    cleanupDuplicateNames();
    
    // IMPORTANTE: Forçar sincronização da legenda com a interface após reordenação (com retry)
    setTimeout(() => {
      forceCategorizedLegendSyncWithRetry();
    }, 100);
    
    // IMPORTANTE: Reconfigurar controles de espaçamento após reordenação
    setTimeout(() => {
      console.log('Reconfigurando controles de espaçamento após reordenação...');
      reattachSpacingControlsEventListeners();
    }, 150);
    
    updatePreviewAndMapSynchronized();
  }
  
  // Função para atualizar cores das classes categorizadas quando a paleta muda
  function updateCategorizedClassColors() {
    console.log('updateCategorizedClassColors: Iniciando atualização de cores');
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') {
      console.log('updateCategorizedClassColors: Não é simbologia categorizada, saindo');
      return;
    }
    
    const field = document.getElementById('field-select').value;
    if (!field) {
      console.log('updateCategorizedClassColors: Nenhum campo selecionado, saindo');
      return;
    }
    
    console.log(`updateCategorizedClassColors: Recarregando categorias para campo ${field}`);
    
    // Recarregar categorias e aplicar nova paleta, preservando informações do usuário
    loadCategoriesForField(field).then(categories => {
      console.log(`updateCategorizedClassColors: Categorias recarregadas:`, categories);
      
      try {
        // Preservar ordem personalizada
        const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
        let orderArray = [];
        
        if (savedOrder) {
          try {
            orderArray = JSON.parse(savedOrder);
            console.log(`updateCategorizedClassColors: Ordem personalizada carregada:`, orderArray);
          } catch (e) {
            console.warn('updateCategorizedClassColors: Erro ao carregar ordem personalizada:', e);
          }
        }
        
        // Preservar nomes personalizados e cores personalizadas
        const savedNames = {};
        const savedColors = {};
        categories.forEach((category, index) => {
          console.log(`updateCategorizedClassColors: Processando categoria ${index}: ${category}`);
          
          // IMPORTANTE: Buscar por todos os índices possíveis para encontrar o nome salvo
          let savedName = null;
          for (let j = 0; j < categories.length; j++) {
            const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${j}`);
            if (testName) {
              savedName = testName;
              break;
            }
          }
          
          // IMPORTANTE: Preservar cor personalizada por valor original da categoria
          const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
          
          if (savedName) {
            savedNames[category] = savedName;
            console.log(`updateCategorizedClassColors: Nome personalizado encontrado para ${category}: ${savedName}`);
          }
          
          if (savedColor) {
            savedColors[category] = savedColor;
            console.log(`updateCategorizedClassColors: Cor personalizada encontrada para ${category}: ${savedColor}`);
          }
        });
        
        console.log(`updateCategorizedClassColors: Nomes salvos:`, savedNames);
        console.log(`updateCategorizedClassColors: Cores salvas:`, savedColors);
        
        // IMPORTANTE: Criar interface preservando informações do usuário
        // Mas primeiro, garantir que as cores sejam preservadas por valor, não por posição
        console.log('updateCategorizedClassColors: Criando interface de categorias...');
        
        // IMPORTANTE: Preservar cores personalizadas por valor original da categoria
        const preservedColors = {};
        categories.forEach(category => {
          const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
          if (savedColor) {
            preservedColors[category] = savedColor;
            console.log(`updateCategorizedClassColors: Preservando cor para ${category}: ${savedColor}`);
          }
        });
        
        // Criar interface com cores preservadas
        createCategorizedClassesInterface(categories);
        
        // IMPORTANTE: Aplicar cores preservadas após criar a interface
        if (Object.keys(preservedColors).length > 0) {
          setTimeout(() => {
            const categoryItems = Array.from(document.querySelectorAll('.categorized-class-item'));
            categoryItems.forEach(item => {
              const category = item.dataset.category;
              const savedColor = preservedColors[category];
              if (savedColor) {
                // Atualizar inputs de cor
                const colorInput = item.querySelector('.categorized-class-color');
                const hexInput = item.querySelector('.categorized-class-hex');
                const colorPreview = item.querySelector('.color-preview');
                
                if (colorInput) colorInput.value = savedColor;
                if (hexInput) hexInput.value = savedColor;
                if (colorPreview) colorPreview.style.backgroundColor = savedColor;
                
                console.log(`updateCategorizedClassColors: Cor preservada aplicada para ${category}: ${savedColor}`);
              }
            });
          }, 100);
        }
        
        // Aplicar ordem personalizada se existir
        if (orderArray.length > 0) {
          console.log('updateCategorizedClassColors: Aplicando ordem personalizada...');
          applySavedOrder(orderArray, savedNames, savedColors);
          
          // IMPORTANTE: Configurar controles de espaçamento após aplicar ordem salva
          setTimeout(() => {
            console.log('updateCategorizedClassColors: Configurando controles de espaçamento após ordem salva...');
            reattachSpacingControlsEventListeners();
          }, 300);
        }
        
        // Limpar nomes duplicados e atualizar preview e mapa
        console.log('updateCategorizedClassColors: Limpando nomes duplicados...');
        cleanupDuplicateNames();
        
            // IMPORTANTE: Forçar sincronização da legenda com a interface após mudança de paleta (com retry)
    setTimeout(() => {
      console.log('updateCategorizedClassColors: Forçando sincronização da legenda...');
      forceCategorizedLegendSyncWithRetry();
    }, 200);
    
    // IMPORTANTE: Configurar controles de espaçamento após criar interface
    setTimeout(() => {
      console.log('updateCategorizedClassColors: Configurando controles de espaçamento...');
      reattachSpacingControlsEventListeners();
    }, 250);
    
    console.log('updateCategorizedClassColors: Atualizando preview e mapa...');
    updatePreviewAndMapSynchronized();
        
      } catch (error) {
        console.error('updateCategorizedClassColors: Erro durante processamento:', error);
        console.error('updateCategorizedClassColors: Stack trace:', error.stack);
      }
    }).catch(error => {
      console.error('updateCategorizedClassColors: Erro ao carregar categorias:', error);
      console.error('updateCategorizedClassColors: Stack trace:', error.stack);
    });
  }
  
  // Função para aplicar ordem salva
  function applySavedOrder(orderArray, savedNames, savedColors = {}) {
    const container = document.getElementById('category-list');
    if (!container) return;
    
    const items = Array.from(container.querySelectorAll('.categorized-class-item'));
    
    console.log(`Aplicando ordem personalizada para ${items.length} itens:`, orderArray);
    
    // IMPORTANTE: Reordenar baseado na ordem salva de forma mais robusta
    const reorderedItems = [];
    
    // Primeiro, adicionar itens na ordem salva
    orderArray.forEach((originalValue, newIndex) => {
      const item = items.find(item => {
        const category = item.dataset.category;
        if (category === originalValue) return true;
        // Para campos numéricos, comparar também como números
        if (typeof category === 'number' && typeof originalValue === 'number') {
          return Math.abs(category - originalValue) < 1e-10; // Tolerância para precisão numérica
        }
        // Para strings numéricas, converter e comparar
        if (!isNaN(parseFloat(category)) && !isNaN(parseFloat(originalValue))) {
          return Math.abs(parseFloat(category) - parseFloat(originalValue)) < 1e-10;
        }
        return false;
      });
      if (item) {
        reorderedItems.push(item);
        console.log(`Item ${originalValue} movido para posição ${reorderedItems.length - 1}`);
      }
    });
    
    // Depois, adicionar itens que não estão na ordem salva (novas categorias)
    items.forEach(item => {
      const category = item.dataset.category;
      const isInOrder = orderArray.some(originalValue => {
        if (category === originalValue) return true;
        // Para campos numéricos, comparar também como números
        if (typeof category === 'number' && typeof originalValue === 'number') {
          return Math.abs(category - originalValue) < 1e-10; // Tolerância para precisão numérica
        }
        // Para strings numéricas, converter e comparar
        if (!isNaN(parseFloat(category)) && !isNaN(parseFloat(originalValue))) {
          return Math.abs(parseFloat(category) - parseFloat(originalValue)) < 1e-10;
        }
        return false;
      });
      
      if (!isInOrder) {
        reorderedItems.push(item);
        console.log(`Item ${category} (novo) adicionado na posição ${reorderedItems.length - 1}`);
      }
    });
    
    // Aplicar nova ordem na interface
    reorderedItems.forEach((item, newIndex) => {
      // Atualizar atributo data-index
      item.setAttribute('data-index', newIndex);
      
      // Mover elemento para a nova posição
      container.appendChild(item);
    });
    
    console.log(`Reordenação concluída: ${reorderedItems.length} itens na nova ordem`);
    
    // Atualizar índices em todos os elementos filhos
    const updatedItems = Array.from(container.querySelectorAll('.categorized-class-item'));
    updatedItems.forEach((item, index) => {
      item.dataset.index = index;
      item.querySelectorAll('[data-index]').forEach(el => {
        el.dataset.index = index;
      });
    });
    
    // Aplicar nomes personalizados e cores personalizadas se disponíveis
    if (savedNames && Object.keys(savedNames).length > 0) {
      updatedItems.forEach((item, index) => {
        const category = item.dataset.category;
        const nameInput = item.querySelector('.categorized-class-name');
        // Para campos numéricos, buscar por todos os tipos de comparação
        const savedName = findSavedNameForCategory(category, savedNames);
        if (nameInput && savedName) {
          nameInput.value = savedName;
          // Salvar o nome com o novo índice
          localStorage.setItem(`categorized_class_name_${layerId}_${category}_${index}`, savedName);
          console.log(`Nome personalizado aplicado para ${category} na posição ${index}: ${savedName}`);
        }
      });
    }
    
    // Aplicar cores personalizadas se disponíveis
    if (savedColors && Object.keys(savedColors).length > 0) {
      updatedItems.forEach((item, index) => {
        const category = item.dataset.category;
        // Para campos numéricos, buscar por todos os tipos de comparação
        const savedColor = findSavedColorForCategory(category, savedColors);
        if (savedColor) {
          // Atualizar inputs de cor
          const colorInput = item.querySelector('.categorized-class-color');
          const hexInput = item.querySelector('.categorized-class-hex');
          const colorPreview = item.querySelector('.color-preview');
          
          if (colorInput) colorInput.value = savedColor;
          if (hexInput) hexInput.value = savedColor;
          if (colorPreview) colorPreview.style.backgroundColor = savedColor;
          
          console.log(`Cor personalizada aplicada para ${category} na posição ${index}: ${savedColor}`);
        }
      });
    }
    
    // IMPORTANTE: Reconfigurar drag & drop após reordenação
    setTimeout(() => {
      console.log('Reconfigurando drag & drop após aplicar ordem personalizada');
      setupDragAndDrop();
    }, 100);
    
    console.log('Ordem personalizada aplicada com sucesso:', orderArray);
  }
  
  // Função auxiliar para encontrar nome salvo para uma categoria (tratando campos numéricos)
  function findSavedNameForCategory(category, savedNames) {
    // Busca direta
    if (savedNames[category]) return savedNames[category];
    
    // Para campos numéricos, buscar por todos os tipos de comparação
    for (const [savedCategory, savedName] of Object.entries(savedNames)) {
      if (savedCategory === category) return savedName;
      // Para campos numéricos, comparar também como números
      if (typeof savedCategory === 'number' && typeof category === 'number') {
        if (Math.abs(savedCategory - category) < 1e-10) return savedName; // Tolerância para precisão numérica
      }
      // Para strings numéricas, converter e comparar
      if (!isNaN(parseFloat(savedCategory)) && !isNaN(parseFloat(category))) {
        if (Math.abs(parseFloat(savedCategory) - parseFloat(category)) < 1e-10) return savedName;
      }
    }
    return null;
  }
  
  // Função auxiliar para encontrar cor salva para uma categoria (tratando campos numéricos)
  function findSavedColorForCategory(category, savedColors) {
    // Busca direta
    if (savedColors[category]) return savedColors[category];
    
    // Para campos numéricos, buscar por todos os tipos de comparação
    for (const [savedCategory, savedColor] of Object.entries(savedColors)) {
      if (savedCategory === category) return savedColor;
      // Para campos numéricos, comparar também como números
      if (typeof savedCategory === 'number' && typeof category === 'number') {
        if (Math.abs(savedCategory - category) < 1e-10) return savedColor; // Tolerância para precisão numérica
      }
      // Para strings numéricas, converter e comparar
      if (!isNaN(parseFloat(savedCategory)) && !isNaN(parseFloat(category))) {
        if (Math.abs(parseFloat(savedCategory) - parseFloat(category)) < 1e-10) return savedColor;
      }
    }
    return null;
  }

  // Função para atualizar preview e mapa de forma sincronizada
  function updatePreviewAndMapSynchronized() {
    console.log('updatePreviewAndMapSynchronized chamada');
    
          // IMPORTANTE: Para simbologia categorizada, sempre sincronizar com a interface
      const currentStyleType = document.getElementById('style-type').value;
      if (currentStyleType === 'categorized') {
        console.log('Simbologia categorizada detectada - sincronizando com interface');
        
        // Forçar atualização da interface primeiro
        const field = document.getElementById('field-select').value;
        if (field) {
          // Verificar se a interface existe e está atualizada
          const categoryList = document.getElementById('category-list');
          if (categoryList && categoryList.children.length > 0) {
            console.log('Interface de categorias encontrada - sincronizando');
            
            // Atualizar preview diretamente da interface
            const legendDiv = document.getElementById('preview-legend');
            if (legendDiv) {
              const style = computeStyle();
              console.log('Style computado para simbologia categorizada:', style);
              console.log('Categorias do style:', style.categories);
              renderCategorizedPreviewFromInterface(legendDiv, style);
            }
            
            // Atualizar mapa
            setTimeout(() => {
              try {
                console.log('Chamando renderMapPreview para simbologia categorizada...');
                renderMapPreview();
              } catch (error) {
                console.error('Erro ao renderizar mapa:', error);
              }
            }, 10);
            
            return; // Sair da função para simbologia categorizada
          }
        }
      }
    
    // Para outros tipos de simbologia, usar o método padrão
    setTimeout(() => {
      console.log('Executando refreshPreview e renderMapPreview (método padrão)');
      
      try {
        // Atualizar preview primeiro
        refreshPreview();
        
        // Atualizar mapa em seguida
        setTimeout(() => {
          try {
            renderMapPreview();
          } catch (error) {
            console.error('Erro ao renderizar mapa:', error);
          }
        }, 10);
      } catch (error) {
        console.error('Erro ao atualizar preview:', error);
      }
    }, 10);
  }
  
  // Função para renderizar preview categorizado diretamente da interface
  function renderCategorizedPreviewFromInterface(legendDiv, style) {
    console.log('renderCategorizedPreviewFromInterface chamada');
    
    // IMPORTANTE: Buscar informações diretamente da interface "Cores e Nomes das Classes"
    const categoryList = document.getElementById('category-list');
    if (!categoryList) {
      console.log('Interface de categorias não encontrada, usando fallback');
      renderCategorizedPreviewFallback(legendDiv, style);
      return;
    }
    
    // Obter todas as categorias da interface
    const categoryItems = Array.from(categoryList.querySelectorAll('.categorized-class-item'));
    if (categoryItems.length === 0) {
      console.log('Nenhuma categoria encontrada na interface, usando fallback');
      renderCategorizedPreviewFallback(legendDiv, style);
      return;
    }
    
    console.log(`Encontradas ${categoryItems.length} categorias na interface`);
    
    // Verificar se as categorias têm dados válidos
    let validCategories = 0;
    const categories = categoryItems.map((item, index) => {
      const category = item.dataset.category;
      const colorInput = item.querySelector('.categorized-class-color');
      const nameInput = item.querySelector('.categorized-class-name');
      
      if (!colorInput || !nameInput) {
        console.log(`Categoria ${index}: inputs não encontrados`);
        return null;
      }
      
      const color = colorInput.value;
      const name = nameInput.value;
      
      // Verificar se os dados são válidos
      if (!color || color === '#cccccc' || !name) {
        console.log(`Categoria ${index}: dados inválidos - cor: ${color}, nome: ${name}`);
        return null;
      }
      
      validCategories++;
      console.log(`Categoria ${index}: ${category} -> ${name}, cor: ${color}`);
      
      return {
        category: name,
        color: color,
        original_value: category,
        index: index
      };
    }).filter(Boolean); // Remover categorias inválidas
    
    if (validCategories === 0) {
      console.log('Nenhuma categoria válida encontrada na interface, usando fallback');
      renderCategorizedPreviewFallback(legendDiv, style);
      return;
    }
    
    console.log(`Categorias válidas encontradas: ${validCategories}/${categoryItems.length}`);
    
    // Aplicar ordem personalizada se existir
    const field = style.field;
    let orderedCategories = [...categories];
    
    if (field) {
      const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
      if (savedOrder) {
        try {
          const orderArray = JSON.parse(savedOrder);
          console.log('Aplicando ordem personalizada:', orderArray);
          
          // Reordenar baseado na ordem salva
          orderedCategories = orderArray.map(originalValue => {
            return categories.find(cat => {
              if (cat.original_value === originalValue) return true;
              // Para campos numéricos, comparar também como números
              if (typeof cat.original_value === 'number' && typeof originalValue === 'number') {
                return Math.abs(cat.original_value - originalValue) < 1e-10; // Tolerância para precisão numérica
              }
              // Para strings numéricas, converter e comparar
              if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(originalValue))) {
                return Math.abs(parseFloat(cat.original_value) - parseFloat(originalValue)) < 1e-10;
              }
              return false;
            });
          }).filter(Boolean);
          
          // Adicionar categorias que não estão na ordem salva
          categories.forEach(cat => {
            const isInOrder = orderArray.some(originalValue => {
              if (cat.original_value === originalValue) return true;
              // Para campos numéricos, comparar também como números
              if (typeof cat.original_value === 'number' && typeof originalValue === 'number') {
                return Math.abs(cat.original_value - originalValue) < 1e-10; // Tolerância para precisão numérica
              }
              // Para strings numéricas, converter e comparar
              if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(originalValue))) {
                return Math.abs(parseFloat(cat.original_value) - parseFloat(originalValue)) < 1e-10;
              }
              return false;
            });
            
            if (!isInOrder) {
              orderedCategories.push(cat);
            }
          });
        } catch (e) {
          console.warn('Erro ao aplicar ordem personalizada:', e);
        }
      }
    }
    
    // Renderizar legenda
    const legendTitle = style.palette ? `Legenda Categorizada - Paleta: ${style.palette}` : 'Legenda Categorizada';
    
    legendDiv.innerHTML = `
      <div class="mb-2">
        <h6 class="text-primary mb-2">${legendTitle}</h6>
        <small class="text-muted">${orderedCategories.length} categorias encontradas</small>
      </div>
      ${orderedCategories.map((cat, index) => `
        <div class="d-flex align-items-center gap-3 p-2 border rounded mb-2 bg-light">
          <div class="d-flex align-items-center gap-2">
            <div style="width: 24px; height: 24px; background-color: ${cat.color}; border: 2px solid #333; border-radius: 4px;"></div>
            <span class="fw-bold">${index + 1}.</span>
          </div>
          <div class="flex-grow-1">
            <div class="fw-semibold">${cat.category}</div>
            <small class="text-muted">Cor: ${cat.color}</small>
          </div>
        </div>
      `).join('')}
    `;
    
    console.log('Legenda categorizada renderizada da interface:', orderedCategories);
  }
  
  // Função de fallback para quando a interface não estiver disponível
  function renderCategorizedPreviewFallback(legendDiv, style) {
    console.log('renderCategorizedPreviewFallback chamada');
    
    const legendTitle = style.palette ? `Legenda Categorizada - Paleta: ${style.palette}` : 'Legenda Categorizada';
    
    // Garantir que as categorias tenham cores válidas
    const validCategories = style.categories.filter(cat => cat && cat.color && cat.category);
    
    if (validCategories.length === 0) {
      legendDiv.innerHTML = `
        <div class="mb-2">
          <h6 class="text-primary mb-2">${legendTitle}</h6>
          <small class="text-muted text-warning">Nenhuma categoria encontrada. Selecione um campo válido.</small>
        </div>
      `;
      return;
    }
    
    // Carregar ordem personalizada das categorias se existir
    const field = style.field;
    let orderedCategories = [...validCategories];
    
    if (field) {
      const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
      if (savedOrder) {
        try {
          const orderArray = JSON.parse(savedOrder);
          // Reordenar baseado na ordem salva
          orderedCategories = orderArray.map(originalValue => {
            return validCategories.find(cat => {
              if (cat.original_value === originalValue) return true;
              // Para campos numéricos, comparar também como números
              if (typeof cat.original_value === 'number' && typeof originalValue === 'number') {
                return Math.abs(cat.original_value - originalValue) < 1e-10; // Tolerância para precisão numérica
              }
              // Para strings numéricas, converter e comparar
              if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(originalValue))) {
                return Math.abs(parseFloat(cat.original_value) - parseFloat(originalValue)) < 1e-10;
              }
              return false;
            });
          }).filter(Boolean);
          
          // Adicionar categorias que não estão na ordem salva
          validCategories.forEach(cat => {
            const isInOrder = orderArray.some(originalValue => {
              if (cat.original_value === originalValue) return true;
              // Para campos numéricos, comparar também como números
              if (typeof cat.original_value === 'number' && typeof originalValue === 'number') {
                return Math.abs(cat.original_value - originalValue) < 1e-10; // Tolerância para precisão numérica
              }
              // Para strings numéricas, converter e comparar
              if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(originalValue))) {
                return Math.abs(parseFloat(cat.original_value) - parseFloat(originalValue)) < 1e-10;
              }
              return false;
            });
            
            if (!isInOrder) {
              orderedCategories.push(cat);
            }
          });
        } catch (e) {
          console.warn('Erro ao carregar ordem personalizada:', e);
        }
      }
    }
    
    // Aplicar cores e nomes personalizados se disponíveis
    orderedCategories = orderedCategories.map((cat, index) => {
      const savedColor = localStorage.getItem(`category_color_${layerId}_${cat.original_value}`);
      
      // Buscar por todos os índices possíveis para encontrar o nome salvo
      let savedName = null;
      for (let i = 0; i < orderedCategories.length; i++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${cat.original_value}_${i}`);
        if (testName) {
          savedName = testName;
          break;
        }
      }
      
      let updatedCat = { ...cat };
      
      // Preservar cores personalizadas - não sobrescrever se já existe
      if (savedColor && !cat.color) {
        updatedCat.color = savedColor;
      }
      
      if (savedName) {
        updatedCat.category = savedName;
      }
      
      return updatedCat;
    });
    
    legendDiv.innerHTML = `
      <div class="mb-2">
        <h6 class="text-primary mb-2">${legendTitle}</h6>
        <small class="text-muted">${orderedCategories.length} categorias encontradas</small>
      </div>
      ${orderedCategories.map((cat, index) => `
        <div class="d-flex align-items-center gap-3 p-2 border rounded mb-2 bg-light">
          <div class="d-flex align-items-center gap-2">
            <div style="width: 24px; height: 24px; background-color: ${cat.color}; border: 2px solid #333; border-radius: 4px;"></div>
            <span class="fw-bold">${index + 1}.</span>
          </div>
          <div class="flex-grow-1">
            <div class="fw-semibold">${cat.category}</div>
            <small class="text-muted">Cor: ${cat.color}</small>
          </div>
        </div>
      `).join('')}
    `;
    
    console.log('Legenda categorizada renderizada do fallback:', orderedCategories);
  }
  
  // Função para forçar sincronização da legenda categorizada com a interface
  function forceCategorizedLegendSync() {
    console.log('forceCategorizedLegendSync chamada');
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') return;
    
    const field = document.getElementById('field-select').value;
    if (!field) return;
    
    const categoryList = document.getElementById('category-list');
    if (!categoryList || categoryList.children.length === 0) return;
    
    const legendDiv = document.getElementById('preview-legend');
    if (!legendDiv) return;
    
    console.log('Forçando sincronização da legenda categorizada com a interface');
    
    // Sincronizar diretamente com a interface
    const style = computeStyle();
    renderCategorizedPreviewFromInterface(legendDiv, style);
    
    // Atualizar mapa também
    setTimeout(() => {
      try {
        renderMapPreview();
      } catch (error) {
        console.error('Erro ao renderizar mapa na sincronização forçada:', error);
      }
    }, 50);
  }
  
  // Função para forçar sincronização com retry e verificação de interface
  function forceCategorizedLegendSyncWithRetry(maxRetries = 10, delay = 200) {
    console.log(`forceCategorizedLegendSyncWithRetry chamada - maxRetries: ${maxRetries}, delay: ${delay}ms`);
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') {
      console.log('Não é simbologia categorizada, abortando');
      return;
    }
    
    const field = document.getElementById('field-select').value;
    if (!field) {
      console.log('Campo não selecionado, abortando');
      return;
    }
    
    // Verificar se a interface está pronta
    const categoryList = document.getElementById('category-list');
    const legendDiv = document.getElementById('preview-legend');
    
    if (!categoryList) {
      console.log('Interface category-list não encontrada');
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: aguardando interface...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    if (!legendDiv) {
      console.log('Interface preview-legend não encontrada');
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: aguardando interface...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    // Verificar se há categorias na interface
    const categoryItems = categoryList.querySelectorAll('.categorized-class-item');
    if (categoryItems.length === 0) {
      console.log(`Interface encontrada mas sem categorias (${categoryItems.length})`);
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: aguardando categorias...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    console.log(`Interface pronta! Encontradas ${categoryItems.length} categorias`);
    
    // Verificar se as categorias têm dados válidos
    let hasValidData = false;
    categoryItems.forEach((item, index) => {
      const colorInput = item.querySelector('.categorized-class-color');
      const nameInput = item.querySelector('.categorized-class-name');
      
      if (colorInput && nameInput) {
        const color = colorInput.value;
        const name = nameInput.value;
        if (color && color !== '#cccccc' && name) {
          hasValidData = true;
          console.log(`Categoria ${index}: ${name} - ${color}`);
        }
      }
    });
    
    if (!hasValidData) {
      console.log('Interface encontrada mas sem dados válidos');
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: aguardando dados válidos...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    console.log('Interface completamente pronta, executando sincronização');
    
    // Executar sincronização
    try {
      const style = computeStyle();
      renderCategorizedPreviewFromInterface(legendDiv, style);
      
      // Atualizar mapa também
      setTimeout(() => {
        try {
          renderMapPreview();
          console.log('Sincronização completa com sucesso!');
        } catch (error) {
          console.error('Erro ao renderizar mapa na sincronização:', error);
        }
      }, 100);
      
    } catch (error) {
      console.error('Erro durante a sincronização:', error);
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: retry após erro...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
    }
  }
  
  // Função para forçar sincronização após carregamento completo da página
  function forceSyncAfterPageLoad() {
    console.log('forceSyncAfterPageLoad chamada');
    
    // Aguardar um pouco mais para garantir que tudo esteja carregado
    setTimeout(() => {
      const styleType = document.getElementById('style-type').value;
      if (styleType === 'categorized') {
        console.log('Simbologia categorizada detectada - forçando sincronização após carregamento');
        
        // IMPORTANTE: Sincronizar tanto a interface quanto a legenda
        forceCategorizedInterfaceSyncWithRetry(15, 300); // Interface primeiro
        forceCategorizedLegendSyncWithRetry(15, 300);   // Legenda depois
      }
    }, 500);
  }
  
  // Função para forçar sincronização da interface "Cores e Nomes das Classes"
  function forceCategorizedInterfaceSyncWithRetry(maxRetries = 15, delay = 300) {
    console.log(`forceCategorizedInterfaceSyncWithRetry chamada - maxRetries: ${maxRetries}, delay: ${delay}ms`);
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') {
      console.log('Não é simbologia categorizada, abortando sincronização da interface');
      return;
    }
    
    const field = document.getElementById('field-select').value;
    if (!field) {
      console.log('Campo não selecionado, abortando sincronização da interface');
      return;
    }
    
    // Verificar se a interface está pronta
    const categoryList = document.getElementById('category-list');
    if (!categoryList) {
      console.log('Interface category-list não encontrada');
      if (maxRetries > 0) {
        console.log(`Tentativa ${16 - maxRetries}: aguardando interface...`);
        setTimeout(() => {
          forceCategorizedInterfaceSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    // Verificar se há categorias na interface
    const categoryItems = categoryList.querySelectorAll('.categorized-class-item');
    if (categoryItems.length === 0) {
      console.log(`Interface encontrada mas sem categorias (${categoryItems.length})`);
      if (maxRetries > 0) {
        console.log(`Tentativa ${16 - maxRetries}: aguardando categorias...`);
        setTimeout(() => {
          forceCategorizedInterfaceSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    console.log(`Interface encontrada com ${categoryItems.length} categorias - verificando dados e ordem...`);
    
    // IMPORTANTE: Primeiro, aplicar ordem personalizada se existir E for válida
    const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
    if (savedOrder && savedOrder !== '[]') {
      try {
        const orderArray = JSON.parse(savedOrder);
        console.log('Verificando ordem personalizada salva:', orderArray);
        
        // IMPORTANTE: Só reordenar se a ordem salva for diferente da ordem atual
        const currentOrder = Array.from(categoryItems).map(item => item.dataset.category);
        const orderChanged = JSON.stringify(currentOrder) !== JSON.stringify(orderArray);
        
        if (orderChanged) {
          console.log('Ordem personalizada diferente da atual - aplicando reordenação');
          console.log('Ordem atual:', currentOrder);
          console.log('Ordem salva:', orderArray);
          
          // Reordenar os elementos da interface baseado na ordem salva
          const reorderedItems = [];
          
          // Primeiro, adicionar itens na ordem salva
          orderArray.forEach(originalValue => {
            const item = Array.from(categoryItems).find(item => item.dataset.category === originalValue);
            if (item) {
              reorderedItems.push(item);
            }
          });
          
          // Depois, adicionar itens que não estão na ordem salva (novas categorias)
          categoryItems.forEach(item => {
            const category = item.dataset.category;
            if (!orderArray.includes(category)) {
              reorderedItems.push(item);
            }
          });
          
          // Aplicar nova ordem na interface
          reorderedItems.forEach((item, newIndex) => {
            // Atualizar atributo data-index
            item.setAttribute('data-index', newIndex);
            
            // Mover elemento para a nova posição
            categoryList.appendChild(item);
          });
          
          console.log(`Interface reordenada: ${reorderedItems.length} categorias na nova ordem`);
        } else {
          console.log('Ordem atual já está correta - não é necessário reordenar');
        }
        
      } catch (e) {
        console.warn('Erro ao aplicar ordem personalizada na interface:', e);
      }
    } else {
      console.log('Nenhuma ordem personalizada encontrada - mantendo ordem original das categorias');
    }
    
    // Agora verificar se as categorias têm dados válidos e sincronizar com localStorage
    let syncNeeded = false;
    let syncCompleted = 0;
    
    // Obter categorias atualizadas após reordenação
    const updatedCategoryItems = categoryList.querySelectorAll('.categorized-class-item');
    
    updatedCategoryItems.forEach((item, index) => {
      const category = item.dataset.category;
      const colorInput = item.querySelector('.categorized-class-color');
      const nameInput = item.querySelector('.categorized-class-name');
      const hexInput = item.querySelector('.categorized-class-hex');
      const colorPreview = item.querySelector('.color-preview');
      
      if (!colorInput || !nameInput) {
        console.log(`Categoria ${index}: inputs não encontrados`);
        return;
      }
      
      // Buscar dados salvos no localStorage
      const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
      let savedName = null;
      
      // Buscar nome salvo por todos os índices possíveis
      for (let i = 0; i < 1000; i++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
        if (testName && testName !== category) {
          savedName = testName;
          break;
        }
      }
      
      // Verificar se precisa sincronizar
      let needsSync = false;
      
      if (savedColor && colorInput.value !== savedColor) {
        console.log(`Categoria ${index}: cor desincronizada - interface: ${colorInput.value}, localStorage: ${savedColor}`);
        needsSync = true;
      }
      
      if (savedName && nameInput.value !== savedName) {
        console.log(`Categoria ${index}: nome desincronizado - interface: ${nameInput.value}, localStorage: ${savedName}`);
        needsSync = true;
      }
      
      if (needsSync) {
        syncNeeded = true;
        
        // Sincronizar cor
        if (savedColor) {
          colorInput.value = savedColor;
          if (hexInput) hexInput.value = savedColor;
          if (colorPreview) colorPreview.style.backgroundColor = savedColor;
          console.log(`Categoria ${index}: cor sincronizada para ${savedColor}`);
        }
        
        // Sincronizar nome
        if (savedName) {
          nameInput.value = savedName;
          console.log(`Categoria ${index}: nome sincronizado para ${savedName}`);
        }
        
        syncCompleted++;
      }
    });
    
    if (syncNeeded) {
      console.log(`Sincronização da interface concluída: ${syncCompleted} categorias atualizadas`);
      
      // Disparar eventos para garantir que as mudanças sejam aplicadas
      updatedCategoryItems.forEach((item) => {
        const colorInput = item.querySelector('.categorized-class-color');
        const nameInput = item.querySelector('.categorized-class-name');
        
        if (colorInput) {
          colorInput.dispatchEvent(new Event('input', { bubbles: true }));
          colorInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        if (nameInput) {
          nameInput.dispatchEvent(new Event('input', { bubbles: true }));
          nameInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });
      
      // Aguardar um pouco e forçar atualização da legenda
      setTimeout(() => {
        console.log('Forçando atualização da legenda após sincronização da interface');
        forceCategorizedLegendSyncWithRetry(5, 100);
      }, 200);
      
    } else {
      console.log('Interface já está sincronizada com localStorage');
    }
    
    // IMPORTANTE: Reconfigurar drag & drop após reordenação
    if (savedOrder) {
      setTimeout(() => {
        console.log('Reconfigurando drag & drop após reordenação');
        setupDragAndDrop();
        
        // IMPORTANTE: Forçar aplicação da ordem personalizada novamente para garantir
        setTimeout(() => {
          console.log('Forçando aplicação da ordem personalizada novamente para garantir');
          forceApplySavedOrder();
        }, 200);
      }, 100);
    }
  }
  
  // Função para forçar sincronização da interface quando necessário
  function forceInterfaceSyncIfNeeded() {
    console.log('forceInterfaceSyncIfNeeded chamada');
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') return;
    
    const field = document.getElementById('field-select').value;
    if (!field) return;
    
    // Verificar se há dados salvos que precisam ser sincronizados
    const categoryList = document.getElementById('category-list');
    if (!categoryList) return;
    
    const categoryItems = categoryList.querySelectorAll('.categorized-class-item');
    if (categoryItems.length === 0) return;
    
    let needsSync = false;
    
    categoryItems.forEach((item) => {
      const category = item.dataset.category;
      const colorInput = item.querySelector('.categorized-class-color');
      const nameInput = item.querySelector('.categorized-class-name');
      
      if (!colorInput || !nameInput) return;
      
      const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
      let savedName = null;
      
      for (let i = 0; i < 1000; i++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
        if (testName && testName !== category) {
          savedName = testName;
          break;
        }
      }
      
      if ((savedColor && colorInput.value !== savedColor) || 
          (savedName && nameInput.value !== savedName)) {
        needsSync = true;
      }
    });
    
    if (needsSync) {
      console.log('Interface precisa de sincronização - forçando...');
      forceCategorizedInterfaceSyncWithRetry(5, 100);
    }
  }
  
  // Função para forçar aplicação da ordem personalizada
  function forceApplySavedOrder() {
    console.log('forceApplySavedOrder chamada');
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') return;
    
    const field = document.getElementById('field-select').value;
    if (!field) return;
    
    const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
    if (!savedOrder) {
      console.log('Nenhuma ordem personalizada encontrada para aplicar');
      return;
    }
    
    try {
      const orderArray = JSON.parse(savedOrder);
      console.log('Forçando aplicação da ordem personalizada:', orderArray);
      
      // Buscar dados salvos
      const savedNames = {};
      const savedColors = {};
      
      orderArray.forEach(category => {
        // Buscar nome personalizado
        for (let i = 0; i < 1000; i++) {
          const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
          if (testName && testName !== category) {
            savedNames[category] = testName;
            break;
          }
        }
        
        // Buscar cor personalizada
        const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
        if (savedColor) {
          savedColors[category] = savedColor;
        }
      });
      
      // Aplicar ordem personalizada
      applySavedOrder(orderArray, savedNames, savedColors);
      
    } catch (e) {
      console.error('Erro ao forçar aplicação da ordem personalizada:', e);
    }
  }
  
  // Função para monitorar mudanças na interface e forçar sincronização
  function setupInterfaceSyncMonitor() {
    console.log('setupInterfaceSyncMonitor chamada');
    
    // Monitorar mudanças na interface usando MutationObserver
    const categoryList = document.getElementById('category-list');
    if (!categoryList) {
      console.log('Interface category-list não encontrada para monitoramento');
      return;
    }
    
    const observer = new MutationObserver((mutations) => {
      let needsSync = false;
      
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList' || mutation.type === 'attributes') {
          // Verificar se há mudanças que afetam a sincronização
          const target = mutation.target;
          if (target.classList && target.classList.contains('categorized-class-item')) {
            needsSync = true;
          }
        }
      });
      
      if (needsSync) {
        console.log('Mudanças detectadas na interface - verificando sincronização...');
        setTimeout(() => {
          forceInterfaceSyncIfNeeded();
        }, 100);
      }
    });
    
    // Configurar observador
    observer.observe(categoryList, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['value', 'style']
    });
    
    console.log('Monitor de sincronização da interface configurado');
  }
  
  // Função para verificar e corrigir consistência dos dados
  function validateAndFixDataConsistency() {
    const field = document.getElementById('field-select').value;
    if (!field || !layerData || !layerData.features) return;
    
    console.log('Verificando consistência dos dados...');
    
    // Obter todas as categorias do campo e tratar campos numéricos de forma robusta
    const uniqueValues = [...new Set(layerData.features.map(f => {
      const value = f.properties[field];
      // Para campos numéricos, preservar o valor original se possível
      if (typeof value === 'number' || !isNaN(parseFloat(value))) {
        const num = parseFloat(value);
        return isFinite(num) ? num : value;
      }
      return value;
    }))];
    
    // Verificar se há ordem personalizada válida
    const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
    if (savedOrder) {
      try {
        const orderArray = JSON.parse(savedOrder);
        // Verificar se a ordem salva ainda é válida
        const validOrder = orderArray.filter(value => {
          if (uniqueValues.includes(value)) return true;
          // Para campos numéricos, comparar também como números
          return uniqueValues.some(uniqueValue => {
            if (uniqueValue === value) return true;
            // Para campos numéricos, comparar também como números
            if (typeof uniqueValue === 'number' && typeof value === 'number') {
              return Math.abs(uniqueValue - value) < 1e-10; // Tolerância para precisão numérica
            }
            // Para strings numéricas, converter e comparar
            if (!isNaN(parseFloat(uniqueValue)) && !isNaN(parseFloat(value))) {
              return Math.abs(parseFloat(uniqueValue) - parseFloat(value)) < 1e-10;
            }
            return false;
          });
        });
        if (validOrder.length !== orderArray.length) {
          console.log('Ordem personalizada corrigida - removidas categorias inválidas');
          localStorage.setItem(`categorized_order_${layerId}_${field}`, JSON.stringify(validOrder));
        }
      } catch (e) {
        console.warn('Ordem personalizada inválida removida:', e);
        localStorage.removeItem(`categorized_order_${layerId}_${field}`);
      }
    }
    
    // Verificar se há nomes personalizados válidos
    uniqueValues.forEach(category => {
      let hasValidName = false;
      for (let i = 0; i < 1000; i++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
        if (testName && testName !== category) {
          hasValidName = true;
          break;
        }
      }
      
      if (!hasValidName) {
        // Limpar nomes inválidos
        for (let i = 0; i < 1000; i++) {
          localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${i}`);
        }
      }
    });
    
    console.log('Consistência dos dados verificada e corrigida');
  }
  
  // Função para limpar nomes personalizados duplicados
  function cleanupDuplicateNames() {
    const field = document.getElementById('field-select').value;
    if (!field) return;
    
    // Obter todas as categorias do campo e tratar campos numéricos de forma robusta
    if (layerData && layerData.features) {
      const uniqueValues = [...new Set(layerData.features.map(f => {
        const value = f.properties[field];
        // Para campos numéricos, preservar o valor original se possível
        if (typeof value === 'number' || !isNaN(parseFloat(value))) {
          const num = parseFloat(value);
          return isFinite(num) ? num : value;
        }
        return value;
      }))];
      
      uniqueValues.forEach(category => {
        let foundName = null;
        let foundIndex = null;
        
        // Encontrar o primeiro nome personalizado válido
        for (let i = 0; i < 1000; i++) {
          const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
          if (testName) {
            foundName = testName;
            foundIndex = i;
            break;
          }
        }
        
        // Se encontrou um nome, limpar todos os outros e manter apenas o primeiro
        if (foundName !== null) {
          for (let i = 0; i < 1000; i++) {
            if (i !== foundIndex) {
              localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${i}`);
            }
          }
          console.log(`Nome personalizado limpo para ${category}: mantido índice ${foundIndex}`);
        }
      });
    }
    
    // IMPORTANTE: Não limpar cores personalizadas - elas devem ser preservadas
    console.log('Limpeza de nomes duplicados concluída - cores personalizadas preservadas');
  }
  
  // Função para resetar a legenda categorizada
  function resetCategorizedLegend() {
    const field = document.getElementById('field-select').value;
    if (!field) {
      alert('Selecione um campo primeiro.');
      return;
    }
    
    if (confirm('Tem certeza que deseja resetar a legenda categorizada?\n\nIsso irá remover:\n• Cores personalizadas\n• Nomes personalizados\n• Ordem personalizada\n\nA legenda voltará ao estado inicial.')) {
      // Limpar todas as informações personalizadas
      const categories = Array.from(document.querySelectorAll('.categorized-class-item'));
      categories.forEach(item => {
        const category = item.dataset.category;
        const index = item.dataset.index;
        
        // Remover do localStorage
        localStorage.removeItem(`category_color_${layerId}_${category}`);
        
        // Remover TODOS os nomes personalizados para esta categoria (todos os índices possíveis)
        for (let i = 0; i < 1000; i++) { // Limite alto para garantir que todos sejam removidos
          localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${i}`);
        }
      });
      
      // Remover ordem personalizada
      localStorage.removeItem(`categorized_order_${layerId}_${field}`);
      
      // Recarregar interface com configurações padrão
      loadCategoriesForField(field).then(categories => {
        createCategorizedClassesInterface(categories);
        // Limpar nomes duplicados e atualizar preview e mapa
        cleanupDuplicateNames();
        
        // IMPORTANTE: Forçar sincronização da legenda com a interface após reset (com retry)
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry();
        }, 200);
        
        updatePreviewAndMapSynchronized();
        saveUserConfig();
      });
      
      console.log('Legenda categorizada resetada para o estado inicial');
    }
  }

  // Função para atualizar visualização da paleta selecionada
  function updatePalettePreview() {
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    const colorsContainer = document.getElementById('palette-colors');
    const paletteNameSpan = document.getElementById('palette-name');
    
    console.log('updatePalettePreview chamada com:', { palette, invert });
    
    // Atualizar nome da paleta
    if (paletteNameSpan) {
      paletteNameSpan.textContent = palette;
    }
    
    // Limpar container
    colorsContainer.innerHTML = '';
    
    let colors = [];
    
    // Verificar se é uma paleta personalizada
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    const customPalette = customPalettes.find(p => p.name === palette);
    
    if (customPalette && customPalette.colors) {
      // É uma paleta personalizada
      colors = [...customPalette.colors];
      console.log('Paleta personalizada encontrada:', colors);
      
      // Aplicar inversão se necessário
      if (invert) {
        colors.reverse();
      }
    } else {
      // É uma paleta padrão - usar função brewer
      colors = brewer(palette, 8, invert); // Mostrar 8 cores para preview
      console.log('Paleta padrão gerada:', colors);
    }
    
    console.log('Cores finais para preview:', colors);
    
    // Criar elementos de cor
    colors.forEach(color => {
      const colorDiv = document.createElement('div');
      colorDiv.style.cssText = `
        width: 35px; 
        height: 35px; 
        background-color: ${color}; 
        border: 2px solid #fff; 
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      `;
      
      // Tooltip com valor HEX
      colorDiv.title = `Clique para copiar: ${color}`;
      
      // Efeito hover
      colorDiv.addEventListener('mouseenter', () => {
        colorDiv.style.transform = 'scale(1.15)';
        colorDiv.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
      });
      
      colorDiv.addEventListener('mouseleave', () => {
        colorDiv.style.transform = 'scale(1)';
        colorDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
      });
      
      // Clique para copiar cor
      colorDiv.addEventListener('click', () => {
        navigator.clipboard.writeText(color).then(() => {
          // Feedback visual
          const originalBorder = colorDiv.style.border;
          colorDiv.style.border = '2px solid #28a745';
          colorDiv.style.transform = 'scale(1.2)';
          
          setTimeout(() => {
            colorDiv.style.border = originalBorder;
            colorDiv.style.transform = 'scale(1)';
          }, 500);
          
          // Mostrar toast ou alert
          showToast(`Cor ${color} copiada para a área de transferência!`, 'success');
        }).catch(err => {
          console.error('Erro ao copiar cor:', err);
          showToast('Erro ao copiar cor', 'error');
        });
      });
      
      colorsContainer.appendChild(colorDiv);
    });
  }

  // Função para atualizar cores da paleta visual (mantida para compatibilidade)
  function updatePaletteVisualColors() {
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    
    // Atualizar cores na visualização da paleta
    document.querySelectorAll('.palette-item').forEach(paletteItem => {
      const paletteName = paletteItem.dataset.palette;
      if (paletteName === palette) {
        const colors = brewer(paletteName, 5, invert);
        const colorDivs = paletteItem.querySelectorAll('div[style*="background-color"]');
        colors.forEach((color, index) => {
          if (colorDivs[index]) {
            colorDivs[index].style.backgroundColor = color;
          }
        });
      }
    });
  }
  
  // Função para criar interface de classes da simbologia graduada
  function createGraduatedClassesInterface(style) {
    const container = document.getElementById('graduated-classes-list');
    container.innerHTML = '';
    
    if (!style || !style.field || !style.classes) {
      container.innerHTML = '<div class="text-muted">Selecione um campo e número de classes para editar as classes.</div>';
      return;
    }
    
    const palette = style.palette || 'Blues';
    const colors = brewer(palette, style.classes, style.palette_invert);
    
    // Gerar nomes padrão para as classes
    const classNames = [];
    for (let i = 0; i < style.classes; i++) {
      const className = localStorage.getItem(`graduated_class_${layerId}_${style.field}_${i}`) || `Classe ${i + 1}`;
      classNames.push(className);
    }
    
    // Carregar cores personalizadas salvas ou usar cores da paleta
    const customColors = [];
    for (let i = 0; i < style.classes; i++) {
      const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
      customColors.push(savedColor || colors[i]);
    }
    
    customColors.forEach((color, index) => {
      const div = document.createElement('div');
      div.className = 'd-flex align-items-center gap-2 p-2 border rounded';
      div.innerHTML = `
        <div class="d-flex align-items-center gap-2">
          <div class="color-preview" style="width: 30px; height: 30px; background-color: ${color}; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;" data-index="${index}"></div>
          <input type="text" class="form-control form-control-sm graduated-class-name" 
                 value="${classNames[index]}" data-index="${index}" data-field="${style.field}"
                 style="min-width: 150px;" placeholder="Nome da classe">
        </div>
        <div class="d-flex align-items-center gap-2">
          <input type="color" class="form-control form-control-color graduated-class-color" 
                 value="${color}" data-index="${index}" style="width: 40px; height: 30px;" title="Seletor de cor">
          <input type="text" class="form-control form-control-sm graduated-class-hex" 
                 value="${color}" data-index="${index}" style="width: 80px;" placeholder="HEX" title="Código HEX">
          <button type="button" class="btn btn-outline-secondary btn-sm graduated-class-rgb-btn" 
                  data-index="${index}" title="Mostrar/ocultar campos RGB">
            <i class="fas fa-palette"></i> RGB
          </button>
        </div>
        <div class="d-flex align-items-center gap-2">
          <div class="text-muted small">
            <span class="class-range" data-index="${index}">Calculando...</span>
          </div>
          <div class="graduated-class-rgb-inputs d-none" data-index="${index}">
            <input type="number" class="form-control form-control-sm" min="0" max="255" 
                   placeholder="R" style="width: 50px;" title="Valor Vermelho (0-255)">
            <input type="number" class="form-control form-control-sm" min="0" max="255" 
                   placeholder="G" style="width: 50px;" title="Valor Verde (0-255)">
            <input type="number" class="form-control form-control-sm" min="0" max="255" 
                   placeholder="B" style="width: 50px;" title="Valor Azul (0-255)">
          </div>
        </div>
      `;
      
      container.appendChild(div);
      
      // Event listeners para edição de cores
      const colorPreview = div.querySelector('.color-preview');
      const colorInput = div.querySelector('.graduated-class-color');
      const hexInput = div.querySelector('.graduated-class-hex');
      const rgbBtn = div.querySelector('.graduated-class-rgb-btn');
      const rgbInputs = div.querySelector('.graduated-class-rgb-inputs');
      const rInput = rgbInputs.querySelector('input[placeholder="R"]');
      const gInput = rgbInputs.querySelector('input[placeholder="G"]');
      const bInput = rgbInputs.querySelector('input[placeholder="B"]');
      
      // Converter cor inicial para RGB
      const rgb = hexToRgb(color);
      if (rgb) {
        rInput.value = rgb.r;
        gInput.value = rgb.g;
        bInput.value = rgb.b;
      }
      
      // Event listener para seletor de cor
      colorInput.addEventListener('input', function() {
        const newColor = this.value;
        updateClassColor(index, newColor);
      });
      
      // Event listener para campo HEX
      hexInput.addEventListener('input', function() {
        const newColor = this.value;
        if (isValidHex(newColor)) {
          updateClassColor(index, newColor);
        }
      });
      
      // Event listener para botão RGB
      rgbBtn.addEventListener('click', function() {
        rgbInputs.classList.toggle('d-none');
        this.classList.toggle('btn-secondary');
        this.classList.toggle('btn-outline-secondary');
      });
      
      // Event listeners para campos RGB
      [rInput, gInput, bInput].forEach(input => {
        input.addEventListener('input', function() {
          const r = parseInt(rInput.value) || 0;
          const g = parseInt(gInput.value) || 0;
          const b = parseInt(bInput.value) || 0;
          const newColor = rgbToHex(r, g, b);
          updateClassColor(index, newColor);
        });
      });
      
      // Event listener para edição do nome da classe
      const nameInput = div.querySelector('.graduated-class-name');
      nameInput.addEventListener('input', function() {
        const newName = this.value;
        const index = this.dataset.index;
        const field = this.dataset.field;
        
        // Salvar no localStorage
        localStorage.setItem(`graduated_class_${layerId}_${field}_${index}`, newName);
        
        // Atualizar preview (sem recriar a interface para evitar travamento)
        updateGraduatedClassRanges(style);
        renderMapPreview();
        
        // Forçar atualização da legenda
        setTimeout(() => {
          renderPreview();
        }, 100);
        
        // Salvar configuração e enviar para o banco
        saveUserConfig();
      });
      
      // Limitar a 50 caracteres
      nameInput.setAttribute('maxlength', '50');
    });
    
    // Atualizar faixas de valores quando possível
    updateGraduatedClassRanges(style);
    
    // Calcular e exibir os breaks das classes após criar a interface
    setTimeout(() => {
      calculateAndDisplayClassBreaks(style);
    }, 100);
  }
  
  // Função para calcular e exibir os breaks das classes graduadas
  function calculateAndDisplayClassBreaks(style) {
    if (!layerData || !style.field) return;
    
    const values = layerData.features
      .map(f => parseFloat(f.properties[style.field]))
      .filter(v => !isNaN(v))
      .sort((a, b) => a - b);
    
    if (values.length === 0) return;
    
    const min = values[0];
    const max = values[values.length - 1];
    const classes = style.classes || 5;
    
    // Gerar breaks baseado no método
    let breaks = [];
    if (style.method === 'equal') {
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    } else if (style.method === 'quantile') {
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'jenks') {
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'log') {
      const logMin = Math.log(Math.max(min, 0.1));
      const logMax = Math.log(max);
      const step = (logMax - logMin) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(Math.exp(logMin + (i * step)));
      }
    } else if (style.method === 'manual' && style.breaks) {
      breaks = style.breaks;
    } else {
      // Padrão: equal interval
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    }
    
    // Salvar breaks no localStorage para preservar entre mudanças de paleta
    localStorage.setItem(`graduated_breaks_${layerId}_${style.field}`, JSON.stringify(breaks));
    
    // Atualizar as faixas de valores na interface
    document.querySelectorAll('.class-range').forEach((rangeSpan, index) => {
      if (index < breaks.length - 1) {
        const start = breaks[index].toFixed(2);
        const end = breaks[index + 1].toFixed(2);
        
        // Formatar números: usar "." como separador de milhar e "," como decimal
        const formatNumber = (num) => {
          const parts = num.split('.');
          if (parts.length === 2) {
            const integerPart = parts[0];
            const decimalPart = parts[1];
            // Adicionar separador de milhar se necessário
            const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
            return `${formattedInteger},${decimalPart}`;
          }
          return num.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
        };
        
        const formattedStart = formatNumber(start);
        const formattedEnd = formatNumber(end);
        rangeSpan.textContent = `${formattedStart} a ${formattedEnd}`;
      }
    });
  }

  // Função para atualizar as faixas de valores das classes graduadas
  function updateGraduatedClassRanges(style) {
    if (!layerData || !style.field) return;
    
    // Tentar usar breaks salvos primeiro
    const savedBreaks = localStorage.getItem(`graduated_breaks_${layerId}_${style.field}`);
    if (savedBreaks) {
      try {
        const breaks = JSON.parse(savedBreaks);
        if (breaks && breaks.length > 0) {
          // Atualizar as faixas de valores na interface usando breaks salvos
          document.querySelectorAll('.class-range').forEach((rangeSpan, index) => {
            if (index < breaks.length - 1) {
              const start = breaks[index].toFixed(2);
              const end = breaks[index + 1].toFixed(2);
              
              // Formatar números: usar "." como separador de milhar e "," como decimal
              const formatNumber = (num) => {
                const parts = num.split('.');
                if (parts.length === 2) {
                  const integerPart = parts[0];
                  const decimalPart = parts[1];
                  // Adicionar separador de milhar se necessário
                                   const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
                 return `${formattedInteger},${decimalPart}`;
                }
                return num.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
              };
              
              const formattedStart = formatNumber(start);
              const formattedEnd = formatNumber(end);
              rangeSpan.textContent = `${formattedStart} a ${formattedEnd}`;
            }
          });
          return; // Usar breaks salvos, não recalcular
        }
      } catch (e) {
        console.log('Erro ao carregar breaks salvos:', e);
      }
    }
    
    // Se não há breaks salvos, calcular novos
    calculateAndDisplayClassBreaks(style);
  }

  // Função para computar o estilo baseado nas seleções
  function computeStyle() {
    const styleType = document.getElementById('style-type').value;
    const geomType = document.getElementById('geom-type').value;
    const field = document.getElementById('field-select').value;
    const palette = document.getElementById('palette-select').value;
    const paletteOpacity = parseFloat(document.getElementById('palette-opacity').value);
    const paletteInvert = document.getElementById('palette-invert').checked;
    
    const style = {
      type: styleType,
      geometry_type: geomType,
      field: field,
      palette: palette,
      palette_opacity: paletteOpacity,
      palette_invert: paletteInvert
    };
    
    if (styleType === 'single') {
      style.stroke_color = document.getElementById('stroke-color').value;
      style.fill_color = document.getElementById('fill-color').value;
      style.stroke_weight = parseInt(document.getElementById('stroke-weight').value);
      style.fill_opacity = parseFloat(document.getElementById('fill-opacity').value);
      
      // IMPORTANTE: Para simbologia single, também tratar configurações de borda de polígono
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      }
      
      if (geomType === 'point') {
        style.radius = parseInt(document.getElementById('point-radius').value);
      } else if (geomType === 'line') {
        style.opacity = parseFloat(document.getElementById('line-opacity').value);
        const dash = document.getElementById('line-dash').value;
        if (dash) style.dashArray = dash;
      }
    } else if (styleType === 'categorized') {
      console.log('computeStyle: Processando simbologia categorizada');
      console.log('Simbologia categorizada aceita qualquer tipo de campo (textual, numérico, etc.)');
      
      // Coletar informações da paleta selecionada
      const paletteSelect = document.getElementById('palette-select');
      const paletteInvert = document.getElementById('palette-invert')?.checked || false;
      
      if (paletteSelect) {
        style.palette = paletteSelect.value;
        style.palette_invert = paletteInvert;
        console.log('Paleta selecionada para categorizada:', style.palette, 'Invertida:', style.palette_invert);
      }
      
      // Carregar categorias do campo selecionado e tratar campos numéricos de forma robusta
      if (field && layerData && layerData.features) {
        const uniqueValues = [...new Set(layerData.features.map(f => {
          const value = f.properties[field];
          // Para campos numéricos, preservar o valor original se possível
          if (typeof value === 'number' || !isNaN(parseFloat(value))) {
            const num = parseFloat(value);
            return isFinite(num) ? num : value;
          }
          return value;
        }))];
        
        // Verificar se há ordem personalizada salva
        const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
        let orderedValues = [...uniqueValues];
        
        if (savedOrder) {
          try {
            const orderArray = JSON.parse(savedOrder);
            // Reordenar baseado na ordem salva
            orderedValues = orderArray.filter(value => uniqueValues.includes(value));
            // Adicionar valores que não estão na ordem salva
            uniqueValues.forEach(value => {
              if (!orderArray.includes(value)) {
                orderedValues.push(value);
              }
            });
          } catch (e) {
            console.warn('Erro ao carregar ordem personalizada:', e);
          }
        }
        
        const categories = orderedValues.map((value, index) => {
          // Verificar se há cor personalizada salva
          const savedColor = localStorage.getItem(`category_color_${layerId}_${value}`);
          
          // Verificar se há nome personalizado salvo
          // IMPORTANTE: Buscar por todos os índices possíveis para encontrar o nome salvo
          let savedName = null;
          for (let i = 0; i < orderedValues.length; i++) {
            const testName = localStorage.getItem(`categorized_class_name_${layerId}_${value}_${i}`);
            if (testName) {
              savedName = testName;
              break;
            }
          }
          
          console.log(`computeStyle - Categoria ${index}: value=${value}, savedName=${savedName}, savedColor=${savedColor}`);
          
          // IMPORTANTE: Preservar cores personalizadas e gerar cores da paleta apenas se não houver cor salva
          let color;
          if (savedColor) {
            // Usar cor personalizada salva (não mudar baseado na posição)
            color = savedColor;
            console.log(`computeStyle - Usando cor personalizada para ${value}: ${color}`);
          } else {
            // IMPORTANTE: Para campos numéricos, tentar encontrar cor salva por valor original
            let foundSavedColor = null;
            if (typeof value === 'number' || !isNaN(parseFloat(value))) {
              // Para campos numéricos, buscar cor salva por valor
              foundSavedColor = localStorage.getItem(`category_color_${layerId}_${value}`);
              if (foundSavedColor) {
                color = foundSavedColor;
                console.log(`computeStyle - Usando cor salva por valor para ${value}: ${color}`);
              }
            }
            
            // Se não encontrou cor salva, gerar cor da paleta
            if (!foundSavedColor) {
              const palette = style.palette || 'Set3';
              const invert = style.palette_invert || false;
              
              if (palette === 'custom') {
                // Para paletas personalizadas, usar cores salvas
                const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
                const selectedPalette = customPalettes.find(p => p.name === paletteSelect.value);
                if (selectedPalette && selectedPalette.colors) {
                  // IMPORTANTE: Distribuir cores de forma inteligente (primeira, última e intermediárias)
                  const distributedColors = distributeColorsIntelligently(selectedPalette.colors, orderedValues.length);
                  color = distributedColors[index];
                  console.log(`computeStyle - Cor distribuída para ${value} na posição ${index}: ${color}`);
                } else {
                  color = brewer('Set3', Math.max(orderedValues.length, 12), invert)[originalIndex % 12];
                }
              } else {
                // Para paletas padrão, usar ColorBrewer com distribuição inteligente
                const paletteColors = brewer(palette, Math.max(orderedValues.length, 12), invert);
                const distributedColors = distributeColorsIntelligently(paletteColors, orderedValues.length);
                color = distributedColors[index];
                console.log(`computeStyle - Cor distribuída da paleta padrão para ${value} na posição ${index}: ${color}`);
              }
              console.log(`computeStyle - Gerando nova cor para ${value} na posição ${index}: ${color}`);
            }
          }
          
          const finalCategory = savedName || value;
          console.log(`computeStyle - Categoria final ${index}: ${value} -> ${finalCategory}`);
          
          // Coletar valores dos controles de linha específicos para esta categoria
          let lineWeight = 2; // valor padrão
          let lineOpacity = 1; // valor padrão
          let lineStyle = ''; // valor padrão (linha contínua)
          
          // Buscar na interface os valores dos controles de linha para esta categoria
          const categoryItem = document.querySelector(`.categorized-class-item[data-category="${value}"]`);
          if (categoryItem) {
            const weightInput = categoryItem.querySelector('.line-weight-input');
            const opacityInput = categoryItem.querySelector('.line-opacity-input');
            const styleSelect = categoryItem.querySelector('.line-style-select');
            const spacingSlider = categoryItem.querySelector('.line-spacing-slider');
            
            if (weightInput) lineWeight = parseFloat(weightInput.value) || 2;
            if (opacityInput) lineOpacity = parseFloat(opacityInput.value) || 1;
            if (styleSelect) {
              lineStyle = styleSelect.value || '';
              
              // Aplicar espaçamento personalizado se houver slider
              if (spacingSlider && lineStyle) {
                const customSpacing = parseFloat(spacingSlider.value) || 10;
                
                // Modificar o estilo baseado no espaçamento personalizado
                if (lineStyle === '5,5') {
                  lineStyle = `${customSpacing},${customSpacing}`;
                } else if (lineStyle === '10,5') {
                  lineStyle = `${customSpacing * 2},${customSpacing}`;
                } else if (lineStyle === '2,2') {
                  lineStyle = `${customSpacing * 0.4},${customSpacing * 0.4}`;
                } else if (lineStyle === '1,1') {
                  lineStyle = `${customSpacing * 0.2},${customSpacing * 0.2}`;
                } else if (lineStyle === '5,2,1,2') {
                  lineStyle = `${customSpacing},${customSpacing * 0.4},${customSpacing * 0.2},${customSpacing * 0.4}`;
                } else if (lineStyle === '10,2,1,2') {
                  lineStyle = `${customSpacing * 2},${customSpacing * 0.4},${customSpacing * 0.2},${customSpacing * 0.4}`;
                }
                
                console.log(`Estilo modificado com espaçamento personalizado para categoria ${value}:`, lineStyle);
              }
            }
          }
          
          return {
            category: finalCategory, // Usar nome personalizado se disponível
            color: color,
            original_value: value,
            line_weight: lineWeight,
            line_opacity: lineOpacity,
            line_style: lineStyle
          };
        });
        
        style.categories = categories;
        console.log('Categorias carregadas para simbologia categorizada:', categories);
      } else {
        style.categories = [];
      }
      
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      } else if (geomType === 'line') {
        // Configurações específicas para linhas categorizadas
        const lineWeightDefault = document.getElementById('line-weight-default');
        const lineOpacityDefault = document.getElementById('line-opacity-default');
        const lineStyleDefault = document.getElementById('line-style-default');
        
        if (lineWeightDefault) {
          style.stroke_weight = parseFloat(lineWeightDefault.value) || 2;
        }
        if (lineOpacityDefault) {
          style.palette_opacity = parseFloat(lineOpacityDefault.value) || 1;
        }
        if (lineStyleDefault && lineStyleDefault.value) {
          style.dashArray = lineStyleDefault.value;
        }
        
        console.log('Configurações de linha aplicadas:', {
          stroke_weight: style.stroke_weight,
          palette_opacity: style.palette_opacity,
          dashArray: style.dashArray
        });
      }
    } else if (styleType === 'graduated') {
      const classes = parseInt(document.getElementById('classes').value);
      const method = document.getElementById('method').value;
      style.classes = classes;
      
      // Debug: verificar valores coletados
      console.log('Valores coletados para simbologia graduada:', {
        classes: classes,
        method: method,
        field: style.field,
        palette: style.palette
      });
      
      // Mapear valores do dropdown para os valores esperados pela função
      if (method === 'equal') style.method = 'equal';
      else if (method === 'quantiles') style.method = 'quantile';
      else if (method === 'jenks') style.method = 'jenks';
      else if (method === 'log') style.method = 'log';
      else if (method === 'manual') style.method = 'manual';
      else style.method = 'equal'; // Padrão
      
      if (method === 'manual') {
        const breaks = document.getElementById('manual-breaks').value;
        if (breaks) {
          style.breaks = breaks.split(',').map(b => parseFloat(b.trim()));
        }
      }
      
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      }
      
      // Debug: verificar estilo final
      console.log('Estilo graduado final:', style);
    }
    
    return style;
  }

  // Função para renderizar preview da legenda
  function renderPreview() {
    console.log('renderPreview chamada');
    console.log('Chamando computeStyle...');
    const style = computeStyle();
    console.log('Estilo computado:', style);
    const legendDiv = document.getElementById('preview-legend');
    
    if (style.type === 'single') {
      legendDiv.innerHTML = `
        <div class="d-flex align-items-center gap-2 p-2 border rounded">
          <div style="width: 20px; height: 20px; background-color: ${style.fill_color}; border: 2px solid ${style.stroke_color};"></div>
          <span>${style.field || 'Símbolo único'}</span>
        </div>
      `;
    } else if (style.type === 'categorized' && style.categories) {
      // IMPORTANTE: Para simbologia categorizada, sincronizar diretamente com a interface
      renderCategorizedPreviewFromInterface(legendDiv, style);
    } else if (style.type === 'graduated') {
      // Para dados vetoriais graduados, mostrar legenda discreta
      if (style.geometry_type !== 'raster') {
        // Gerar cores da paleta para a legenda discreta
        const palette = style.palette || 'Blues';
        const classes = style.classes || 5;
        const colors = brewer(palette, classes, style.palette_invert);
        
        // Carregar cores personalizadas se disponíveis
        const customColors = [];
        for (let i = 0; i < classes; i++) {
          const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
          customColors.push(savedColor || colors[i]);
        }
        
        // Criar legenda discreta com cada classe individual
        const legendItems = customColors.map((color, index) => {
          // Obter nome personalizado da classe
          const customClassName = localStorage.getItem(`graduated_class_${layerId}_${style.field}_${index}`) || `Classe ${index + 1}`;
          
          // Verificar se deve mostrar legenda composta
          const compositeLegend = document.getElementById('composite-legend-toggle')?.checked;
          
          let legendText = customClassName;
          
          if (compositeLegend) {
            // Quando marcado (ativado): mostrar nome da classe + intervalo
            const classRangeElement = document.querySelector(`.class-range[data-index="${index}"]`);
            if (classRangeElement) {
              const rangeText = classRangeElement.textContent;
              legendText = `${customClassName} - ${rangeText}`; // Nome + intervalo
            }
          } else {
            // Quando desmarcado (desativado): mostrar apenas o intervalo
            const classRangeElement = document.querySelector(`.class-range[data-index="${index}"]`);
            if (classRangeElement) {
              const rangeText = classRangeElement.textContent;
              legendText = rangeText; // Apenas o intervalo
            }
          }
          
          console.log(`Classe ${index}: ${customClassName}, Legenda: ${legendText}`);
          
          return `
            <div class="d-flex align-items-center gap-2 p-2 border rounded mb-1">
              <div style="width: 20px; height: 20px; background-color: ${color}; border: 1px solid #ccc;"></div>
              <span>${legendText}</span>
            </div>
          `;
        }).join('');
        
        legendDiv.innerHTML = `
          <div class="mb-2">
            <div><strong>${style.field}</strong></div>
            <div class="small text-muted">Método: ${style.method}</div>
            <div class="small text-muted">Paleta: ${palette}</div>
            <div class="small text-muted">${classes} classes</div>
            <div class="small text-muted">Tipo: Vetorial (discreto)</div>
          </div>
          ${legendItems}
        `;
      } else {
        // Para dados raster, manter legenda contínua
        const palette = style.palette || 'Blues';
        const classes = style.classes || 5;
        const colors = brewer(palette, classes, style.palette_invert);
        
        // Criar gradiente visual para a legenda
        const gradientColors = colors.map(color => color).join(', ');
        
        legendDiv.innerHTML = `
          <div class="d-flex align-items-center gap-2 p-2 border rounded">
            <div class="d-flex flex-column">
              <div style="width: 20px; height: 60px; background: linear-gradient(to bottom, ${gradientColors}); border: 1px solid #ccc;"></div>
              <small class="text-muted text-center">${classes} classes</small>
            </div>
            <div class="flex-grow-1">
              <div><strong>${style.field}</strong></div>
              <div class="small text-muted">Método: ${style.method}</div>
              <div class="small text-muted">Paleta: ${palette}</div>
              <div class="small text-muted">Tipo: Raster (contínuo)</div>
            </div>
          </div>
        `;
      }
    }
  }

  // Função para renderizar rótulos no mapa
  function renderLabelsOnMap() {
    if (!layerData || !map) return;
    
    // Remover rótulos existentes
    map.eachLayer(layer => {
      if (layer._labelLayer) {
        map.removeLayer(layer);
      }
    });
    
    const labelsEnabled = document.getElementById('labels-enabled').checked;
    if (!labelsEnabled) return;
    
    const labelField = document.getElementById('label-field-select').value;
    if (!labelField) return;
    
    const labelConfig = {
      font: document.getElementById('label-font').value,
      size: parseInt(document.getElementById('label-size').value),
      color: document.getElementById('label-color').value,
      bold: document.getElementById('label-bold').checked,
      italic: document.getElementById('label-italic').checked,
      bufferColor: document.getElementById('label-buffer-color').value,
      bufferSize: parseInt(document.getElementById('label-buffer-size').value),
      bufferOpacity: parseFloat(document.getElementById('label-buffer-opacity').value),
      offsetX: parseInt(document.getElementById('label-offset-x').value),
      offsetY: parseInt(document.getElementById('label-offset-y').value)
    };
    
    // Criar camada de rótulos
    const labelLayer = L.layerGroup();
    labelLayer._labelLayer = true;
    
    layerData.features.forEach(feature => {
      if (feature.geometry && feature.properties[labelField]) {
        const labelText = feature.properties[labelField].toString();
        
        // Calcular posição do rótulo baseado na geometria
        let labelPosition;
        if (feature.geometry.type === 'Point') {
          labelPosition = feature.geometry.coordinates;
        } else if (feature.geometry.type === 'LineString') {
          // Posição no meio da linha
          const coords = feature.geometry.coordinates;
          const midIndex = Math.floor(coords.length / 2);
          labelPosition = coords[midIndex];
        } else if (feature.geometry.type === 'Polygon') {
          // Centro do polígono
          const coords = feature.geometry.coordinates[0];
          let sumX = 0, sumY = 0;
          coords.forEach(coord => {
            sumX += coord[0];
            sumY += coord[1];
          });
          labelPosition = [sumX / coords.length, sumY / coords.length];
        }
        
        if (labelPosition) {
          // Converter coordenadas para lat/lng
          const latLng = L.latLng(labelPosition[1], labelPosition[0]);
          
          // Criar elemento HTML para o rótulo
          const labelDiv = document.createElement('div');
          labelDiv.innerHTML = labelText;
          labelDiv.style.cssText = `
            font-family: ${labelConfig.font}, sans-serif;
            font-size: ${labelConfig.size}px;
            color: ${labelConfig.color};
            font-weight: ${labelConfig.bold ? 'bold' : 'normal'};
            font-style: ${labelConfig.italic ? 'italic' : 'normal'};
            text-shadow: 
              -1px -1px 0 ${labelConfig.bufferColor},
              -1px 1px 0 ${labelConfig.bufferColor},
              1px -1px 0 ${labelConfig.bufferColor},
              1px 1px 0 ${labelConfig.bufferColor};
            text-shadow: 
              -1px -1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              -1px 1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              1px -1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              1px 1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor};
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
          `;
          
          // Criar marcador de rótulo
          const labelMarker = L.marker(latLng, {
            icon: L.divIcon({
              html: labelDiv,
              className: 'label-icon',
              iconSize: [labelDiv.offsetWidth, labelDiv.offsetHeight],
              iconAnchor: [labelDiv.offsetWidth / 2, labelDiv.offsetHeight / 2]
            })
          });
          
          // Aplicar deslocamento
          if (labelConfig.offsetX !== 0 || labelConfig.offsetY !== 0) {
            labelMarker.setLatLng([
              latLng.lat + (labelConfig.offsetY / 1000),
              latLng.lng + (labelConfig.offsetX / 1000)
            ]);
          }
          
          labelLayer.addLayer(labelMarker);
        }
      }
    });
    
    labelLayer.addTo(map);
  }

  // Função para renderizar preview no mapa (aplicação instantânea)
  function renderMapPreview() {
    console.log('renderMapPreview chamada');
    if (!currentLayer || !map) {
      console.log('renderMapPreview: currentLayer ou map não disponível');
      return;
    }
    
    // Aplicar mudanças INSTANTANEAMENTE sem remover a camada
    const style = computeStyle();
    
    // Aplicar estilo baseado no tipo
    if (style.type === 'single') {
      // IMPORTANTE: Aplicar borda apenas se estiver habilitada para polígonos
      const layerStyle = {
        fillColor: style.fill_color,
        fillOpacity: style.fill_opacity
      };
      
      // Para polígonos, aplicar borda apenas se estiver habilitada
      if (style.geometry_type === 'polygon') {
        if (style.border_color && style.border_width > 0) {
          layerStyle.color = style.border_color;
          layerStyle.weight = style.border_width;
        } else {
          // Se não quiser borda, definir como transparente
          layerStyle.color = 'transparent';
          layerStyle.weight = 0;
        }
      } else {
        // Para pontos e linhas, usar configurações padrão
        layerStyle.color = style.stroke_color;
        layerStyle.weight = style.stroke_weight;
      }
      
      currentLayer.setStyle(layerStyle);
      
      if (style.geometry_type === 'point') {
        currentLayer.eachLayer(layer => {
          if (layer.setRadius) {
            layer.setRadius(style.radius);
          }
        });
      } else if (style.geometry_type === 'line') {
        currentLayer.eachLayer(layer => {
          if (style.opacity !== undefined) {
            layer.setStyle({ opacity: style.opacity });
          }
          if (style.dashArray) {
            layer.setStyle({ dashArray: style.dashArray });
          }
        });
      }
    } else if (style.type === 'categorized' && style.categories) {
      // Aplicar estilo categorizado INSTANTANEAMENTE
      console.log('renderMapPreview: Aplicando estilo categorizado:', style);
      console.log('Campo para simbologia:', style.field);
      console.log('Categorias finais para renderização do mapa:', style.categories);
      
      // Usar as categorias já computadas pelo computeStyle
      // As cores já estão corretas e não devem ser alteradas aqui
      
      let layersUpdated = 0;
      currentLayer.eachLayer(layer => {
        if (layer.feature && layer.feature.properties && style.field) {
          const value = layer.feature.properties[style.field];
          // Para campos numéricos, tratar comparação de forma robusta
          const category = style.categories.find(cat => {
            if (cat.original_value === value) return true;
            // Para campos numéricos, comparar também como números
            if (typeof cat.original_value === 'number' && typeof value === 'number') {
              return Math.abs(cat.original_value - value) < 1e-10; // Tolerância para precisão numérica
            }
            // Para strings numéricas, converter e comparar
            if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(value))) {
              return Math.abs(parseFloat(cat.original_value) - parseFloat(value)) < 1e-10;
            }
            return false;
          });
          if (category) {
            console.log(`Atualizando layer ${value} com cor ${category.color}`);
            
            // IMPORTANTE: Aplicar estilo baseado no tipo de geometria
            const layerStyle = {};
            
            if (style.geometry_type === 'line') {
              // Para linhas: usar color (cor da linha) e weight (espessura)
              layerStyle.color = category.color;
              layerStyle.weight = category.line_weight || 2;
              layerStyle.opacity = category.line_opacity || 1;
              
              // Aplicar estilo de linha (tracejado, pontilhado, etc.)
              if (category.line_style) {
                layerStyle.dashArray = category.line_style;
              }
            } else if (style.geometry_type === 'point') {
              // Para pontos: usar fillColor e color para borda
              layerStyle.fillColor = category.color;
              layerStyle.fillOpacity = style.palette_opacity || 0.6;
              layerStyle.color = style.border_color || '#333';
              layerStyle.weight = style.border_width || 2;
            } else {
              // Para polígonos: usar fillColor e aplicar borda se habilitada
              layerStyle.fillColor = category.color;
              layerStyle.fillOpacity = style.palette_opacity || 0.6;
              
              // Aplicar configurações de borda apenas se estiver habilitada
              if (style.border_color && style.border_width > 0) {
                layerStyle.color = style.border_color;
                layerStyle.weight = style.border_width;
              } else {
                // Se não quiser borda, definir como transparente
                layerStyle.color = 'transparent';
                layerStyle.weight = 0;
              }
            }
            
            layer.setStyle(layerStyle);
            layersUpdated++;
          } else {
            console.log(`Categoria não encontrada para valor: ${value}`);
          }
        }
      });
      
      console.log(`Total de layers atualizados: ${layersUpdated}`);
    } else if (style.type === 'graduated') {
      // Aplicar estilo graduado
      console.log('renderMapPreview: Aplicando estilo graduado:', style);
      if (style.field && style.classes && style.method) {
        console.log('Aplicando estilo graduado:', style);
        applyGraduatedStyle(currentLayer, style);
      } else {
        console.log('Dados insuficientes para estilo graduado:', {
          field: style.field,
          classes: style.classes,
          method: style.method
        });
      }
    }
    
    // Adicionar camada ao mapa se não estiver presente
    if (!map.hasLayer(currentLayer)) {
      console.log('renderMapPreview: Adicionando camada ao mapa');
      currentLayer.addTo(map);
    }
    
    // Renderizar rótulos se habilitados
    renderLabelsOnMap();
    
    // Atualizar legenda após renderizar o mapa
    setTimeout(() => {
      renderPreview();
    }, 100);
    
    console.log('renderMapPreview concluída - mudanças aplicadas instantaneamente');
  }

  // Função para atualizar preview
  function refreshPreview() {
    console.log('refreshPreview chamada');
    
    // IMPORTANTE: Para simbologia categorizada, sincronizar diretamente com a interface
    const currentStyleType = document.getElementById('style-type').value;
    if (currentStyleType === 'categorized') {
      console.log('Simbologia categorizada detectada em refreshPreview - sincronizando com interface');
      
      const field = document.getElementById('field-select').value;
      if (field) {
        const categoryList = document.getElementById('category-list');
        if (categoryList && categoryList.children.length > 0) {
          // Atualizar preview diretamente da interface
          const legendDiv = document.getElementById('preview-legend');
          if (legendDiv) {
            const style = computeStyle();
            renderCategorizedPreviewFromInterface(legendDiv, style);
          }
          
          // Atualizar mapa
          renderMapPreview();
          return; // Sair da função para simbologia categorizada
        }
      }
    }
    
    // Para outros tipos de simbologia, usar o método padrão
    console.log('Chamando renderPreview (método padrão)...');
    renderPreview();
    console.log('Chamando renderMapPreview...');
    renderMapPreview(); // Isso agora inclui renderização de rótulos
    updatePalettePreview(); // Atualizar visualização da paleta
    updatePaletteVisualColors();
    
    // Atualizar interface de classes graduadas se aplicável (apenas se não existir)
    const styleType = document.getElementById('style-type').value;
    if (styleType === 'graduated') {
      const style = computeStyle();
      const existingInterface = document.getElementById('graduated-classes-list');
      if (!existingInterface.children.length) {
        createGraduatedClassesInterface(style);
      } else {
        // Apenas atualizar as faixas de valores sem recriar a interface
        updateGraduatedClassRanges(style);
      }
    }
  }
  
  // Função para gerar cores da paleta para simbologia categorizada
  function generatePaletteColors(paletteName, numCategories, invert = false) {
    console.log('generatePaletteColors chamada:', { paletteName, numCategories, invert });
    
    // Se for uma paleta personalizada, retornar as cores salvas
    if (paletteName === 'custom') {
      const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
      const selectedPalette = customPalettes.find(p => p.name === document.getElementById('palette-select').value);
      if (selectedPalette && selectedPalette.colors) {
        return selectedPalette.colors.slice(0, numCategories);
      }
    }
    
    // Para paletas padrão, usar a biblioteca ColorBrewer
    try {
      let colors = [];
      
      // Determinar o tipo de paleta baseado no nome
      if (['Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'BuGn', 'BuPu', 'GnBu', 'OrRd', 'PuBu', 'PuRd', 'RdPu', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd'].includes(paletteName)) {
        // Paletas sequenciais
        colors = brewer(paletteName, Math.min(numCategories, 9), invert);
      } else if (['RdBu', 'RdYlBu', 'RdYlGn', 'Spectral', 'PuOr', 'BrBG', 'PiYG', 'PRGn', 'RdBu', 'RdGy', 'Spectral'].includes(paletteName)) {
        // Paletas divergentes
        colors = brewer(paletteName, Math.min(numCategories, 11), invert);
      } else if (['Set1', 'Set2', 'Set3', 'Paired', 'Accent', 'Dark2', 'Pastel1', 'Pastel2'].includes(paletteName)) {
        // Paletas qualitativas (ideais para categorias)
        colors = brewer(paletteName, Math.min(numCategories, 12), invert);
      } else {
        // Paleta padrão se não reconhecida
        colors = brewer('Set3', Math.min(numCategories, 12), invert);
      }
      
      // Se precisar de mais cores que a paleta fornece, repetir ou gerar variações
      if (colors.length < numCategories) {
        const baseColors = [...colors];
        while (colors.length < numCategories) {
          colors.push(...baseColors);
        }
        colors = colors.slice(0, numCategories);
      }
      
      console.log('Cores geradas:', colors);
      return colors;
      
    } catch (error) {
      console.error('Erro ao gerar cores da paleta:', error);
      // Fallback: gerar cores aleatórias
      const fallbackColors = [];
      for (let i = 0; i < numCategories; i++) {
        fallbackColors.push(`hsl(${(i * 360) / numCategories}, 70%, 60%)`);
      }
      return fallbackColors;
    }
  }

  // Função para carregar dados da camada
  async function loadLayerData() {
    try {
      console.log('Carregando dados da camada...');
      
      // Usar a URL correta para carregar os dados da camada
      // Primeiro, vamos tentar obter o slug da empresa do usuário logado
      let companySlug = 'amplo'; // Padrão
      
      // Tentar obter do contexto da página ou do usuário
      try {
        // Verificar se há um elemento com o slug da empresa
        const companyElement = document.querySelector('#company-data');
        if (companyElement) {
          companySlug = companyElement.dataset.companySlug;
          console.log('Slug da empresa obtido:', companySlug);
        }
      } catch (e) {
        console.log('Usando slug padrão da empresa:', companySlug);
      }
      
      const url = `/portal/${companySlug}/api/camada_data/${layerId}`;
      console.log('URL da API:', url);
      
      const response = await fetch(url);
      console.log('Resposta da API:', response.status, response.statusText);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      layerData = await response.json();
      console.log('Dados da camada carregados:', layerData);
      
      if (map && layerData.features && layerData.features.length > 0) {
        console.log('Camada tem', layerData.features.length, 'features');
        
        // Remover camada anterior se existir
        if (currentLayer) {
          map.removeLayer(currentLayer);
          console.log('Camada anterior removida');
        }
        
        // Criar nova camada GeoJSON
        currentLayer = L.geoJSON(layerData, {
          style: {
            color: '#333333',
            weight: 2,
            fillColor: '#38bdf8',
            fillOpacity: 0.6
          },
          onEachFeature: function(feature, layer) {
            layer.bindPopup(`
              <strong>${feature.properties[Object.keys(feature.properties)[0]] || 'Sem nome'}</strong><br>
              ${Object.entries(feature.properties).map(([key, value]) => `${key}: ${value}`).join('<br>')}
            `);
          }
        });
        
        // Adicionar ao mapa
        currentLayer.addTo(map);
        console.log('Nova camada adicionada ao mapa');
        
        // Ajustar visualização
        if (currentLayer.getBounds) {
          map.fitBounds(currentLayer.getBounds());
          console.log('Mapa ajustado aos limites da camada');
        }
        
        // Detectar e preselecionar tipo de geometria
        const detectedType = detectGeometryType(layerData);
        document.getElementById('geom-type').value = detectedType;
        console.log('Tipo de geometria detectado:', detectedType);
        
        // IMPORTANTE: NÃO aplicar visibilidade aqui para evitar mostrar method-info brevemente
        // applyVisibility(); // REMOVIDO - não deve ser chamado aqui
        
        // Restaurar configurações salvas do usuário
        const configRestored = loadUserConfig();
        
        // IMPORTANTE: Aplicar visibilidade APENAS após restaurar configurações
        // para garantir que o method-info só apareça se for simbologia graduada
        if (configRestored) {
          applyVisibility();
        } else {
          // Se não há configurações salvas, aplicar visibilidade padrão
          applyVisibility();
        }
        
        // Se tiver campo selecionado e for categorizada, carregar categorias
        const field = document.getElementById('field-select').value;
        const styleType = document.getElementById('style-type').value;
        if (field && styleType === 'categorized') {
          loadCategoriesForField(field).then(categories => {
            // Validar e corrigir consistência dos dados
            validateAndFixDataConsistency();
            createCategorizedClassesInterface(categories);
            // Limpar nomes duplicados após carregamento
            cleanupDuplicateNames();
            
            // IMPORTANTE: Forçar sincronização da legenda com a interface (com retry)
            setTimeout(() => {
              forceCategorizedLegendSyncWithRetry();
            }, 300);
            
            refreshPreview();
            
            // IMPORTANTE: Forçar sincronização após carregamento completo
            forceSyncAfterPageLoad();
          });
        }
        
        refreshPreview();
        
        // IMPORTANTE: Forçar sincronização após carregamento geral da página
        setTimeout(() => {
          forceSyncAfterPageLoad();
        }, 1000);
        
        console.log('Dados da camada carregados com sucesso');
      } else {
        console.warn('Dados da camada vazios ou mapa não inicializado');
        if (!map) {
          console.error('Mapa não está inicializado!');
        }
        if (!layerData.features || layerData.features.length === 0) {
          console.error('Camada não tem features!');
        }
      }
    } catch (error) {
      console.error('Erro ao carregar dados da camada:', error);
      
      // Mostrar erro para o usuário
      const errorDiv = document.createElement('div');
      errorDiv.className = 'alert alert-danger alert-dismissible fade show';
      errorDiv.innerHTML = `
        <i class="fas fa-exclamation-triangle"></i>
        <strong>Erro ao carregar dados da camada:</strong> ${error.message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      const container = document.querySelector('.container-fluid');
      if (container) {
        container.insertBefore(errorDiv, container.firstChild);
      }
    }
  }

  // Inicialização da página
  document.addEventListener('DOMContentLoaded', function() {
    // Carregar campos e dados
    initializePage();
    
    // IMPORTANTE: NÃO mostrar informações padrão automaticamente
    // O method-info só deve aparecer quando "Graduada" estiver selecionada
    // showDefaultMethodInfo(); // REMOVIDO - não deve ser chamado automaticamente
    
    // IMPORTANTE: Forçar sincronização após carregamento completo da página
    window.addEventListener('load', function() {
      console.log('Página completamente carregada - forçando sincronização');
      
      // IMPORTANTE: Para simbologia categorizada, verificar se há dados personalizados antes de sincronizar
      const styleType = document.getElementById('style-type').value;
      const field = document.getElementById('field-select').value;
      
      if (styleType === 'categorized' && field) {
        console.log('Simbologia categorizada detectada - verificando dados personalizados antes de sincronizar');
        
        // Verificar se há ordem personalizada salva
        const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
        const hasCustomData = savedOrder && savedOrder !== '[]';
        
        if (hasCustomData) {
          console.log('Dados personalizados encontrados - aplicando sincronização completa');
          setTimeout(() => {
            forceSyncAfterPageLoad();
            
            // IMPORTANTE: Verificar se a interface precisa de sincronização adicional
            setTimeout(() => {
              forceInterfaceSyncIfNeeded();
            }, 2000);
            
            // IMPORTANTE: Forçar aplicação da ordem personalizada após carregamento completo
            setTimeout(() => {
              forceApplySavedOrder();
            }, 2500);
          }, 1500);
        } else {
          console.log('Nenhum dado personalizado encontrado - mantendo ordem original das categorias');
          // Para campos sem dados personalizados, apenas sincronizar cores e nomes, sem reordenar
          setTimeout(() => {
            forceSyncAfterPageLoad();
          }, 1500);
        }
      } else {
        // Para outros tipos de simbologia, usar sincronização padrão
        setTimeout(() => {
          forceSyncAfterPageLoad();
          
          // IMPORTANTE: Verificar se a interface precisa de sincronização adicional
          setTimeout(() => {
            forceInterfaceSyncIfNeeded();
          }, 2000);
          
          // IMPORTANTE: Forçar aplicação da ordem personalizada após carregamento completo
          setTimeout(() => {
            forceApplySavedOrder();
          }, 2500);
        }, 1500);
      }
    });
    
    // Event listeners para mudanças
    document.getElementById('style-type').addEventListener('change', function() {
      const styleType = this.value;
      const fieldSelect = document.getElementById('field-select');
      const field = fieldSelect.value;
      
      applyVisibility();
      
      // Filtrar paletas baseado no tipo de simbologia
      filterPalettesForStyleType(styleType);
      
      // Se mudou para simbologia graduada, verificar se o campo é numérico
      if (styleType === 'graduated') {
        if (field && !isNumericField(field)) {
          showNumericFieldWarning(field);
          // Voltar para o tipo anterior ou padrão
          this.value = 'single';
          applyVisibility();
          return;
        }
        
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      } else if (styleType === 'categorized') {
        // Para simbologia categorizada, aceitar qualquer tipo de campo
        // e criar interface de categorias se houver campo selecionado
        if (field) {
          console.log(`Mudança para simbologia categorizada - aceitando campo: ${field}`);
          console.log('Simbologia categorizada funciona com qualquer tipo de campo (textual, numérico, etc.)');
          
          loadCategoriesForField(field).then(categories => {
            console.log(`Categorias carregadas para campo ${field}:`, categories);
            createCategorizedClassesInterface(categories);
            refreshPreview();
          });
        }
      }
      
      // Controlar visibilidade do modal method-info baseado no tipo de simbologia
      const methodInfoContainer = document.getElementById('method-info');
      if (methodInfoContainer) {
        if (styleType === 'categorized') {
          // Ocultar modal method-info para simbologia categorizada
          methodInfoContainer.classList.add('d-none');
        } else if (styleType === 'graduated') {
          // Mostrar modal method-info para simbologia graduada
          methodInfoContainer.classList.remove('d-none');
          showMethodInfo();
        } else {
          // Para outros tipos (single), ocultar modal method-info
          methodInfoContainer.classList.add('d-none');
        }
      }
      
      refreshPreview();
      saveUserConfig(); // Salvar configuração automaticamente
    });
    document.getElementById('geom-type').addEventListener('change', function() {
      applyVisibility();
      refreshPreview();
      saveUserConfig(); // Salvar configuração automaticamente
    });
    document.getElementById('method').addEventListener('change', function() {
      applyVisibility();
      
      // Atualizar informações do método apenas se for simbologia graduada
      const styleType = document.getElementById('style-type').value;
      if (styleType === 'graduated') {
        showMethodInfo();
      }
      
      saveUserConfig(); // Salvar configuração automaticamente
    });
    
    // Event listener para seleção de campo
    document.getElementById('field-select').addEventListener('change', async function() {
      const field = this.value;
      const styleType = document.getElementById('style-type').value;
      
      if (field && styleType === 'categorized') {
        console.log(`Campo selecionado para simbologia categorizada: ${field}`);
        console.log('Aceitando qualquer tipo de campo (textual, numérico, etc.)');
        
        const categories = await loadCategoriesForField(field);
        console.log(`Categorias carregadas: ${categories.length}`, categories);
        
        // Validar e corrigir consistência dos dados
        validateAndFixDataConsistency();
        createCategorizedClassesInterface(categories);
        // Limpar nomes duplicados após mudança de campo
        cleanupDuplicateNames();
        
        // IMPORTANTE: Forçar sincronização da legenda com a interface (com retry)
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry();
        }, 300);
        
        refreshPreview();
      } else if (field && styleType === 'graduated') {
        // Verificar se o campo é numérico para simbologia graduada
        if (!isNumericField(field)) {
          showNumericFieldWarning(field);
          // Limpar a seleção do campo
          this.value = '';
          return;
        }
        
        // Para simbologia graduada, atualizar interface de classes
        const style = computeStyle();
        createGraduatedClassesInterface(style);
        refreshPreview();
      }
      saveUserConfig(); // Salvar configuração automaticamente
    });
    
    document.getElementById('palette-select').addEventListener('change', function() {
      // Limpar cores personalizadas antes de aplicar nova paleta
      const field = document.getElementById('field-select').value;
      clearCustomColors(field);
      
      updatePalettePreview();
      
      const styleType = document.getElementById('style-type').value;
      
      // Se for simbologia graduada, apenas atualizar cores sem recriar interface
      if (styleType === 'graduated') {
        // Apenas atualizar as cores das classes existentes, preservando os valores
        updateGraduatedClassColors();
      } else if (styleType === 'categorized') {
        // Para simbologia categorizada, atualizar cores das categorias automaticamente
        console.log('Atualizando cores para simbologia categorizada');
        // Atualizar interface com novas cores
        updateCategorizedClassColors();
      }
      
      refreshPreview();
      saveUserConfig();
    });
    
    document.getElementById('palette-opacity').addEventListener('input', function() {
      // Atualizar valor exibido
      document.getElementById('opacity-value').textContent = this.value;
      
      refreshPreview();
      saveUserConfig();
    });
    
    document.getElementById('palette-invert').addEventListener('change', function() {
      // Limpar cores personalizadas antes de aplicar nova paleta
      const field = document.getElementById('field-select').value;
      clearCustomColors(field);
      
      updatePalettePreview();
      
      const styleType = document.getElementById('style-type').value;
      
      // Se for simbologia graduada, apenas atualizar cores sem recriar interface
      if (styleType === 'graduated') {
        // Apenas atualizar as cores das classes existentes, preservando os valores
        updateGraduatedClassColors();
      } else if (styleType === 'categorized') {
        // Para simbologia categorizada, atualizar cores das categorias automaticamente
        console.log('Atualizando cores para simbologia categorizada (invertida)');
        // Atualizar interface com novas cores
        updateCategorizedClassColors();
      }
      
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listener para legenda composta
    document.getElementById('composite-legend-toggle').addEventListener('change', function() {
      refreshPreview();
      saveUserConfig();
    });

    // Event listeners para o select customizado de paletas
    document.getElementById('palette-select-header').addEventListener('click', function() {
      const dropdown = document.getElementById('palette-select-dropdown');
      const icon = this.querySelector('i');
      
      if (dropdown.classList.contains('d-none')) {
        dropdown.classList.remove('d-none');
        icon.classList.remove('fa-chevron-down');
        icon.classList.add('fa-chevron-up');
      } else {
        dropdown.classList.add('d-none');
        icon.classList.remove('fa-chevron-up');
        icon.classList.add('fa-chevron-down');
      }
    });

    // Event listeners para as opções de paleta
    document.addEventListener('click', function(e) {
      if (e.target.closest('.palette-option')) {
        const option = e.target.closest('.palette-option');
        const value = option.dataset.value;
        const text = option.querySelector('span').textContent;
        
        console.log('Paleta selecionada:', value, text);
        
        // Atualizar o header
        document.getElementById('palette-select-text').textContent = text;
        document.getElementById('palette-select').value = value;
        
        // Fechar dropdown
        document.getElementById('palette-select-dropdown').classList.add('d-none');
        document.querySelector('#palette-select-header i').classList.remove('fa-chevron-up');
        document.querySelector('#palette-select-header i').classList.add('fa-chevron-down');
        
        // Atualizar preview da paleta imediatamente
        console.log('Atualizando preview da paleta...');
        updatePalettePreview();
        
        // Disparar evento de mudança após a atualização visual
        setTimeout(() => {
          console.log('Disparando evento change...');
          const event = new Event('change');
          document.getElementById('palette-select').dispatchEvent(event);
        }, 50);
      }
    });

    // Fechar dropdown ao clicar fora
    document.addEventListener('click', function(e) {
      if (!e.target.closest('.custom-palette-select')) {
        document.getElementById('palette-select-dropdown').classList.add('d-none');
        document.querySelector('#palette-select-header i').classList.remove('fa-chevron-up');
        document.querySelector('#palette-select-header i').classList.add('fa-chevron-down');
      }
    });
    
    // Event listeners para simbologia graduada
    document.getElementById('classes').addEventListener('change', function() {
      refreshPreview();
      
      // Se for simbologia graduada, atualizar interface de classes
      if (document.getElementById('style-type').value === 'graduated') {
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      }
      
      saveUserConfig();
    });
    
    document.getElementById('method').addEventListener('change', function() {
      applyVisibility();
      refreshPreview();
      
      // Se for simbologia graduada, atualizar interface de classes
      if (document.getElementById('style-type').value === 'graduated') {
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      }
      
      // Atualizar informações do método apenas se for simbologia graduada
      const styleType = document.getElementById('style-type').value;
      if (styleType === 'graduated') {
        showMethodInfo();
      }
      
      saveUserConfig();
    });
    
    // Event listener para breaks manuais
    document.getElementById('manual-breaks').addEventListener('input', function() {
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listeners para campos personalizados
    ['stroke-color', 'fill-color', 'stroke-weight', 'fill-opacity', 'point-radius', 'line-opacity', 'line-dash'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de polígono
    ['polygon-border-color', 'polygon-border-width', 'polygon-border-toggle'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de classificação
    ['classes', 'manual-breaks'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', function() {
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de rótulos
    ['labels-enabled', 'label-field-select', 'label-font', 'label-size', 'label-color', 'label-bold', 'label-italic', 'label-buffer-color', 'label-buffer-size', 'label-buffer-opacity', 'label-offset-x', 'label-offset-y'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listener específico para o slider de opacidade do buffer
    document.getElementById('label-buffer-opacity').addEventListener('input', function() {
      document.getElementById('buffer-opacity-value').textContent = this.value;
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listener para botão de aplicar simbologia
    document.getElementById('btn-apply').addEventListener('click', async function() {
      const style = computeStyle();
      
      if (!style.field) {
        showToast('Por favor, selecione um campo para simbologia.', 'warning');
        return;
      }
      
      try {
        // Salvar configurações do usuário antes de aplicar
        saveUserConfig();
        
        // Usar a função que já tem toda a lógica implementada
        const config = {
          field: style.field,
          styleType: style.type || 'graduated'
        };
        
        const success = await saveSymbologyToDatabase(config);
        
        if (!success) {
          showToast('Erro ao aplicar simbologia no portal', 'error');
        }
      } catch (error) {
        console.error('Erro ao aplicar simbologia:', error);
        showToast('Erro ao aplicar simbologia. Verifique o console para mais detalhes.', 'error');
      }
    });

    // Event listeners para controles de rótulos
    setupLabelEventListeners();

    // Event listener para botão de aplicar rótulos
    document.getElementById('btn-apply-labels').addEventListener('click', async function() {
      const labelConfig = getLabelConfiguration();

      if (!labelConfig.field) {
        showToast('Por favor, selecione um campo para rótulos.', 'warning');
        return;
      }

      try {
        saveUserConfig(); // Salvar configurações gerais

        const response = await fetch(`/admin/layer/${layerId}/labels/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(labelConfig)
        });

        if (response.ok) {
          showToast('Configurações de rótulos aplicadas com sucesso!', 'success');
          refreshPreview(); // Atualizar preview com novas configurações de rótulos
        } else {
          const error = await response.json();
          showToast(`Erro ao aplicar configurações de rótulos: ${error.error || 'Erro desconhecido'}`, 'error');
        }
      } catch (error) {
        console.error('Erro ao aplicar configurações de rótulos:', error);
        showToast('Erro ao aplicar configurações de rótulos. Verifique o console para mais detalhes.', 'error');
      }
    });

    // Event listener para botão de pré-visualizar rótulos
    document.getElementById('btn-preview-labels').addEventListener('click', function() {
      const labelConfig = getLabelConfiguration();
      if (!labelConfig.field) {
        showToast('Por favor, selecione um campo para rótulos.', 'warning');
        return;
      }
      
      previewLabels(labelConfig);
      showToast('Pré-visualização de rótulos atualizada!', 'info');
    });

    // Event listener para botão de resetar rótulos
    document.getElementById('btn-reset-labels').addEventListener('click', function() {
      resetLabelConfiguration();
      showToast('Configurações de rótulos resetadas!', 'info');
    });
    
    // Selecionar primeira paleta por padrão (Viridis)
    document.getElementById('palette-select').value = 'Viridis';
    
    // Configurar o select customizado com o valor padrão
    document.getElementById('palette-select-text').textContent = 'Viridis - Científica Moderna';
    
    // Event listeners para gerenciamento de paletas personalizadas
    document.getElementById('btn-create-palette').addEventListener('click', createNewPalette);
    document.getElementById('btn-save-current-palette').addEventListener('click', saveCurrentPalette);
    document.getElementById('btn-manage-palettes').addEventListener('click', managePalettes);
    
    // Carregar paletas personalizadas ao inicializar
    loadCustomPalettes();
    
    // Inicializar previews de cores das paletas
    initializePalettePreviews();
    
    // Configurar filtro inicial de paletas
    const initialStyleType = document.getElementById('style-type').value;
    filterPalettesForStyleType(initialStyleType);
  });

  // Função para inicializar os previews de cores das paletas
  function initializePalettePreviews() {
    const paletteOptions = document.querySelectorAll('.palette-preview-mini');
    
    paletteOptions.forEach(option => {
      const paletteName = option.dataset.palette;
      const colors = brewer(paletteName, 8, false);
      
      // Criar variáveis CSS para as cores
      let cssVars = '';
      colors.forEach((color, index) => {
        cssVars += `--color${index + 1}: ${color};`;
      });
      
      option.style.cssText = cssVars;
    });
    
    // Também inicializar previews das paletas personalizadas
    updateCustomPalettePreviews();
  }

  // Função para filtrar paletas baseado no tipo de simbologia
  function filterPalettesForStyleType(styleType) {
    console.log('filterPalettesForStyleType chamada com:', styleType);
    
    // Selecionar todos os grupos de paletas
    const qualitativeGroups = document.querySelectorAll('.palette-optgroup[data-type="qualitative"]');
    const sequentialGroups = document.querySelectorAll('.palette-optgroup[data-type="sequential"]');
    const divergentGroups = document.querySelectorAll('.palette-optgroup[data-type="divergent"]');
    const customGroups = document.querySelectorAll('.palette-optgroup[data-type="custom"]');
    
    console.log('Grupos encontrados:', {
      qualitative: qualitativeGroups.length,
      sequential: sequentialGroups.length,
      divergent: divergentGroups.length,
      custom: customGroups.length
    });
    
    // Primeiro, remover todas as classes de filtro
    const allGroups = document.querySelectorAll('.palette-optgroup');
    console.log('Total de grupos encontrados:', allGroups.length);
    
    allGroups.forEach(group => {
      group.classList.remove('show-for-graduated', 'show-for-categorized', 'show-for-single');
      console.log('Removendo classes de filtro do grupo:', group.dataset.type);
    });
    
    if (styleType === 'graduated') {
      console.log('Aplicando filtro para simbologia graduada');
      // Para simbologia graduada, mostrar apenas sequencial, divergente e personalizadas
      qualitativeGroups.forEach(group => {
        group.classList.add('show-for-graduated');
        group.style.setProperty('display', 'none', 'important');
        console.log('Ocultando grupo qualitativo:', group);
      });
      sequentialGroups.forEach(group => {
        group.classList.add('show-for-graduated');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo sequencial:', group);
      });
      divergentGroups.forEach(group => {
        group.classList.add('show-for-graduated');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo divergente:', group);
      });
      customGroups.forEach(group => {
        group.classList.add('show-for-graduated');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo personalizado:', group);
      });
    } else if (styleType === 'categorized') {
      console.log('Aplicando filtro para simbologia categorizada');
      // Para simbologia categorizada, mostrar APENAS qualitativas e personalizadas
      qualitativeGroups.forEach(group => {
        group.classList.add('show-for-categorized');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo qualitativo:', group);
      });
      sequentialGroups.forEach(group => {
        group.classList.add('show-for-categorized');
        group.style.setProperty('display', 'none', 'important');
        console.log('Ocultando grupo sequencial:', group);
      });
      divergentGroups.forEach(group => {
        group.classList.add('show-for-categorized');
        group.style.setProperty('display', 'none', 'important');
        console.log('Ocultando grupo divergente:', group);
      });
      customGroups.forEach(group => {
        group.classList.add('show-for-categorized');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo personalizado:', group);
      });
      console.log('Paletas habilitadas para simbologia categorizada: Qualitativas e Personalizadas');
    } else {
      console.log('Aplicando filtro para outros tipos');
      // Para outros tipos, mostrar todas as paletas
      qualitativeGroups.forEach(group => {
        group.classList.add('show-for-single');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo qualitativo:', group);
      });
      sequentialGroups.forEach(group => {
        group.classList.add('show-for-single');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo sequencial:', group);
      });
      divergentGroups.forEach(group => {
        group.classList.add('show-for-single');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo divergente:', group);
      });
      customGroups.forEach(group => {
        group.classList.add('show-for-single');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo personalizado:', group);
      });
    }
  }

  // Função para atualizar apenas as cores das classes graduadas (sem recriar interface)
  function updateGraduatedClassColors() {
    const style = computeStyle();
    if (!style || !style.field || !style.classes) return;
    
    const palette = style.palette || 'Blues';
    const colors = brewer(palette, style.classes, style.palette_invert);
    
    // Atualizar apenas as cores das classes existentes
    for (let i = 0; i < style.classes; i++) {
      const colorPreview = document.querySelector(`.color-preview[data-index="${i}"]`);
      const colorInput = document.querySelector(`.graduated-class-color[data-index="${i}"]`);
      const hexInput = document.querySelector(`.graduated-class-hex[data-index="${i}"]`);
      
      if (colorPreview && colorInput && hexInput) {
        // Verificar se há cor personalizada salva
        const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
        const newColor = savedColor || colors[i];
        
        // Atualizar elementos visuais
        colorPreview.style.backgroundColor = newColor;
        colorInput.value = newColor;
        hexInput.value = newColor;
        
        // Atualizar campos RGB se estiverem visíveis
        const rgbInputs = document.querySelector(`.graduated-class-rgb-inputs[data-index="${i}"]`);
        if (rgbInputs && !rgbInputs.classList.contains('d-none')) {
          const rgb = hexToRgb(newColor);
          if (rgb) {
            const rInput = rgbInputs.querySelector('input[placeholder="R"]');
            const gInput = rgbInputs.querySelector('input[placeholder="G"]');
            const bInput = rgbInputs.querySelector('input[placeholder="B"]');
            if (rInput && gInput && bInput) {
              rInput.value = rgb.r;
              gInput.value = rgb.g;
              bInput.value = rgb.b;
            }
          }
        }
      }
    }
  }

  // Função para aplicar estilo graduado
  function applyGraduatedStyle(layer, style) {
    if (!layerData || !style.field) return;
    
    // Coletar valores do campo selecionado
    const values = layerData.features
      .map(f => parseFloat(f.properties[style.field]))
      .filter(v => !isNaN(v))
      .sort((a, b) => a - b);
    
    if (values.length === 0) return;
    
    const min = values[0];
    const max = values[values.length - 1];
    const classes = style.classes || 5;
    
    // Gerar breaks baseado no método
    let breaks = [];
    if (style.method === 'equal') {
      // Equal Interval
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    } else if (style.method === 'quantile') {
      // Quantiles
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'jenks') {
      // Jenks Natural Breaks (simplificado)
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'log') {
      // Logarithmic
      const logMin = Math.log(Math.max(min, 0.1));
      const logMax = Math.log(max);
      const step = (logMax - logMin) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(Math.exp(logMin + (i * step)));
      }
    } else if (style.method === 'stddev') {
      // Standard Deviation
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
      const stddev = Math.sqrt(variance);
      
      // Criar classes baseadas em desvios padrão
      const stddevStep = (2 * stddev) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(mean - stddev + (i * stddevStep));
      }
    } else if (style.method === 'arithmetic') {
      // Arithmetic Progression
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    } else if (style.method === 'geometric') {
      // Geometric Progression
      const ratio = Math.pow(max / min, 1 / classes);
      for (let i = 0; i <= classes; i++) {
        breaks.push(min * Math.pow(ratio, i));
      }
    } else if (style.method === 'manual' && style.breaks) {
      breaks = style.breaks;
    }
    
    // Gerar cores da paleta
    const palette = style.palette || 'Blues';
    const colors = brewer(palette, classes, style.palette_invert);
    
    // Carregar cores personalizadas se disponíveis
    const customColors = [];
    for (let i = 0; i < classes; i++) {
      const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
      customColors.push(savedColor || colors[i]);
    }
    
    // Aplicar estilo a cada feature
    layer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.properties) {
        const value = parseFloat(featureLayer.feature.properties[style.field]);
        if (isNaN(value)) return;
        
        // Encontrar classe para o valor
        let colorIndex = 0;
        for (let i = 0; i < breaks.length - 1; i++) {
          if (value >= breaks[i] && value < breaks[i + 1]) {
            colorIndex = i;
            break;
          }
        }
        
        // Aplicar cor
        const color = customColors[colorIndex] || customColors[0];
        
        // Configurar estilo base
        const layerStyle = {
          fillColor: color,
          fillOpacity: style.palette_opacity || 1.0
        };
        
        // Aplicar configurações de borda se for polígono
        if (style.geometry_type === 'polygon') {
          if (style.border_color && style.border_width > 0) {
            layerStyle.color = style.border_color;
            layerStyle.weight = style.border_width;
          } else {
            // Se não quiser borda, definir como transparente
            layerStyle.color = 'transparent';
            layerStyle.weight = 0;
          }
        } else {
          // Para pontos e linhas, usar configurações padrão
          layerStyle.color = style.border_color || '#333333';
          layerStyle.weight = style.border_width || 1;
        }
        
        console.log('Aplicando estilo ao feature:', layerStyle);
        featureLayer.setStyle(layerStyle);
      }
    });
    
    // Log de execução da função
    console.log('applyGraduatedStyle executada com sucesso');
    
    // Atualizar legenda após aplicar o estilo
    setTimeout(() => {
      renderPreview();
    }, 100);
  }

  // ========================================
  // FUNÇÕES PARA RÓTULOS AVANÇADOS
  // ========================================

  /**
   * Configura todos os event listeners para controles de rótulos
   */
  function setupLabelEventListeners() {
    // Sliders com valores dinâmicos
    const sliders = [
      { id: 'label-opacity', valueId: 'text-opacity-value', suffix: '' },
      { id: 'label-buffer-opacity', valueId: 'buffer-opacity-value', suffix: '' },
      { id: 'label-stroke-opacity', valueId: 'stroke-opacity-value', suffix: '' },
      { id: 'label-rotation', valueId: 'rotation-value', suffix: '°' },
      { id: 'label-callout-opacity', valueId: 'callout-opacity-value', suffix: '' }
    ];

    sliders.forEach(slider => {
      const element = document.getElementById(slider.id);
      const valueElement = document.getElementById(slider.valueId);
      
      if (element && valueElement) {
        element.addEventListener('input', function() {
          valueElement.textContent = this.value + slider.suffix;
        });
      }
    });

    // Event listeners para habilitar/desabilitar seções
    document.getElementById('label-buffer-enabled').addEventListener('change', function() {
      toggleLabelSection('buffer', this.checked);
    });

    document.getElementById('label-stroke-enabled').addEventListener('change', function() {
      toggleLabelSection('stroke', this.checked);
    });

    document.getElementById('label-callout-enabled').addEventListener('change', function() {
      toggleLabelSection('callout', this.checked);
    });

    document.getElementById('label-filter-enabled').addEventListener('change', function() {
      toggleLabelSection('filter', this.checked);
    });

    // Event listeners para pré-visualização em tempo real
    const previewElements = [
      'label-field-select', 'label-font', 'label-size', 'label-color',
      'label-bold', 'label-italic', 'label-underline', 'label-uppercase',
      'label-rotation', 'label-alignment', 'label-opacity'
    ];

    previewElements.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', debounce(updateLabelPreview, 300));
      }
    });
  }

  /**
   * Habilita/desabilita seções de configuração de rótulos
   */
  function toggleLabelSection(section, enabled) {
    const sectionMap = {
      'buffer': ['label-buffer-color', 'label-buffer-size', 'label-buffer-opacity'],
      'stroke': ['label-stroke-color', 'label-stroke-width', 'label-stroke-opacity'],
      'callout': ['label-callout-color', 'label-callout-width', 'label-callout-style', 
                  'label-callout-opacity', 'label-arrow-type', 'label-arrow-size', 
                  'label-callout-max-distance'],
      'filter': ['label-filter-expression']
    };

    const elements = sectionMap[section] || [];
    elements.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.disabled = !enabled;
        element.style.opacity = enabled ? '1' : '0.5';
      }
    });
  }

  /**
   * Configura controles específicos para linhas na simbologia categorizada
   */
  function setupLineSpecificControls() {
    console.log('setupLineSpecificControls: Configurando controles específicos para linhas');
    
    // Event listener para espessura padrão das linhas
    const lineWeightDefault = document.getElementById('line-weight-default');
    if (lineWeightDefault) {
      lineWeightDefault.addEventListener('change', function() {
        console.log('Espessura padrão das linhas alterada:', this.value);
        updateAllLineWeights(this.value);
        refreshPreview();
      });
    }
    
    // Event listener para opacidade padrão das linhas
    const lineOpacityDefault = document.getElementById('line-opacity-default');
    if (lineOpacityDefault) {
      lineOpacityDefault.addEventListener('input', function() {
        const value = this.value;
        document.getElementById('line-opacity-value').textContent = value;
        console.log('Opacidade padrão das linhas alterada:', value);
        updateAllLineOpacities(value);
        refreshPreview();
      });
    }
    
    // Event listener para estilo padrão das linhas
    const lineStyleDefault = document.getElementById('line-style-default');
    if (lineStyleDefault) {
      lineStyleDefault.addEventListener('change', function() {
        console.log('Estilo padrão das linhas alterado:', this.value);
        updateAllLineStyles(this.value);
        refreshPreview();
      });
    }
    
    // Event listener para permitir personalização individual por categoria
    const allowCustomPerCategory = document.getElementById('line-allow-custom-per-category');
    if (allowCustomPerCategory) {
      allowCustomPerCategory.addEventListener('change', function() {
        console.log('Personalização individual por categoria:', this.checked);
        toggleIndividualLineControls(this.checked);
        refreshPreview();
      });
    }
  }

  /**
   * Atualiza a espessura de todas as linhas para o valor padrão
   */
  function updateAllLineWeights(weight) {
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    categoryItems.forEach(item => {
      const weightInput = item.querySelector('.line-weight-input');
      if (weightInput) {
        weightInput.value = weight;
        // Disparar evento de mudança para atualizar a interface
        weightInput.dispatchEvent(new Event('change'));
      }
    });
  }

  /**
   * Atualiza a opacidade de todas as linhas para o valor padrão
   */
  function updateAllLineOpacities(opacity) {
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    categoryItems.forEach(item => {
      const opacityInput = item.querySelector('.line-opacity-input');
      if (opacityInput) {
        opacityInput.value = opacity;
        // Disparar evento de mudança para atualizar a interface
        opacityInput.dispatchEvent(new Event('change'));
      }
    });
  }

  /**
   * Atualiza o estilo de todas as linhas para o valor padrão
   */
  function updateAllLineStyles(style) {
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    categoryItems.forEach(item => {
      const styleSelect = item.querySelector('.line-style-select');
      if (styleSelect) {
        styleSelect.value = style;
        // Disparar evento de mudança para atualizar a interface
        styleSelect.dispatchEvent(new Event('change'));
      }
    });
  }

  /**
   * Habilita/desabilita controles individuais de linha por categoria
   */
  function toggleIndividualLineControls(enabled) {
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    categoryItems.forEach(item => {
      const lineControls = item.querySelectorAll('.line-control-individual');
      lineControls.forEach(control => {
        control.disabled = !enabled;
        control.style.opacity = enabled ? '1' : '0.5';
      });
    });
  }

  /**
   * Coleta todas as configurações de rótulos
   */
  function getLabelConfiguration() {
    return {
      // Configurações básicas
      enabled: document.getElementById('labels-enabled').checked,
      field: document.getElementById('label-field-select').value,
      font: document.getElementById('label-font').value,
      size: parseInt(document.getElementById('label-size').value),
      color: document.getElementById('label-color').value,
      opacity: parseFloat(document.getElementById('label-opacity').value),
      
      // Estilo do texto
      bold: document.getElementById('label-bold').checked,
      italic: document.getElementById('label-italic').checked,
      underline: document.getElementById('label-underline').checked,
      uppercase: document.getElementById('label-uppercase').checked,
      rotation: parseInt(document.getElementById('label-rotation').value),
      alignment: document.getElementById('label-alignment').value,
      
      // Buffer
      bufferEnabled: document.getElementById('label-buffer-enabled').checked,
      bufferColor: document.getElementById('label-buffer-color').value,
      bufferSize: parseFloat(document.getElementById('label-buffer-size').value),
      bufferOpacity: parseFloat(document.getElementById('label-buffer-opacity').value),
      
      // Contorno
      strokeEnabled: document.getElementById('label-stroke-enabled').checked,
      strokeColor: document.getElementById('label-stroke-color').value,
      strokeWidth: parseFloat(document.getElementById('label-stroke-width').value),
      strokeOpacity: parseFloat(document.getElementById('label-stroke-opacity').value),
      
      // Posicionamento
      offsetX: parseInt(document.getElementById('label-offset-x').value),
      offsetY: parseInt(document.getElementById('label-offset-y').value),
      collisionDetection: document.getElementById('label-collision-detection').checked,
      minDistance: parseInt(document.getElementById('label-min-distance').value),
      priority: document.getElementById('label-priority').value,
      maxPerScreen: parseInt(document.getElementById('label-max-per-screen').value),
      
      // Linhas de chamada
      calloutEnabled: document.getElementById('label-callout-enabled').checked,
      calloutColor: document.getElementById('label-callout-color').value,
      calloutWidth: parseFloat(document.getElementById('label-callout-width').value),
      calloutStyle: document.getElementById('label-callout-style').value,
      calloutOpacity: parseFloat(document.getElementById('label-callout-opacity').value),
      arrowType: document.getElementById('label-arrow-type').value,
      arrowSize: parseInt(document.getElementById('label-arrow-size').value),
      calloutMaxDistance: parseInt(document.getElementById('label-callout-max-distance').value),
      
      // Filtros
      minZoom: parseInt(document.getElementById('label-min-zoom').value),
      maxZoom: parseInt(document.getElementById('label-max-zoom').value),
      filterEnabled: document.getElementById('label-filter-enabled').checked,
      filterExpression: document.getElementById('label-filter-expression').value
    };
  }

  /**
   * Aplica pré-visualização de rótulos no mapa
   */
  function previewLabels(labelConfig) {
    if (!currentLayer || !labelConfig.enabled || !labelConfig.field) {
      return;
    }

    // Remover rótulos existentes
    if (window.labelLayer) {
      map.removeLayer(window.labelLayer);
    }

    // Criar nova camada de rótulos
    window.labelLayer = L.layerGroup();

    currentLayer.eachLayer(function(layer) {
      if (layer.feature && layer.feature.properties) {
        const properties = layer.feature.properties;
        const labelText = properties[labelConfig.field];
        
        if (labelText !== null && labelText !== undefined) {
          // Aplicar filtros se habilitados
          if (labelConfig.filterEnabled && labelConfig.filterExpression) {
            if (!evaluateFilterExpression(properties, labelConfig.filterExpression)) {
              return;
            }
          }

          // Calcular posição do rótulo
          const bounds = layer.getBounds ? layer.getBounds() : null;
          const center = bounds ? bounds.getCenter() : layer.getLatLng();
          
          if (center) {
            const labelPosition = calculateLabelPosition(center, labelConfig);
            const labelMarker = createLabelMarker(labelText, labelPosition, labelConfig, center);
            
            window.labelLayer.addLayer(labelMarker);
          }
        }
      }
    });

    // Adicionar camada de rótulos ao mapa
    window.labelLayer.addTo(map);
  }

  /**
   * Calcula a posição do rótulo baseado no alinhamento e deslocamento
   */
  function calculateLabelPosition(center, config) {
    const offsetX = config.offsetX || 0;
    const offsetY = config.offsetY || 0;
    
    // Converter pixels para graus (aproximação)
    const pixelToDegree = 0.0001;
    
    return L.latLng(
      center.lat + (offsetY * pixelToDegree),
      center.lng + (offsetX * pixelToDegree)
    );
  }

  /**
   * Cria um marcador de rótulo com todas as configurações aplicadas
   */
  function createLabelMarker(text, position, config, originalPosition) {
    // Aplicar transformações de texto
    let displayText = text.toString();
    if (config.uppercase) {
      displayText = displayText.toUpperCase();
    }

    // Criar estilos CSS
    const styles = {
      fontFamily: config.font || 'Arial',
      fontSize: (config.size || 12) + 'px',
      color: config.color || '#000000',
      opacity: config.opacity || 1,
      fontWeight: config.bold ? 'bold' : 'normal',
      fontStyle: config.italic ? 'italic' : 'normal',
      textDecoration: config.underline ? 'underline' : 'none',
      transform: `rotate(${config.rotation || 0}deg)`,
      textAlign: getTextAlign(config.alignment),
      whiteSpace: 'nowrap',
      pointerEvents: 'none',
      zIndex: 1000
    };

    // Aplicar buffer se habilitado
    if (config.bufferEnabled && config.bufferSize > 0) {
      styles.textShadow = createTextShadow(config);
    }

    // Aplicar contorno se habilitado
    if (config.strokeEnabled && config.strokeWidth > 0) {
      styles.webkitTextStroke = `${config.strokeWidth}px ${config.strokeColor}`;
      styles.webkitTextStrokeOpacity = config.strokeOpacity || 1;
    }

    // Criar HTML do rótulo
    const labelHtml = `<div style="${objectToCSS(styles)}">${displayText}</div>`;

    // Criar marcador
    const labelMarker = L.marker(position, {
      icon: L.divIcon({
        html: labelHtml,
        className: 'custom-label-marker',
        iconSize: [0, 0],
        iconAnchor: [0, 0]
      })
    });

    // Adicionar linha de chamada se habilitada e necessária
    if (config.calloutEnabled && config.offsetX !== 0 || config.offsetY !== 0) {
      const calloutLine = createCalloutLine(originalPosition, position, config);
      if (calloutLine) {
        labelMarker.calloutLine = calloutLine;
      }
    }

    return labelMarker;
  }

  /**
   * Cria sombra de texto para buffer
   */
  function createTextShadow(config) {
    const size = config.bufferSize;
    const color = config.bufferColor;
    const opacity = config.bufferOpacity;
    
    const shadows = [];
    for (let x = -size; x <= size; x++) {
      for (let y = -size; y <= size; y++) {
        if (x !== 0 || y !== 0) {
          shadows.push(`${x}px ${y}px 0 ${color}`);
        }
      }
    }
    
    return shadows.join(', ');
  }

  /**
   * Converte alinhamento para CSS text-align
   */
  function getTextAlign(alignment) {
    const alignMap = {
      'left': 'left',
      'right': 'right',
      'center': 'center',
      'top': 'center',
      'bottom': 'center',
      'top-left': 'left',
      'top-right': 'right',
      'bottom-left': 'left',
      'bottom-right': 'right'
    };
    
    return alignMap[alignment] || 'center';
  }

  /**
   * Converte objeto de estilos para string CSS
   */
  function objectToCSS(styles) {
    return Object.entries(styles)
      .map(([key, value]) => `${camelToKebab(key)}: ${value}`)
      .join('; ');
  }

  /**
   * Converte camelCase para kebab-case
   */
  function camelToKebab(str) {
    return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
  }

  /**
   * Cria linha de chamada entre rótulo e ponto original
   */
  function createCalloutLine(start, end, config) {
    const distance = start.distanceTo(end);
    
    if (distance > config.calloutMaxDistance) {
      return null;
    }

    const lineOptions = {
      color: config.calloutColor || '#666666',
      weight: config.calloutWidth || 1,
      opacity: config.calloutOpacity || 0.7,
      dashArray: getLineDashArray(config.calloutStyle)
    };

    return L.polyline([start, end], lineOptions);
  }

  /**
   * Retorna padrão de linha baseado no estilo
   */
  function getLineDashArray(style) {
    const patterns = {
      'solid': null,
      'dashed': '10, 5',
      'dotted': '2, 3'
    };
    
    return patterns[style] || null;
  }

  /**
   * Avalia expressão de filtro
   */
  function evaluateFilterExpression(properties, expression) {
    try {
      // Substituir nomes de campos por valores
      let evalExpression = expression;
      
      Object.keys(properties).forEach(key => {
        const value = properties[key];
        const regex = new RegExp(`\\b${key}\\b`, 'g');
        
        if (typeof value === 'string') {
          evalExpression = evalExpression.replace(regex, `"${value}"`);
        } else {
          evalExpression = evalExpression.replace(regex, value);
        }
      });

      // Substituir operadores SQL por JavaScript
      evalExpression = evalExpression
        .replace(/\bAND\b/g, '&&')
        .replace(/\bOR\b/g, '||')
        .replace(/\bLIKE\b/g, '.includes')
        .replace(/=/g, '==');

      // Avaliar expressão (cuidado com segurança em produção)
      return new Function('return ' + evalExpression)();
    } catch (error) {
      console.warn('Erro ao avaliar expressão de filtro:', error);
      return true;
    }
  }

  /**
   * Reseta configurações de rótulos para padrão
   */
  function resetLabelConfiguration() {
    // Configurações básicas
    document.getElementById('labels-enabled').checked = true;
    document.getElementById('label-field-select').value = '';
    document.getElementById('label-font').value = 'Arial';
    document.getElementById('label-size').value = 12;
    document.getElementById('label-color').value = '#000000';
    document.getElementById('label-opacity').value = 1;
    document.getElementById('text-opacity-value').textContent = '1.0';
    
    // Estilo do texto
    document.getElementById('label-bold').checked = false;
    document.getElementById('label-italic').checked = false;
    document.getElementById('label-underline').checked = false;
    document.getElementById('label-uppercase').checked = false;
    document.getElementById('label-rotation').value = 0;
    document.getElementById('rotation-value').textContent = '0°';
    document.getElementById('label-alignment').value = 'center';
    
    // Buffer
    document.getElementById('label-buffer-enabled').checked = true;
    document.getElementById('label-buffer-color').value = '#ffffff';
    document.getElementById('label-buffer-size').value = 2;
    document.getElementById('label-buffer-opacity').value = 0.8;
    document.getElementById('buffer-opacity-value').textContent = '0.8';
    
    // Contorno
    document.getElementById('label-stroke-enabled').checked = false;
    document.getElementById('label-stroke-color').value = '#000000';
    document.getElementById('label-stroke-width').value = 1;
    document.getElementById('label-stroke-opacity').value = 1;
    document.getElementById('stroke-opacity-value').textContent = '1.0';
    
    // Posicionamento
    document.getElementById('label-offset-x').value = 0;
    document.getElementById('label-offset-y').value = 0;
    document.getElementById('label-collision-detection').checked = true;
    document.getElementById('label-min-distance').value = 10;
    document.getElementById('label-priority').value = 'medium';
    document.getElementById('label-max-per-screen').value = 100;
    
    // Linhas de chamada
    document.getElementById('label-callout-enabled').checked = false;
    document.getElementById('label-callout-color').value = '#666666';
    document.getElementById('label-callout-width').value = 1;
    document.getElementById('label-callout-style').value = 'solid';
    document.getElementById('label-callout-opacity').value = 0.7;
    document.getElementById('callout-opacity-value').textContent = '0.7';
    document.getElementById('label-arrow-type').value = 'simple';
    document.getElementById('label-arrow-size').value = 6;
    document.getElementById('label-callout-max-distance').value = 50;
    
    // Filtros
    document.getElementById('label-min-zoom').value = 1;
    document.getElementById('label-max-zoom').value = 20;
    document.getElementById('label-filter-enabled').checked = false;
    document.getElementById('label-filter-expression').value = '';

    // Atualizar seções habilitadas/desabilitadas
    toggleLabelSection('buffer', true);
    toggleLabelSection('stroke', false);
    toggleLabelSection('callout', false);
    toggleLabelSection('filter', false);
  }

  /**
   * Atualiza pré-visualização de rótulos em tempo real
   */
  function updateLabelPreview() {
    const labelConfig = getLabelConfiguration();
    if (labelConfig.enabled && labelConfig.field) {
      previewLabels(labelConfig);
    }
  }

  /**
   * Função debounce para otimizar performance
   */
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
</script>
{% endblock %}