{% extends 'layout.html' %}
{% block content %}
<h2>Simbologia: {{ layer.name }}</h2>
<div class="row">
  <div class="col-lg-6">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">Configurações de Simbologia</h5>
      </div>
      <div class="card-body">
        <!-- Abas para organizar simbologia e rótulos -->
        <ul class="nav nav-tabs" id="symbologyTabs" role="tablist">
          <li class="nav-item" role="presentation">
            <button class="nav-link active" id="symbology-tab" data-bs-toggle="tab" data-bs-target="#symbology-content" type="button" role="tab">
              <i class="fas fa-palette"></i> Simbologia
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="labels-tab" data-bs-toggle="tab" data-bs-target="#labels-content" type="button" role="tab">
              <i class="fas fa-font"></i> Rótulos
            </button>
          </li>
        </ul>
        
        <div class="tab-content mt-3" id="symbologyTabsContent">
          <!-- Aba de Simbologia -->
          <div class="tab-pane fade show active" id="symbology-content" role="tabpanel">
            <div class="row g-3">
              <div class="col-md-6">
                <label class="form-label">Tipo de Geometria</label>
                <select id="geom-type" class="form-select">
                  <option value="point">Ponto</option>
                  <option value="line">Linha</option>
                  <option value="polygon">Polígono</option>
                  <option value="raster">Raster</option>
                </select>
              </div>
              <div class="col-md-6">
                <label class="form-label">Campo para Simbologia</label>
                <select id="field-select" class="form-select">
                  <option value="">Selecione uma coluna...</option>
                </select>
              </div>
              <div class="col-md-12">
                <label for="style-type" class="form-label">Tipo de Simbologia</label>
                <select class="form-select" id="style-type">
                  <option value="single">Símbolo Único</option>
                  <option value="categorized">Categorizada</option>
                  <option value="graduated">Graduada</option>
                  <option value="raster">Raster</option>
                </select>
              </div>
              
              <!-- Blocos condicionais de simbologia -->
              <div class="col-md-4 d-none" id="block-classes">
                <label class="form-label">Número de classes</label>
                <input id="classes" type="number" class="form-control" min="2" max="20" value="5">
              </div>
              <div class="col-md-4 d-none" id="block-method">
                <label class="form-label">Método de Classificação</label>
                <select id="method" class="form-select">
                  <option value="equal">Intervalos Iguais</option>
                  <option value="quantiles">Quantis (Equal Count)</option>
                  <option value="jenks">Quebras Naturais (Jenks)</option>
                  <option value="log">Logarítmica</option>
                  <option value="stddev">Desvio Padrão</option>
                  <option value="arithmetic">Progressão Aritmética</option>
                  <option value="geometric">Progressão Geométrica</option>
                  <option value="manual">Manual</option>
                </select>
                <small class="text-muted">
                  <strong>Intervalos Iguais:</strong> Divide o range em classes de mesmo tamanho<br>
                  <strong>Quantis:</strong> Cada classe tem o mesmo número de elementos<br>
                  <strong>Jenks:</strong> Otimiza a separação natural dos dados<br>
                  <strong>Logarítmica:</strong> Para dados com distribuição exponencial<br>
                  <strong>Desvio Padrão:</strong> Baseado na distribuição estatística<br>
                  <strong>Progressão Aritmética:</strong> Crescimento linear entre classes<br>
                  <strong>Progressão Geométrica:</strong> Crescimento exponencial entre classes
                </small>
              </div>
              <div class="col-md-12 d-none" id="block-manual">
                <label class="form-label">Intervalos (separados por vírgula)</label>
                <input id="manual-breaks" class="form-control" placeholder="ex.: 0, 10, 25, 50, 100">
              </div>
              
              <!-- Paleta de cores -->
              <div class="col-md-12" id="block-palette">
                <label class="form-label">Paleta de Cores</label>
                <select id="palette-select" class="form-select mb-3">
                  <optgroup label="Sequencial (Dados Quantitativos Ordenados)">
                    <option value="Viridis">Viridis - Científica Moderna</option>
                    <option value="Cividis">Cividis - Daltonismo Seguro</option>
                    <option value="Blues">Blues - Água/Precipitação</option>
                    <option value="Greens">Greens - Vegetação/Agricultura</option>
                    <option value="YlOrRd">YlOrRd - Calor/Densidade</option>
                    <option value="Purples">Purples - Magnitude</option>
                    <option value="Greys">Greys - Mapa Base</option>
                  </optgroup>
                  <optgroup label="Divergente (Dados com Ponto Central)">
                    <option value="RdYlBu">RdYlBu - Anomalias (Seguro)</option>
                    <option value="RdYlGn">RdYlGn - Clássica</option>
                    <option value="BrBG">BrBG - Vegetação vs Solo</option>
                    <option value="PiYG">PiYG - Alternativa Verde</option>
                    <option value="Coolwarm">Coolwarm - Azul-Vermelho</option>
                    <option value="Spectral">Spectral - Topografia</option>
                  </optgroup>
                  <optgroup label="Qualitativo (Dados Categóricos)">
                    <option value="Vivid (Início Verde)">Vivid (Início Verde) - Personalizada</option>
                    <option value="Vivid (Início Azul)">Vivid (Início Azul) - Personalizada</option>
                    <option value="Tableau Tab10">Tableau Tab10 - Moderna</option>
                    <option value="ColorBrewer Paired">ColorBrewer Paired - Pares</option>
                    <option value="ColorBrewer Set3">ColorBrewer Set3 - Suave</option>
                  </optgroup>
                </select>
                
                <!-- Visualização da paleta selecionada -->
                <div id="palette-preview" class="mb-3">
                  <label class="form-label">Visualização da Paleta:</label>
                  <div id="palette-colors" class="d-flex gap-1"></div>
                </div>
                
                <div class="row g-2">
                  <div class="col-md-6">
                    <label class="form-label">Opacidade da paleta</label>
                    <input id="palette-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="0.6">
                    <small class="text-muted">Valor: <span id="opacity-value">0.6</span></small>
                  </div>
                  <div class="col-md-6">
                    <div class="form-check form-switch mt-4">
                      <input class="form-check-input" type="checkbox" id="palette-invert">
                      <label class="form-check-label" for="palette-invert">Inverter ordem das cores</label>
                    </div>
                    <small class="text-muted d-block">Inverte a ordem das cores da paleta selecionada</small>
                  </div>
                </div>
                <div class="row g-2 mt-2">
                  <div class="col-md-6 d-none" id="block-polygon-border">
                    <label class="form-label">Cor da borda</label>
                    <input type="color" id="polygon-border-color" class="form-control form-control-color" value="#333333">
                    <label class="form-label mt-2">Espessura da borda</label>
                    <input type="number" id="polygon-border-width" class="form-control" min="0" max="10" value="2">
                    <div class="form-check form-switch mt-2">
                      <input class="form-check-input" type="checkbox" id="polygon-border-toggle" checked>
                      <label class="form-check-label" for="polygon-border-toggle">Exibir borda dos polígonos</label>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Editor de categorias -->
              <div class="col-md-12 d-none" id="block-category-editor">
                <label class="form-label">Cores e Nomes das Classes</label>
                <div class="alert alert-info">
                  <i class="fas fa-info-circle"></i>
                  <strong>Dica:</strong> Clique no nome da classe para editá-lo. As mudanças são aplicadas automaticamente ao mapa.
                </div>
                <div id="category-list" class="d-flex flex-column gap-2"></div>
              </div>
              
              <!-- Cor personalizada (apenas Símbolo Único) -->
              <div class="col-md-12 d-none" id="block-custom-color">
                <label class="form-label">Cor Personalizada (apenas Símbolo Único)</label>
                <div class="row g-3">
                  <div class="col-md-6">
                    <label class="form-label">Borda</label>
                    <input id="stroke-color" type="color" class="form-control form-control-color" value="#333333">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Preenchimento</label>
                    <input id="fill-color" type="color" class="form-control form-control-color" value="#38bdf8">
                  </div>
                </div>
                <div class="row g-3 mt-2">
                  <div class="col-md-6">
                    <label class="form-label">Espessura</label>
                    <input id="stroke-weight" type="number" class="form-control" value="2" min="0" max="10">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Opacidade</label>
                    <input id="fill-opacity" type="number" class="form-control" value="0.3" step="0.05" min="0" max="1">
                  </div>
                </div>
                <div class="row g-3 mt-2" id="block-point-only">
                  <div class="col-md-6">
                    <label class="form-label">Raio (ponto)</label>
                    <input id="point-radius" type="number" class="form-control" value="6" min="1" max="50">
                  </div>
                </div>
                <div class="row g-3 mt-2 d-none" id="block-line-only">
                  <div class="col-md-6">
                    <label class="form-label">Opacidade da linha</label>
                    <input id="line-opacity" type="number" class="form-control" value="1" step="0.05" min="0" max="1">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Tracejado</label>
                    <input id="line-dash" class="form-control" placeholder="ex.: 4,2 (padrão: contínua)">
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Aba de Rótulos -->
          <div class="tab-pane fade" id="labels-content" role="tabpanel">
            <div class="row g-3">
              <div class="col-md-12">
                <div class="form-check form-switch">
                  <input class="form-check-input" type="checkbox" id="labels-enabled" checked>
                  <label class="form-check-label" for="labels-enabled">
                    <strong>Habilitar Rótulos</strong>
                  </label>
                  <small class="text-muted d-block">Marque para exibir rótulos na camada</small>
                </div>
              </div>
              
              <div class="col-md-6">
                <label class="form-label">Campo para Rótulo</label>
                <select id="label-field-select" class="form-select">
                  <option value="">Selecione uma coluna...</option>
                </select>
              </div>
              <div class="col-md-6">
                <label class="form-label">Fonte</label>
                <select id="label-font" class="form-select">
                  <option value="Arial">Arial</option>
                  <option value="Helvetica">Helvetica</option>
                  <option value="Times New Roman">Times New Roman</option>
                  <option value="Georgia">Georgia</option>
                  <option value="Verdana">Verdana</option>
                  <option value="Courier New">Courier New</option>
                </select>
              </div>
              <div class="col-md-6">
                <label class="form-label">Tamanho da Fonte</label>
                <input id="label-size" type="number" class="form-control" min="8" max="72" value="12">
              </div>
              <div class="col-md-6">
                <label class="form-label">Cor do Texto</label>
                <input id="label-color" type="color" class="form-control form-control-color" value="#000000">
              </div>
              <div class="col-md-6">
                <div class="form-check form-switch mt-4">
                  <input class="form-check-input" type="checkbox" id="label-bold">
                  <label class="form-check-label" for="label-bold">Negrito</label>
                </div>
              </div>
              <div class="col-md-6">
                <div class="form-check form-switch mt-4">
                  <input class="form-check-input" type="checkbox" id="label-italic">
                  <label class="form-check-label" for="label-italic">Itálico</label>
                </div>
              </div>
              <div class="col-md-6">
                <label class="form-label">Cor do Buffer</label>
                <input id="label-buffer-color" type="color" class="form-control form-control-color" value="#ffffff">
              </div>
              <div class="col-md-6">
                <label class="form-label">Tamanho do Buffer</label>
                <input id="label-buffer-size" type="number" class="form-control" min="0" max="20" value="2" step="0.5">
              </div>
              <div class="col-md-6">
                <label class="form-label">Opacidade do Buffer</label>
                <input id="label-buffer-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="0.8">
                <small class="text-muted">Valor: <span id="buffer-opacity-value">0.8</span></small>
              </div>
              <div class="col-md-6">
                <label class="form-label">Deslocamento X</label>
                <input id="label-offset-x" type="number" class="form-control" min="-50" max="50" value="0">
              </div>
              <div class="col-md-6">
                <label class="form-label">Deslocamento Y</label>
                <input id="label-offset-y" type="number" class="form-control" min="-50" max="50" value="0">
              </div>
              
              <div class="col-md-12 mt-3">
                <button type="button" id="btn-apply-labels" class="btn btn-success">
                  <i class="fas fa-font"></i> Aplicar Rótulos
                </button>
                <small class="text-muted d-block mt-1">Clique para aplicar as configurações de rótulos ao mapa</small>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    <div class="col-lg-6">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0">Pré-visualização</h5>
        </div>
        <div class="card-body">
          <div class="d-flex justify-content-between align-items-center mb-3">
            <button id="btn-apply" class="btn btn-primary btn-sm">Aplicar Simbologia</button>
            <a class="btn btn-secondary btn-sm" href="{{ url_for('admin_dashboard') }}">Cancelar</a>
          </div>
          <div class="mb-2">
            <label class="form-label">Basemap:</label>
            <select id="basemap-select" class="form-select form-select-sm">
              <option value="osm">OpenStreetMap</option>
              <option value="google-streets">Google Streets</option>
              <option value="google-satellite">Google Satellite</option>
              <option value="google-hybrid">Google Hybrid</option>
              <option value="google-terrain">Google Terrain</option>
            </select>
          </div>
          <div id="symbology-map" style="height: 50vh;" class="mb-3 border rounded"></div>
          <div id="preview-legend" class="mb-2"></div>
          <div class="text-muted small">A legenda acima reflete a configuração atual e será exibida no portal.</div>
        </div>
      </div>
    </div>
  </div>


  </div>
</div>
{% endblock %}
{% block scripts %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  let map, layerData, currentLayer, currentBasemap;
  const layerId = {{ layer.id }};
  
  // Paletas ColorBrewer expandidas
  const colorBrewer = {
    sequential: ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'BuGn', 'BuPu', 'GnBu', 'OrRd', 'PuBu', 'PuRd', 'RdPu', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd'],
    diverging: ['RdBu', 'RdYlBu', 'RdYlGn', 'BrBG', 'PiYG', 'PRGn', 'PuOr', 'Spectral'],
    qualitative: ['Set1', 'Set2', 'Set3', 'Paired', 'Accent', 'Dark2', 'Pastel1', 'Pastel2', 'tab10', 'tab20', 'tab20b', 'tab20c']
  };

  // Função para gerar cores únicas baseadas em HSL
  function generateUniqueColors(count) {
    const colors = [];
    const hueStep = 360 / count;
    const saturation = 70; // 70% saturation
    const lightness = 60;  // 60% lightness
    
    for (let i = 0; i < count; i++) {
      const hue = (i * hueStep) % 360;
      colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
    }
    return colors;
  }

  // Função para converter HSL para HEX
  function hslToHex(h, s, l) {
    s /= 100;
    l /= 100;
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h / 60) % 2 - 1));
    const m = l - c/2;
    let r = 0, g = 0, b = 0;
    if (0 <= h && h < 60) {
      r = c; g = x; b = 0;
    } else if (60 <= h && h < 120) {
      r = x; g = c; b = 0;
    } else if (120 <= h && h < 180) {
      r = 0; g = c; b = x;
    } else if (180 <= h && h < 240) {
      r = 0; g = x; b = c;
    } else if (240 <= h && h < 300) {
      r = x; g = 0; b = c;
    } else if (300 <= h && h < 360) {
      r = c; g = 0; b = x;
    }
    const rHex = Math.round((r + m) * 255).toString(16).padStart(2, '0');
    const gHex = Math.round((g + m) * 255).toString(16).padStart(2, '0');
    const bHex = Math.round((b + m) * 255).toString(16).padStart(2, '0');
    return `#${rHex}${gHex}${bHex}`;
  }

  // Função para gerar cores da paleta ColorBrewer
  function brewer(palette, count, invert = false) {
    const palettes = {
      // Sequential palettes
      'viridis': ['#440154', '#482878', '#3e4989', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6ece58', '#b5de2b', '#fde725'],
      'plasma': ['#0d0887', '#41049d', '#6a00a8', '#8f0aa4', '#b12a90', '#cc4778', '#e16462', '#f1834b', '#fca636', '#fcce25'],
      'inferno': ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c5c', '#cf4446', '#ed6925', '#f58b49', '#fdb42f', '#fce762'],
      'magma': ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c5c', '#cf4446', '#ed6925', '#f58b49', '#fdb42f', '#fce762'],
      'cividis': ['#00224f', '#123a5a', '#2d4f69', '#446475', '#5b7a7c', '#729083', '#8aa68a', '#a3bc93', '#bdd3a8', '#d8e5be'],
      'Blues': ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
      'Greens': ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
      'Reds': ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
      'Oranges': ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#e6550d', '#a63603', '#7f2704'],
      'Purples': ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
      
      // Diverging palettes
      'RdBu': ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
      'RdYlBu': ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
      'RdYlGn': ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
      'BrBG': ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
      'PiYG': ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
      'PRGn': ['#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
      'PuOr': ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
      'Spectral': ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
      
      // Qualitative palettes
      'Set1': ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
      'Set2': ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
      'Set3': ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
      'Paired': ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a6a6a', '#ffff99', '#b15928'],
      'Accent': ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
      'Dark2': ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
      'Pastel1': ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
      'Pastel2': ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
      'tab10': ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
      'tab20': ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'],
      'tab20b': ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'],
      'tab20c': ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9']
    };
    
    if (palettes[palette]) {
      const paletteColors = palettes[palette];
      if (count <= paletteColors.length) {
        let selectedColors = paletteColors.slice(0, count);
        // Aplicar inversão se solicitado
        if (invert) {
          selectedColors = selectedColors.reverse();
        }
        return selectedColors;
      } else {
        // Se precisar de mais cores que a paleta oferece, gerar cores únicas
        let uniqueColors = generateUniqueColors(count).map(color => {
          // Converter HSL para HEX
          const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
          if (match) {
            return hslToHex(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
          }
          return color;
        });
        
        // Aplicar inversão se solicitado
        if (invert) {
          uniqueColors = uniqueColors.reverse();
        }
        
        return uniqueColors;
      }
    }
    
    // Fallback para paletas não encontradas
    let fallbackColors = generateUniqueColors(count).map(color => {
      const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
      if (match) {
        return hslToHex(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
      }
      return color;
    });
    
    // Aplicar inversão se solicitado
    if (invert) {
      fallbackColors = fallbackColors.reverse();
    }
    
    return fallbackColors;
  }

  // Função para salvar configurações do usuário
  function saveUserConfig() {
    const config = {
      field: document.getElementById('field-select').value,
      styleType: document.getElementById('style-type').value,
      geomType: document.getElementById('geom-type').value,
      palette: document.getElementById('palette-select').value,
      paletteOpacity: document.getElementById('palette-opacity').value,
      paletteInvert: document.getElementById('palette-invert').checked,
      classes: document.getElementById('classes').value,
      method: document.getElementById('method').value,
      manualBreaks: document.getElementById('manual-breaks').value,
      strokeColor: document.getElementById('stroke-color').value,
      fillColor: document.getElementById('fill-color').value,
      strokeWeight: document.getElementById('stroke-weight').value,
      fillOpacity: document.getElementById('fill-opacity').value,
      pointRadius: document.getElementById('point-radius').value,
      lineOpacity: document.getElementById('line-opacity').value,
      lineDash: document.getElementById('line-dash').value,
      polygonBorderColor: document.getElementById('polygon-border-color').value,
      polygonBorderWidth: document.getElementById('polygon-border-width').value,
      polygonBorderToggle: document.getElementById('polygon-border-toggle').checked,
      labelField: document.getElementById('label-field-select').value,
      labelFont: document.getElementById('label-font').value,
      labelSize: document.getElementById('label-size').value,
      labelColor: document.getElementById('label-color').value,
      labelBold: document.getElementById('label-bold').checked,
      labelItalic: document.getElementById('label-italic').checked,
      labelBufferColor: document.getElementById('label-buffer-color').value,
      labelBufferSize: document.getElementById('label-buffer-size').value,
      labelBufferOpacity: document.getElementById('label-buffer-opacity').value,
      labelOffsetX: document.getElementById('label-offset-x').value,
      labelOffsetY: document.getElementById('label-offset-y').value,
      labelsEnabled: document.getElementById('labels-enabled').checked,
      timestamp: Date.now() // Adicionar timestamp
    };
    
    localStorage.setItem(`symbology_config_${layerId}`, JSON.stringify(config));
  }

  // Função para carregar configurações salvas do usuário
  function loadUserConfig() {
    try {
      const savedConfig = localStorage.getItem(`symbology_config_${layerId}`);
      if (savedConfig) {
        const config = JSON.parse(savedConfig);
        
        // Restaurar configurações básicas
        if (config.field) {
          document.getElementById('field-select').value = config.field;
        }
        if (config.styleType) {
          document.getElementById('style-type').value = config.styleType;
        }
        if (config.geomType) {
          document.getElementById('geom-type').value = config.geomType;
        }
        if (config.palette) {
          document.getElementById('palette-select').value = config.palette;
        }
        if (config.paletteOpacity) {
          document.getElementById('palette-opacity').value = config.paletteOpacity;
          document.getElementById('opacity-value').textContent = config.paletteOpacity;
        }
        if (config.paletteInvert !== undefined) {
          document.getElementById('palette-invert').checked = config.paletteInvert;
        }
        
        // Restaurar configurações de classes e método
        if (config.classes) {
          document.getElementById('classes').value = config.classes;
        }
        if (config.method) {
          document.getElementById('method').value = config.method;
        }
        if (config.manualBreaks) {
          document.getElementById('manual-breaks').value = config.manualBreaks;
        }
        
        // Restaurar configurações de cor personalizada
        if (config.strokeColor) {
          document.getElementById('stroke-color').value = config.strokeColor;
        }
        if (config.fillColor) {
          document.getElementById('fill-color').value = config.fillColor;
        }
        if (config.strokeWeight) {
          document.getElementById('stroke-weight').value = config.strokeWeight;
        }
        if (config.fillOpacity) {
          document.getElementById('fill-opacity').value = config.fillOpacity;
        }
        if (config.pointRadius) {
          document.getElementById('point-radius').value = config.pointRadius;
        }
        if (config.lineOpacity) {
          document.getElementById('line-opacity').value = config.lineOpacity;
        }
        if (config.lineDash) {
          document.getElementById('line-dash').value = config.lineDash;
        }
        
        // Restaurar configurações de polígono
        if (config.polygonBorderColor) {
          document.getElementById('polygon-border-color').value = config.polygonBorderColor;
        }
        if (config.polygonBorderWidth) {
          document.getElementById('polygon-border-width').value = config.polygonBorderWidth;
        }
        if (config.polygonBorderToggle !== undefined) {
          document.getElementById('polygon-border-toggle').checked = config.polygonBorderToggle;
        }
        
        // Restaurar configurações de rótulos
        if (config.labelField) {
          document.getElementById('label-field-select').value = config.labelField;
        }
        if (config.labelFont) {
          document.getElementById('label-font').value = config.labelFont;
        }
        if (config.labelSize) {
          document.getElementById('label-size').value = config.labelSize;
        }
        if (config.labelColor) {
          document.getElementById('label-color').value = config.labelColor;
        }
        if (config.labelBold !== undefined) {
          document.getElementById('label-bold').checked = config.labelBold;
        }
        if (config.labelItalic !== undefined) {
          document.getElementById('label-italic').checked = config.labelItalic;
        }
        if (config.labelBufferColor) {
          document.getElementById('label-buffer-color').value = config.labelBufferColor;
        }
        if (config.labelBufferSize) {
          document.getElementById('label-buffer-size').value = config.labelBufferSize;
        }
        if (config.labelBufferOpacity) {
          document.getElementById('label-buffer-opacity').value = config.labelBufferOpacity;
          document.getElementById('buffer-opacity-value').textContent = config.labelBufferOpacity;
        }
        if (config.labelOffsetX) {
          document.getElementById('label-offset-x').value = config.labelOffsetX;
        }
        if (config.labelOffsetY) {
          document.getElementById('label-offset-y').value = config.labelOffsetY;
        }
        if (config.labelsEnabled !== undefined) {
          document.getElementById('labels-enabled').checked = config.labelsEnabled;
        }
        
        return true;
      }
    } catch (error) {
      console.error('Erro ao carregar configurações salvas:', error);
    }
    return false;
  }

  // Função para limpar configurações antigas (mais de 30 dias)
  function clearOldConfigs() {
    const now = Date.now();
    const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
    
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('symbology_config_')) {
        try {
          const config = JSON.parse(localStorage.getItem(key));
          if (config.timestamp && config.timestamp < thirtyDaysAgo) {
            localStorage.removeItem(key);
          }
        } catch (e) {
          // Se não conseguir parsear, remove o item corrompido
          localStorage.removeItem(key);
        }
      }
    });
  }

  // Função para adicionar timestamp às configurações
  function addTimestampToConfig(config) {
    config.timestamp = Date.now();
    return config;
  }

  // Função para mostrar feedback visual de configurações carregadas
  function showConfigLoadedFeedback() {
    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'alert alert-info alert-dismissible fade show';
    feedbackDiv.innerHTML = `
      <i class="fas fa-info-circle"></i>
      <strong>Configurações restauradas!</strong> Suas últimas configurações foram carregadas automaticamente.
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    const container = document.querySelector('.container-fluid');
    container.insertBefore(feedbackDiv, container.firstChild);
    
    // Auto-remover após 5 segundos
    setTimeout(() => {
      if (feedbackDiv.parentNode) {
        feedbackDiv.remove();
      }
    }, 5000);
  }

  // Função para limpar configurações da camada atual
  function clearCurrentConfig() {
    if (confirm('Tem certeza que deseja limpar todas as configurações salvas para esta camada?')) {
      localStorage.removeItem(`symbology_config_${layerId}`);
      alert('Configurações salvas limpas com sucesso!');
      location.reload(); // Recarrega a página para mostrar que as configurações foram removidas
    }
  }

  // Função para inicializar o mapa
  function initMap() {
    // Inicializar mapa Leaflet
    map = L.map('symbology-map').setView([0, 0], 2);
    
    // Adicionar basemap padrão
    currentBasemap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);
    
    // Event listener para mudança de basemap
    document.getElementById('basemap-select').addEventListener('change', function() {
      const basemapType = this.value;
      
      // Remover basemap atual
      if (currentBasemap) {
        map.removeLayer(currentBasemap);
      }
      
      // Adicionar novo basemap
      switch (basemapType) {
        case 'osm':
          currentBasemap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
          }).addTo(map);
          break;
        case 'google-streets':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps'
          }).addTo(map);
          break;
        case 'google-satellite':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps'
          }).addTo(map);
          break;
        case 'google-hybrid':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps'
          }).addTo(map);
          break;
        case 'google-terrain':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps'
          }).addTo(map);
          break;
      }
    });
  }

  // Função para inicializar a página
  async function initializePage() {
    // Limpar configurações antigas
    clearOldConfigs();
    
    // Inicializar mapa
    initMap();
    
    // Carregar campos da camada
    await loadLayerFields();
    
    // Carregar dados da camada (que também restaura configurações)
    await loadLayerData();
    
    // Mostrar feedback se configurações foram carregadas
    if (localStorage.getItem(`symbology_config_${layerId}`)) {
      showConfigLoadedFeedback();
    }
  }

  // Função para aplicar visibilidade dos blocos
  function applyVisibility() {
    const styleType = document.getElementById('style-type').value;
    const geomType = document.getElementById('geom-type').value;
    
    // Blocos condicionais
    document.getElementById('block-classes').classList.toggle('d-none', !['graduated', 'raster'].includes(styleType));
    document.getElementById('block-method').classList.toggle('d-none', !['graduated'].includes(styleType));
    document.getElementById('block-manual').classList.toggle('d-none', !(styleType === 'graduated' && document.getElementById('method').value === 'manual'));
    document.getElementById('block-category-editor').classList.toggle('d-none', styleType !== 'categorized');
    document.getElementById('block-custom-color').classList.toggle('d-none', styleType !== 'single');
    document.getElementById('block-polygon-border').classList.toggle('d-none', geomType !== 'polygon');
    document.getElementById('block-point-only').classList.toggle('d-none', geomType !== 'point');
    document.getElementById('block-line-only').classList.toggle('d-none', geomType !== 'line');
    
    // Ocultar paleta de cores para símbolo único e mostrar cor personalizada
    document.getElementById('block-palette').classList.toggle('d-none', styleType === 'single');
  }

  // Função para detectar tipo de geometria da camada
  function detectGeometryType(layerData) {
    if (!layerData || !layerData.features || layerData.features.length === 0) {
      return 'polygon'; // padrão
    }
    
    const firstFeature = layerData.features[0];
    if (!firstFeature.geometry) {
      return 'polygon'; // padrão
    }
    
    const geomType = firstFeature.geometry.type;
    
    switch (geomType.toLowerCase()) {
      case 'point':
      case 'multipoint':
        return 'point';
      case 'linestring':
      case 'multilinestring':
        return 'line';
      case 'polygon':
      case 'multipolygon':
        return 'polygon';
      default:
        return 'polygon'; // padrão
    }
  }

  // Função para carregar campos da camada
  async function loadLayerFields() {
    try {
      const response = await fetch(`/admin/layer/${layerId}/fields`);
      const data = await response.json();
      
      const fieldSelect = document.getElementById('field-select');
      const labelFieldSelect = document.getElementById('label-field-select');
      
      fieldSelect.innerHTML = '<option value="">Selecione uma coluna...</option>';
      labelFieldSelect.innerHTML = '<option value="">Selecione uma coluna...</option>';
      
      data.fields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.name;
        option.textContent = `${field.name} (${field.dtype})`;
        fieldSelect.appendChild(option);
        
        const labelOption = document.createElement('option');
        labelOption.value = field.name;
        labelOption.textContent = `${field.name} (${field.dtype})`;
        labelFieldSelect.appendChild(labelOption);
      });
    } catch (error) {
      console.error('Erro ao carregar campos:', error);
    }
  }

  // Função para carregar categorias para um campo
  async function loadCategoriesForField(field) {
    try {
      const response = await fetch(`/admin/layer/${layerId}/classify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ field, mode: 'categorized' })
      });
      
      const data = await response.json();
      if (data.categories) {
        return data.categories;
      }
    } catch (error) {
      console.error('Erro ao carregar categorias:', error);
    }
    return [];
  }

  // Função para criar interface de cores por categoria
  function createCategoryColorInterface(categories) {
    const container = document.getElementById('category-list');
    container.innerHTML = '';
    
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    const colors = brewer(palette, categories.length, invert);
    
    categories.forEach((category, index) => {
      let color;
      
      if (index < colors.length) {
        // Usar cor da paleta se disponível
        color = colors[index];
      } else {
        // Gerar cor aleatória para classes excedentes
        const hue = Math.random() * 360;
        const saturation = 60 + Math.random() * 30; // 60-90%
        const lightness = 40 + Math.random() * 30;  // 40-70%
        color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      }
      
      const div = document.createElement('div');
      div.className = 'd-flex align-items-center gap-2 p-2 border rounded';
      div.innerHTML = `
        <div class="d-flex align-items-center gap-2">
          <input type="color" class="form-control form-control-color category-color" 
                 value="${color}" data-category="${category}" style="width: 40px;">
          <span class="badge bg-secondary">${category}</span>
        </div>
        <div class="d-flex gap-1">
          <button type="button" class="btn btn-outline-primary btn-sm category-hex-btn" 
                  data-category="${category}" title="Inserir cor HEX">
            <i class="fas fa-hashtag"></i> HEX
          </button>
          <button type="button" class="btn btn-outline-success btn-sm category-rgb-btn" 
                  data-category="${category}" title="Inserir cor RGB">
            <i class="fas fa-palette"></i> RGB
          </button>
        </div>
        <div class="flex-grow-1 d-none category-hex-input" data-category="${category}">
          <input type="text" class="form-control form-control-sm category-hex" 
                 placeholder="HEX (ex: #FF5733)" value="${color}" data-category="${category}">
        </div>
        <div class="flex-grow-1 d-none category-rgb-input" data-category="${category}">
          <input type="text" class="form-control form-control-sm category-rgb" 
                 placeholder="RGB (ex: 255,87,51)" data-category="${category}">
        </div>
      `;
      
      // Event listeners para mudanças de cor
      const colorInput = div.querySelector('.category-color');
      const hexBtn = div.querySelector('.category-hex-btn');
      const rgbBtn = div.querySelector('.category-rgb-btn');
      const hexInputContainer = div.querySelector('.category-hex-input');
      const rgbInputContainer = div.querySelector('.category-rgb-input');
      const hexInput = div.querySelector('.category-hex');
      const rgbInput = div.querySelector('.category-rgb');
      
      // Toggle dos campos de entrada - apenas um por vez
      hexBtn.addEventListener('click', function() {
        // Fechar campo RGB se estiver aberto
        rgbInputContainer.classList.add('d-none');
        // Toggle campo HEX
        hexInputContainer.classList.toggle('d-none');
        if (!hexInputContainer.classList.contains('d-none')) {
          hexInput.focus();
        }
      });
      
      rgbBtn.addEventListener('click', function() {
        // Fechar campo HEX se estiver aberto
        hexInputContainer.classList.add('d-none');
        // Toggle campo RGB
        rgbInputContainer.classList.toggle('d-none');
        if (!rgbInputContainer.classList.contains('d-none')) {
          rgbInput.focus();
        }
      });
      
      colorInput.addEventListener('change', (e) => {
        hexInput.value = e.target.value;
        refreshPreview();
        saveUserConfig();
      });
      
      hexInput.addEventListener('input', (e) => {
        if (e.target.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          colorInput.value = e.target.value;
          refreshPreview();
          saveUserConfig();
        }
      });
      
      rgbInput.addEventListener('input', (e) => {
        const rgb = e.target.value.match(/^(\d+),\s*(\d+),\s*(\d+)$/);
        if (rgb) {
          const hex = '#' + [parseInt(rgb[1]), parseInt(rgb[2]), parseInt(rgb[3])]
            .map(x => x.toString(16).padStart(2, '0')).join('');
          colorInput.value = hex;
          hexInput.value = hex;
          refreshPreview();
          saveUserConfig();
        }
      });
      
      container.appendChild(div);
    });
  }

  // Função para atualizar cores da paleta visual
  function updatePaletteVisualColors() {
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    
    // Atualizar cores na visualização da paleta
    document.querySelectorAll('.palette-item').forEach(paletteItem => {
      const paletteName = paletteItem.dataset.palette;
      if (paletteName === palette) {
        const colors = brewer(paletteName, 5, invert);
        const colorDivs = paletteItem.querySelectorAll('div[style*="background-color"]');
        colors.forEach((color, index) => {
          if (colorDivs[index]) {
            colorDivs[index].style.backgroundColor = color;
          }
        });
      }
    });
  }

  // Função para computar o estilo baseado nas seleções
  function computeStyle() {
    const styleType = document.getElementById('style-type').value;
    const geomType = document.getElementById('geom-type').value;
    const field = document.getElementById('field-select').value;
    const palette = document.getElementById('palette-select').value;
    const paletteOpacity = parseFloat(document.getElementById('palette-opacity').value);
    const paletteInvert = document.getElementById('palette-invert').checked;
    
    const style = {
      type: styleType,
      geometry_type: geomType,
      field: field,
      palette: palette,
      palette_opacity: paletteOpacity,
      palette_invert: paletteInvert
    };
    
    if (styleType === 'single') {
      style.stroke_color = document.getElementById('stroke-color').value;
      style.fill_color = document.getElementById('fill-color').value;
      style.stroke_weight = parseInt(document.getElementById('stroke-weight').value);
      style.fill_opacity = parseFloat(document.getElementById('fill-opacity').value);
      
      if (geomType === 'point') {
        style.radius = parseInt(document.getElementById('point-radius').value);
      } else if (geomType === 'line') {
        style.opacity = parseFloat(document.getElementById('line-opacity').value);
        const dash = document.getElementById('line-dash').value;
        if (dash) style.dashArray = dash;
      }
    } else if (styleType === 'categorized') {
      const categories = Array.from(document.querySelectorAll('.category-color')).map(input => ({
        category: input.dataset.category,
        color: input.value
      }));
      style.categories = categories;
      
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      }
    } else if (styleType === 'graduated') {
      const classes = parseInt(document.getElementById('classes').value);
      const method = document.getElementById('method').value;
      style.classes = classes;
      
      // Debug: verificar valores coletados
      console.log('Valores coletados para simbologia graduada:', {
        classes: classes,
        method: method,
        field: style.field,
        palette: style.palette
      });
      
      // Mapear valores do dropdown para os valores esperados pela função
      if (method === 'equal') style.method = 'equal';
      else if (method === 'quantiles') style.method = 'quantile';
      else if (method === 'jenks') style.method = 'jenks';
      else if (method === 'log') style.method = 'log';
      else if (method === 'manual') style.method = 'manual';
      else style.method = 'equal'; // Padrão
      
      if (method === 'manual') {
        const breaks = document.getElementById('manual-breaks').value;
        if (breaks) {
          style.breaks = breaks.split(',').map(b => parseFloat(b.trim()));
        }
      }
      
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      }
      
      // Debug: verificar estilo final
      console.log('Estilo graduado final:', style);
    }
    
    return style;
  }

  // Função para renderizar preview da legenda
  function renderPreview() {
    console.log('renderPreview chamada');
    const style = computeStyle();
    console.log('Estilo computado:', style);
    const legendDiv = document.getElementById('preview-legend');
    
    if (style.type === 'single') {
      legendDiv.innerHTML = `
        <div class="d-flex align-items-center gap-2 p-2 border rounded">
          <div style="width: 20px; height: 20px; background-color: ${style.fill_color}; border: 2px solid ${style.stroke_color};"></div>
          <span>${style.field || 'Símbolo único'}</span>
        </div>
      `;
    } else if (style.type === 'categorized' && style.categories) {
      legendDiv.innerHTML = style.categories.map(cat => `
        <div class="d-flex align-items-center gap-2 p-2 border rounded mb-1">
          <div style="width: 20px; height: 20px; background-color: ${cat.color};"></div>
          <span>${cat.category}</span>
        </div>
      `).join('');
    } else if (style.type === 'graduated') {
      // Para dados vetoriais graduados, mostrar legenda discreta
      if (style.geometry_type !== 'raster') {
        // Gerar cores da paleta para a legenda discreta
        const palette = style.palette || 'Blues';
        const classes = style.classes || 5;
        const colors = brewer(palette, classes, style.palette_invert);
        
        // Criar legenda discreta com cada classe individual
        const legendItems = colors.map((color, index) => `
          <div class="d-flex align-items-center gap-2 p-2 border rounded mb-1">
            <div style="width: 20px; height: 20px; background-color: ${color}; border: 1px solid #ccc;"></div>
            <span>Classe ${index + 1}</span>
          </div>
        `).join('');
        
        legendDiv.innerHTML = `
          <div class="mb-2">
            <div><strong>${style.field}</strong></div>
            <div class="small text-muted">Método: ${style.method}</div>
            <div class="small text-muted">Paleta: ${palette}</div>
            <div class="small text-muted">${classes} classes</div>
            <div class="small text-muted">Tipo: Vetorial (discreto)</div>
          </div>
          ${legendItems}
        `;
      } else {
        // Para dados raster, manter legenda contínua
        const palette = style.palette || 'Blues';
        const classes = style.classes || 5;
        const colors = brewer(palette, classes, style.palette_invert);
        
        // Criar gradiente visual para a legenda
        const gradientColors = colors.map(color => color).join(', ');
        
        legendDiv.innerHTML = `
          <div class="d-flex align-items-center gap-2 p-2 border rounded">
            <div class="d-flex flex-column">
              <div style="width: 20px; height: 60px; background: linear-gradient(to bottom, ${gradientColors}); border: 1px solid #ccc;"></div>
              <small class="text-muted text-center">${classes} classes</small>
            </div>
            <div class="flex-grow-1">
              <div><strong>${style.field}</strong></div>
              <div class="small text-muted">Método: ${style.method}</div>
              <div class="small text-muted">Paleta: ${palette}</div>
              <div class="small text-muted">Tipo: Raster (contínuo)</div>
            </div>
          </div>
        `;
      }
    }
  }

  // Função para renderizar rótulos no mapa
  function renderLabelsOnMap() {
    if (!layerData || !map) return;
    
    // Remover rótulos existentes
    map.eachLayer(layer => {
      if (layer._labelLayer) {
        map.removeLayer(layer);
      }
    });
    
    const labelsEnabled = document.getElementById('labels-enabled').checked;
    if (!labelsEnabled) return;
    
    const labelField = document.getElementById('label-field-select').value;
    if (!labelField) return;
    
    const labelConfig = {
      font: document.getElementById('label-font').value,
      size: parseInt(document.getElementById('label-size').value),
      color: document.getElementById('label-color').value,
      bold: document.getElementById('label-bold').checked,
      italic: document.getElementById('label-italic').checked,
      bufferColor: document.getElementById('label-buffer-color').value,
      bufferSize: parseInt(document.getElementById('label-buffer-size').value),
      bufferOpacity: parseFloat(document.getElementById('label-buffer-opacity').value),
      offsetX: parseInt(document.getElementById('label-offset-x').value),
      offsetY: parseInt(document.getElementById('label-offset-y').value)
    };
    
    // Criar camada de rótulos
    const labelLayer = L.layerGroup();
    labelLayer._labelLayer = true;
    
    layerData.features.forEach(feature => {
      if (feature.geometry && feature.properties[labelField]) {
        const labelText = feature.properties[labelField].toString();
        
        // Calcular posição do rótulo baseado na geometria
        let labelPosition;
        if (feature.geometry.type === 'Point') {
          labelPosition = feature.geometry.coordinates;
        } else if (feature.geometry.type === 'LineString') {
          // Posição no meio da linha
          const coords = feature.geometry.coordinates;
          const midIndex = Math.floor(coords.length / 2);
          labelPosition = coords[midIndex];
        } else if (feature.geometry.type === 'Polygon') {
          // Centro do polígono
          const coords = feature.geometry.coordinates[0];
          let sumX = 0, sumY = 0;
          coords.forEach(coord => {
            sumX += coord[0];
            sumY += coord[1];
          });
          labelPosition = [sumX / coords.length, sumY / coords.length];
        }
        
        if (labelPosition) {
          // Converter coordenadas para lat/lng
          const latLng = L.latLng(labelPosition[1], labelPosition[0]);
          
          // Criar elemento HTML para o rótulo
          const labelDiv = document.createElement('div');
          labelDiv.innerHTML = labelText;
          labelDiv.style.cssText = `
            font-family: ${labelConfig.font}, sans-serif;
            font-size: ${labelConfig.size}px;
            color: ${labelConfig.color};
            font-weight: ${labelConfig.bold ? 'bold' : 'normal'};
            font-style: ${labelConfig.italic ? 'italic' : 'normal'};
            text-shadow: 
              -1px -1px 0 ${labelConfig.bufferColor},
              -1px 1px 0 ${labelConfig.bufferColor},
              1px -1px 0 ${labelConfig.bufferColor},
              1px 1px 0 ${labelConfig.bufferColor};
            text-shadow: 
              -1px -1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              -1px 1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              1px -1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              1px 1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor};
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
          `;
          
          // Criar marcador de rótulo
          const labelMarker = L.marker(latLng, {
            icon: L.divIcon({
              html: labelDiv,
              className: 'label-icon',
              iconSize: [labelDiv.offsetWidth, labelDiv.offsetHeight],
              iconAnchor: [labelDiv.offsetWidth / 2, labelDiv.offsetHeight / 2]
            })
          });
          
          // Aplicar deslocamento
          if (labelConfig.offsetX !== 0 || labelConfig.offsetY !== 0) {
            labelMarker.setLatLng([
              latLng.lat + (labelConfig.offsetY / 1000),
              latLng.lng + (labelConfig.offsetX / 1000)
            ]);
          }
          
          labelLayer.addLayer(labelMarker);
        }
      }
    });
    
    labelLayer.addTo(map);
  }

  // Função para renderizar preview no mapa
  function renderMapPreview() {
    console.log('renderMapPreview chamada');
    if (!currentLayer || !map) {
      console.log('renderMapPreview: currentLayer ou map não disponível');
      return;
    }
    
    // Remover camada anterior se existir
    if (map.hasLayer(currentLayer)) {
      map.removeLayer(currentLayer);
    }
    
    const style = computeStyle();
    
    // Aplicar estilo baseado no tipo
    if (style.type === 'single') {
      currentLayer.setStyle({
        color: style.stroke_color,
        weight: style.stroke_weight,
        fillColor: style.fill_color,
        fillOpacity: style.fill_opacity
      });
      
      if (style.geometry_type === 'point') {
        currentLayer.eachLayer(layer => {
          if (layer.setRadius) {
            layer.setRadius(style.radius);
          }
        });
      } else if (style.geometry_type === 'line') {
        currentLayer.eachLayer(layer => {
          if (style.opacity !== undefined) {
            layer.setStyle({ opacity: style.opacity });
          }
          if (style.dashArray) {
            layer.setStyle({ dashArray: style.dashArray });
          }
        });
      }
    } else if (style.type === 'categorized' && style.categories) {
      // Aplicar estilo categorizado
      currentLayer.eachLayer(layer => {
        if (layer.feature && layer.feature.properties && style.field) {
          const value = layer.feature.properties[style.field];
          const category = style.categories.find(cat => cat.category == value);
          if (category) {
            layer.setStyle({
              color: style.border_color || '#333333',
              weight: style.border_width || 1,
              fillColor: category.color,
              fillOpacity: style.palette_opacity || 0.6
            });
          }
        }
      });
    } else if (style.type === 'graduated') {
      // Aplicar estilo graduado
      console.log('renderMapPreview: Aplicando estilo graduado:', style);
      if (style.field && style.classes && style.method) {
        console.log('Aplicando estilo graduado:', style);
        applyGraduatedStyle(currentLayer, style);
      } else {
        console.log('Dados insuficientes para estilo graduado:', {
          field: style.field,
          classes: style.classes,
          method: style.method
        });
      }
    }
    
    // Adicionar camada ao mapa se não estiver presente
    if (!map.hasLayer(currentLayer)) {
      console.log('renderMapPreview: Adicionando camada ao mapa');
      currentLayer.addTo(map);
    }
    
    // Renderizar rótulos se habilitados
    renderLabelsOnMap();
    
    console.log('renderMapPreview concluída');
  }

  // Função para atualizar preview
  function refreshPreview() {
    console.log('refreshPreview chamada');
    renderPreview();
    renderMapPreview(); // Isso agora inclui renderização de rótulos
    updatePaletteVisualColors();
  }

  // Função para carregar dados da camada
  async function loadLayerData() {
    try {
      // Usar a URL correta para carregar os dados da camada
      const response = await fetch(`/portal/amplo/api/camada_data/${layerId}`);
      layerData = await response.json();
      
      if (map && layerData.features && layerData.features.length > 0) {
        // Remover camada anterior se existir
        if (currentLayer) {
          map.removeLayer(currentLayer);
        }
        
        currentLayer = L.geoJSON(layerData, {
          style: {
            color: '#333333',
            weight: 2,
            fillColor: '#38bdf8',
            fillOpacity: 0.6
          },
          onEachFeature: function(feature, layer) {
            layer.bindPopup(`
              <strong>${feature.properties[Object.keys(feature.properties)[0]] || 'Sem nome'}</strong><br>
              ${Object.entries(feature.properties).map(([key, value]) => `${key}: ${value}`).join('<br>')}
            `);
          }
        }).addTo(map);
        
        map.fitBounds(currentLayer.getBounds());
        
        // Detectar e preselecionar tipo de geometria
        const detectedType = detectGeometryType(layerData);
        document.getElementById('geom-type').value = detectedType;
        
        // Aplicar visibilidade baseada no tipo detectado
        applyVisibility();
        
        // Restaurar configurações salvas do usuário
        const configRestored = loadUserConfig();
        
        // Se configurações foram restauradas, aplicar visibilidade novamente
        if (configRestored) {
          applyVisibility();
          
          // Se tiver campo selecionado e for categorizada, carregar categorias
          const field = document.getElementById('field-select').value;
          const styleType = document.getElementById('style-type').value;
          if (field && styleType === 'categorized') {
            loadCategoriesForField(field).then(categories => {
              createCategoryColorInterface(categories);
              refreshPreview();
            });
          }
        }
        
        refreshPreview();
      }
    } catch (error) {
      console.error('Erro ao carregar dados da camada:', error);
    }
  }

  // Inicialização da página
  document.addEventListener('DOMContentLoaded', function() {
    // Carregar campos e dados
    initializePage();
    
    // Event listeners para mudanças
    document.getElementById('style-type').addEventListener('change', function() {
      applyVisibility();
      saveUserConfig(); // Salvar configuração automaticamente
    });
    document.getElementById('geom-type').addEventListener('change', function() {
      applyVisibility();
      saveUserConfig(); // Salvar configuração automaticamente
    });
    document.getElementById('method').addEventListener('change', function() {
      applyVisibility();
      saveUserConfig(); // Salvar configuração automaticamente
    });
    
    // Event listener para seleção de campo
    document.getElementById('field-select').addEventListener('change', async function() {
      const field = this.value;
      if (field && document.getElementById('style-type').value === 'categorized') {
        const categories = await loadCategoriesForField(field);
        createCategoryColorInterface(categories);
        refreshPreview();
      }
      saveUserConfig(); // Salvar configuração automaticamente
    });
    
    document.getElementById('palette-select').addEventListener('change', function() {
      createCategoryColorInterface([]);
      refreshPreview();
      saveUserConfig();
    });
    
    document.getElementById('palette-opacity').addEventListener('input', function() {
      refreshPreview();
      saveUserConfig();
    });
    
    document.getElementById('palette-invert').addEventListener('change', function() {
      createCategoryColorInterface([]);
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listeners para simbologia graduada
    document.getElementById('classes').addEventListener('change', function() {
      refreshPreview();
      saveUserConfig();
    });
    
    document.getElementById('method').addEventListener('change', function() {
      applyVisibility();
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listener para breaks manuais
    document.getElementById('manual-breaks').addEventListener('input', function() {
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listeners para campos personalizados
    ['stroke-color', 'fill-color', 'stroke-weight', 'fill-opacity', 'point-radius', 'line-opacity', 'line-dash'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de polígono
    ['polygon-border-color', 'polygon-border-width', 'polygon-border-toggle'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de classificação
    ['classes', 'manual-breaks'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', function() {
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de rótulos
    ['labels-enabled', 'label-field-select', 'label-font', 'label-size', 'label-color', 'label-bold', 'label-italic', 'label-buffer-color', 'label-buffer-size', 'label-buffer-opacity', 'label-offset-x', 'label-offset-y'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listener específico para o slider de opacidade do buffer
    document.getElementById('label-buffer-opacity').addEventListener('input', function() {
      document.getElementById('buffer-opacity-value').textContent = this.value;
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listener para botão de aplicar simbologia
    document.getElementById('btn-apply').addEventListener('click', async function() {
      const style = computeStyle();
      
      if (!style.field) {
        alert('Por favor, selecione um campo para simbologia.');
        return;
      }
      
      try {
        // Salvar configurações do usuário antes de aplicar
        saveUserConfig();
        
        const response = await fetch(`/admin/layer/${layerId}/symbology/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(style)
        });
        
        if (response.ok) {
          alert('Simbologia aplicada com sucesso! A camada agora está disponível no Portal e Mapa Público.');
        } else {
          const error = await response.json();
          alert(`Erro ao aplicar simbologia: ${error.error || 'Erro desconhecido'}`);
        }
      } catch (error) {
        console.error('Erro ao aplicar simbologia:', error);
        alert('Erro ao aplicar simbologia. Verifique o console para mais detalhes.');
      }
    });

    // Event listener para botão de aplicar rótulos
    document.getElementById('btn-apply-labels').addEventListener('click', async function() {
      const labelConfig = {
        field: document.getElementById('label-field-select').value,
        font: document.getElementById('label-font').value,
        size: parseInt(document.getElementById('label-size').value),
        color: document.getElementById('label-color').value,
        bold: document.getElementById('label-bold').checked,
        italic: document.getElementById('label-italic').checked,
        bufferColor: document.getElementById('label-buffer-color').value,
        bufferSize: parseInt(document.getElementById('label-buffer-size').value),
        bufferOpacity: parseFloat(document.getElementById('label-buffer-opacity').value),
        offsetX: parseInt(document.getElementById('label-offset-x').value),
        offsetY: parseInt(document.getElementById('label-offset-y').value),
        enabled: document.getElementById('labels-enabled').checked
      };

      if (!labelConfig.field) {
        alert('Por favor, selecione um campo para rótulos.');
        return;
      }

      try {
        saveUserConfig(); // Salvar configurações gerais

        const response = await fetch(`/admin/layer/${layerId}/labels/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(labelConfig)
        });

        if (response.ok) {
          alert('Configurações de rótulos aplicadas com sucesso!');
          refreshPreview(); // Atualizar preview com novas configurações de rótulos
        } else {
          const error = await response.json();
          alert(`Erro ao aplicar configurações de rótulos: ${error.error || 'Erro desconhecido'}`);
        }
      } catch (error) {
        console.error('Erro ao aplicar configurações de rótulos:', error);
        alert('Erro ao aplicar configurações de rótulos. Verifique o console para mais detalhes.');
      }
    });
    
    // Criar grid de paletas
    const paletteGrid = document.getElementById('palette-grid');
    Object.entries(colorBrewer).forEach(([category, palettes]) => {
      const categoryDiv = document.createElement('div');
      categoryDiv.className = 'mb-2';
      categoryDiv.innerHTML = `<small class="text-muted d-block mb-1">${category.charAt(0).toUpperCase() + category.slice(1)}</small>`;
      
      palettes.forEach(palette => {
        const paletteDiv = document.createElement('div');
        paletteDiv.className = 'd-inline-block me-2 mb-1';
        paletteDiv.innerHTML = `
          <div class="palette-item" data-palette="${palette}" style="cursor: pointer; border: 2px solid transparent; padding: 2px; border-radius: 4px;">
            <div class="d-flex">
              ${brewer(palette, 5, false).map(color => 
                `<div style="width: 20px; height: 20px; background-color: ${color}; border: 1px solid #ccc;"></div>`
              ).join('')}
            </div>
            <small class="d-block text-center">${palette}</small>
          </div>
        `;
        
        paletteDiv.querySelector('.palette-item').addEventListener('click', function() {
          document.getElementById('palette-select').value = palette;
          document.querySelectorAll('.palette-item').forEach(item => item.style.borderColor = 'transparent');
          this.style.borderColor = '#007bff';
          
          // Se for categorizada, recriar interface de cores
          if (document.getElementById('style-type').value === 'categorized') {
            const field = document.getElementById('field-select').value;
            if (field) {
              loadCategoriesForField(field).then(categories => {
                createCategoryColorInterface(categories);
                refreshPreview();
              });
            }
          } else {
            refreshPreview();
          }
        });
        
        categoryDiv.appendChild(paletteDiv);
      });
      
      paletteGrid.appendChild(categoryDiv);
    });
    
    // Selecionar primeira paleta por padrão
    const firstPalette = document.querySelector('.palette-item');
    if (firstPalette) {
      firstPalette.style.borderColor = '#007bff';
    }
  });

  // Função para aplicar estilo graduado
  function applyGraduatedStyle(layer, style) {
    if (!layerData || !style.field) return;
    
    // Coletar valores do campo selecionado
    const values = layerData.features
      .map(f => parseFloat(f.properties[style.field]))
      .filter(v => !isNaN(v))
      .sort((a, b) => a - b);
    
    if (values.length === 0) return;
    
    const min = values[0];
    const max = values[values.length - 1];
    const classes = style.classes || 5;
    
    // Gerar breaks baseado no método
    let breaks = [];
    if (style.method === 'equal') {
      // Equal Interval
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    } else if (style.method === 'quantile') {
      // Quantiles
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'jenks') {
      // Jenks Natural Breaks (simplificado)
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'log') {
      // Logarithmic
      const logMin = Math.log(Math.max(min, 0.1));
      const logMax = Math.log(max);
      const step = (logMax - logMin) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(Math.exp(logMin + (i * step)));
      }
    } else if (style.method === 'manual' && style.breaks) {
      breaks = style.breaks;
    }
    
    // Gerar cores da paleta
    const palette = style.palette || 'Blues';
    const colors = brewer(palette, classes, style.palette_invert);
    
    // Aplicar estilo a cada feature
    layer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.properties) {
        const value = parseFloat(featureLayer.feature.properties[style.field]);
        if (isNaN(value)) return;
        
        // Encontrar classe para o valor
        let colorIndex = 0;
        for (let i = 0; i < breaks.length - 1; i++) {
          if (value >= breaks[i] && value < breaks[i + 1]) {
            colorIndex = i;
            break;
          }
        }
        
        // Aplicar cor
        const color = colors[colorIndex] || colors[0];
        featureLayer.setStyle({
          fillColor: color,
          fillOpacity: style.palette_opacity || 0.6,
          color: style.border_color || '#333333',
          weight: style.border_width || 1
        });
      }
    });
    
    // Log de execução da função
    console.log('applyGraduatedStyle executada com sucesso');
  }
</script>
{% endblock %}