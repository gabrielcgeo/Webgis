{% extends 'layout.html' %}
{% block content %}
<!-- Adicionar dados da empresa para JavaScript -->
<div id="company-data" data-company-slug="{{ current_user.company.slug if current_user.company else 'amplo' }}" style="display: none;"></div>

<style>
  #symbology-map {
    height: 50vh !important;
    min-height: 400px !important;
    width: 100% !important;
    z-index: 1;
    position: relative;
  }
  
  .leaflet-container {
    height: 100% !important;
    width: 100% !important;
  }
  
  .leaflet-control-attribution {
    font-size: 10px;
  }
  
  #palette-colors {
    flex-wrap: wrap;
  }
  
  #palette-colors div {
    margin-bottom: 5px;
  }
  
  .palette-preview-container {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 15px;
    margin-bottom: 15px;
  }
  
  /* Caixa explicativa compacta e horizontal - sempre visível */
  .method-info-compact {
    display: flex;
    align-items: flex-start;
    gap: 15px;
    padding: 16px 20px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e3f2fd 100%);
    border: 1px solid #0dcaf0;
    border-left: 4px solid #0dcaf0;
    border-radius: 8px;
    margin-top: 15px;
    margin-bottom: 20px;
    margin-left: 0;
    margin-right: 0;
    font-size: 0.8rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    width: 100%; /* Ocupa toda a largura da coluna col-md-12 */
    max-width: 100%;
    position: relative;
    left: 0;
    grid-column: 1 / -1; /* Estende por todas as colunas do grid */
    z-index: 10; /* Garante que fique acima de outros elementos */
    box-sizing: border-box; /* Inclui padding e border na largura total */
  }
  
  .method-info-compact .method-icon {
    font-size: 1rem;
    color: #0dcaf0;
    flex-shrink: 0;
  }
  
  .method-info-compact .method-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(13, 202, 240, 0.2);
  }
  
  .method-info-compact .method-title-section {
    flex: 1;
  }
  
  .method-info-compact .method-title {
    font-weight: 700;
    color: #0c63e4;
    margin-bottom: 4px;
    font-size: 1rem;
    letter-spacing: 0.5px;
  }
  
  .method-info-compact .method-description {
    color: #495057;
    line-height: 1.4;
    font-size: 0.85rem;
    font-style: italic;
  }
  
  .method-info-compact .method-content-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    width: 100%;
  }
  
  .method-info-compact .method-detail-card {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 6px;
    padding: 12px;
    border: 1px solid rgba(13, 202, 240, 0.15);
    transition: all 0.2s ease;
  }
  
  .method-info-compact .method-detail-card:hover {
    background: rgba(255, 255, 255, 0.9);
    border-color: rgba(13, 202, 240, 0.3);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  
  .method-info-compact .detail-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  
  .method-info-compact .detail-icon {
    font-size: 1rem;
    flex-shrink: 0;
  }
  
  .method-info-compact .detail-label {
    font-weight: 600;
    color: #0c63e4;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .method-info-compact .detail-text {
    color: #495057;
    font-size: 0.75rem;
    line-height: 1.4;
  }
  
  /* Ajuste para responsividade - comporta-se como col-md-12 */
  @media (max-width: 1200px) {
    .method-info-compact {
      margin-left: 0;
      margin-right: 0;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }
  }
  
  @media (max-width: 768px) {
    .method-info-compact {
      margin-left: 0;
      margin-right: 0;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }
  }
  
  /* Garante que a caixa se comporte exatamente como uma col-md-12 */
  .method-info-compact {
    flex: 0 0 100%;
    flex-basis: 100%;
    margin-left: 0;
    margin-right: 0;
  }
</style>
<h2>Simbologia: {{ layer.name }}</h2>
<div class="row">
  <div class="col-lg-6">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">Configurações de Simbologia</h5>
      </div>
      <div class="card-body">
        <!-- Abas para organizar simbologia e rótulos -->
        <ul class="nav nav-tabs" id="symbologyTabs" role="tablist">
          <li class="nav-item" role="presentation">
            <button class="nav-link active" id="symbology-tab" data-bs-toggle="tab" data-bs-target="#symbology-content" type="button" role="tab">
              <i class="fas fa-palette"></i> Simbologia
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="labels-tab" data-bs-toggle="tab" data-bs-target="#labels-content" type="button" role="tab">
              <i class="fas fa-font"></i> Rótulos
            </button>
          </li>
        </ul>
        
        <div class="tab-content mt-3" id="symbologyTabsContent">
          <!-- Aba de Simbologia -->
          <div class="tab-pane fade show active" id="symbology-content" role="tabpanel">
            <div class="row g-3">
              <div class="col-md-6">
                <label class="form-label">Tipo de Geometria</label>
                <select id="geom-type" class="form-select">
                  <option value="point">Ponto</option>
                  <option value="line">Linha</option>
                  <option value="polygon">Polígono</option>
                  <option value="raster">Raster</option>
                </select>
              </div>
              <div class="col-md-6">
                <label class="form-label">Campo para Simbologia</label>
                <select id="field-select" class="form-select">
                  <option value="">Selecione uma coluna...</option>
                </select>
              </div>
              <div class="col-md-12">
                <label for="style-type" class="form-label">Tipo de Simbologia</label>
                <select class="form-select" id="style-type">
                  <option value="single">Símbolo Único</option>
                  <option value="categorized">Categorizada</option>
                  <option value="graduated">Graduada</option>
                  <option value="raster">Raster</option>
                </select>
              </div>
              
              <!-- Blocos condicionais de simbologia -->
              <div class="col-md-4 d-none" id="block-classes">
                <label class="form-label">Número de classes</label>
                <input id="classes" type="number" class="form-control" min="2" max="20" value="5">
              </div>
              <div class="col-md-4 d-none" id="block-method">
                <label class="form-label">Método de Classificação</label>
                <select id="method" class="form-select">
                  <option value="equal">Intervalos Iguais</option>
                  <option value="quantiles">Quantis (Equal Count)</option>
                  <option value="jenks">Quebras Naturais (Jenks)</option>
                  <option value="log">Logarítmica</option>
                  <option value="stddev">Desvio Padrão</option>
                  <option value="arithmetic">Progressão Aritmética</option>
                  <option value="geometric">Progressão Geométrica</option>
                  <option value="manual">Manual</option>
                </select>
              </div>
              <div class="col-md-12 d-none" id="block-manual">
                <label class="form-label">Intervalos (separados por vírgula)</label>
                <input id="manual-breaks" class="form-control" placeholder="ex.: 0, 10, 25, 50, 100">
              </div>
              
              <!-- Caixa explicativa independente - sempre visível acima da paleta -->
              <div id="method-info" class="method-info-compact">
                <!-- As informações aparecerão aqui dinamicamente -->
              </div>
              
              <!-- Paleta de cores -->
              <div class="col-md-12" id="block-palette">
                <label class="form-label">Paleta de Cores</label>
                <small class="text-muted d-block mb-2">
                  <i class="fas fa-info-circle"></i> 
                  <strong>Distribuição Otimizada:</strong> A primeira classe sempre recebe a primeira cor da paleta, 
                  a última classe sempre recebe a última cor, e as classes intermediárias são distribuídas uniformemente 
                  entre os extremos para máxima variação visual.
                </small>
                <select id="palette-select" class="form-select mb-3">
                  <optgroup label="Sequencial (Dados Quantitativos Ordenados)">
                    <option value="Viridis" data-palette="Viridis">Viridis - Científica Moderna</option>
                    <option value="Cividis" data-palette="Cividis">Cividis - Daltonismo Seguro</option>
                    <option value="Blues" data-palette="Blues">Blues - Água/Precipitação</option>
                    <option value="Greens" data-palette="Greens">Greens - Vegetação/Agricultura</option>
                    <option value="YlOrRd" data-palette="YlOrRd">YlOrRd - Calor/Densidade</option>
                    <option value="Purples" data-palette="Purples">Purples - Magnitude</option>
                    <option value="Greys" data-palette="Greys">Greys - Mapa Base</option>
                  </optgroup>
                  <optgroup label="Divergente (Dados com Ponto Central)">
                    <option value="RdYlBu" data-palette="RdYlBu">RdYlBu - Anomalias (Seguro)</option>
                    <option value="RdYlGn" data-palette="RdYlGn">RdYlGn - Clássica</option>
                    <option value="BrBG" data-palette="BrBG">BrBG - Vegetação vs Solo</option>
                    <option value="PiYG" data-palette="PiYG">PiYG - Alternativa Verde</option>
                    <option value="Coolwarm" data-palette="Coolwarm">Coolwarm - Azul-Vermelho</option>
                    <option value="Spectral" data-palette="Spectral">Spectral - Topografia</option>
                  </optgroup>
                  <optgroup label="Qualitativo (Dados Categóricos)">
                    <option value="Vivid (Início Verde)" data-palette="Vivid (Início Verde)">Vivid (Início Verde) - Personalizada</option>
                    <option value="Vivid (Início Azul)" data-palette="Vivid (Início Azul)">Vivid (Início Azul) - Personalizada</option>
                    <option value="Tableau Tab10" data-palette="Tableau Tab10">Tableau Tab10 - Moderna</option>
                    <option value="ColorBrewer Paired" data-palette="ColorBrewer Paired">ColorBrewer Paired - Pares</option>
                    <option value="ColorBrewer Set3" data-palette="ColorBrewer Set3">ColorBrewer Set3 - Suave</option>
                  </optgroup>
                  <optgroup label="Personalizadas" id="custom-palettes-group">
                    <!-- Paletas personalizadas serão adicionadas aqui dinamicamente -->
                  </optgroup>
                </select>
                
                <!-- Controles para paletas personalizadas -->
                <div class="d-flex gap-2 mb-3">
                  <button type="button" id="btn-create-palette" class="btn btn-outline-primary btn-sm">
                    <i class="fas fa-plus"></i> Criar Nova Paleta
                  </button>
                  <button type="button" id="btn-save-current-palette" class="btn btn-outline-success btn-sm">
                    <i class="fas fa-save"></i> Salvar Paleta Atual
                  </button>
                  <button type="button" id="btn-manage-palettes" class="btn btn-outline-info btn-sm">
                    <i class="fas fa-cog"></i> Gerenciar Paletas
                  </button>
                </div>
                
                <!-- Visualização da paleta selecionada com nome -->
                <div id="palette-preview" class="palette-preview-container">
                  <div class="d-flex align-items-center gap-2 mb-2">
                    <label class="form-label mb-0 fw-bold">Paleta Selecionada:</label>
                    <span id="palette-name" class="badge bg-primary fs-6"></span>
                  </div>
                  <div class="mb-2">
                    <small class="text-muted">Clique nas cores para copiar o valor HEX</small>
                  </div>
                  <div id="palette-colors" class="d-flex gap-1 flex-wrap"></div>
                </div>
                

                
                <div class="row g-2">
                  <div class="col-md-6">
                    <label class="form-label">Opacidade da paleta</label>
                    <input id="palette-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="1">
                    <small class="text-muted">Valor: <span id="opacity-value">1.0</span></small>
                  </div>
                  <div class="col-md-6">
                    <div class="form-check form-switch mt-4">
                      <input class="form-check-input" type="checkbox" id="palette-invert">
                      <label class="form-check-label" for="palette-invert">Inverter ordem das cores</label>
                    </div>
                    <small class="text-muted d-block">Inverte a ordem das cores da paleta selecionada</small>
                  </div>
                </div>
                <div class="row g-2 mt-2">
                  <div class="col-md-6 d-none" id="block-polygon-border">
                    <label class="form-label">Cor da borda</label>
                    <input type="color" id="polygon-border-color" class="form-control form-control-color" value="#333333">
                    <label class="form-label mt-2">Espessura da borda</label>
                    <input type="number" id="polygon-border-width" class="form-control" min="0" max="10" value="2">
                    <div class="form-check form-switch mt-2">
                      <input class="form-check-input" type="checkbox" id="polygon-border-toggle" checked>
                      <label class="form-check-label" for="polygon-border-toggle">Exibir borda dos polígonos</label>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Editor de categorias -->
              <div class="col-md-12 d-none" id="block-category-editor">
                <label class="form-label">Cores e Nomes das Classes</label>
                <div class="alert alert-info">
                  <i class="fas fa-info-circle"></i>
                  <strong>Dica:</strong> Clique no nome da classe para editá-lo. As mudanças são aplicadas automaticamente ao mapa.
                </div>
                <div id="category-list" class="d-flex flex-column gap-2"></div>
              </div>
              
              <!-- Editor de classes para simbologia graduada -->
              <div class="col-md-12 d-none" id="block-graduated-classes">
                <label class="form-label">Editor de Classes da Simbologia Graduada</label>
                <div class="alert alert-info">
                  <i class="fas fa-info-circle"></i>
                  <strong>Dica:</strong> Edite os nomes das classes para personalizar a legenda. As mudanças são aplicadas automaticamente.
                </div>
                
                <!-- Opção de legenda composta -->
                <div class="form-check form-switch mb-3">
                  <input class="form-check-input" type="checkbox" id="composite-legend-toggle" checked>
                  <label class="form-check-label" for="composite-legend-toggle">
                    <strong>Legenda Composta:</strong> Nome da classe + intervalo de valores
                  </label>
                  <small class="text-muted d-block">Exemplo: "Muito Bom - 1,0 a 1,80"</small>
                </div>
                
                <div id="graduated-classes-list" class="d-flex flex-column gap-2"></div>
              </div>
              
              <!-- Cor personalizada (apenas Símbolo Único) -->
              <div class="col-md-12 d-none" id="block-custom-color">
                <label class="form-label">Cor Personalizada (apenas Símbolo Único)</label>
                <div class="row g-3">
                  <div class="col-md-6">
                    <label class="form-label">Borda</label>
                    <input id="stroke-color" type="color" class="form-control form-control-color" value="#333333">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Preenchimento</label>
                    <input id="fill-color" type="color" class="form-control form-control-color" value="#38bdf8">
                  </div>
                </div>
                <div class="row g-3 mt-2">
                  <div class="col-md-6">
                    <label class="form-label">Espessura</label>
                    <input id="stroke-weight" type="number" class="form-control" value="2" min="0" max="10">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Opacidade</label>
                    <input id="fill-opacity" type="number" class="form-control" value="0.3" step="0.05" min="0" max="1">
                  </div>
                </div>
                <div class="row g-3 mt-2" id="block-point-only">
                  <div class="col-md-6">
                    <label class="form-label">Raio (ponto)</label>
                    <input id="point-radius" type="number" class="form-control" value="6" min="1" max="50">
                  </div>
                </div>
                <div class="row g-3 mt-2 d-none" id="block-line-only">
                  <div class="col-md-6">
                    <label class="form-label">Opacidade da linha</label>
                    <input id="line-opacity" type="number" class="form-control" value="1" step="0.05" min="0" max="1">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Tracejado</label>
                    <input id="line-dash" class="form-control" placeholder="ex.: 4,2 (padrão: contínua)">
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Aba de Rótulos -->
          <div class="tab-pane fade" id="labels-content" role="tabpanel">
            <div class="row g-3">
              <div class="col-md-12">
                <div class="form-check form-switch">
                  <input class="form-check-input" type="checkbox" id="labels-enabled" checked>
                  <label class="form-check-label" for="labels-enabled">
                    <strong>Habilitar Rótulos</strong>
                  </label>
                  <small class="text-muted d-block">Marque para exibir rótulos na camada</small>
                </div>
              </div>
              
              <div class="col-md-6">
                <label class="form-label">Campo para Rótulo</label>
                <select id="label-field-select" class="form-select">
                  <option value="">Selecione uma coluna...</option>
                </select>
              </div>
              <div class="col-md-6">
                <label class="form-label">Fonte</label>
                <select id="label-font" class="form-select">
                  <option value="Arial">Arial</option>
                  <option value="Helvetica">Helvetica</option>
                  <option value="Times New Roman">Times New Roman</option>
                  <option value="Georgia">Georgia</option>
                  <option value="Verdana">Verdana</option>
                  <option value="Courier New">Courier New</option>
                </select>
              </div>
              <div class="col-md-6">
                <label class="form-label">Tamanho da Fonte</label>
                <input id="label-size" type="number" class="form-control" min="8" max="72" value="12">
              </div>
              <div class="col-md-6">
                <label class="form-label">Cor do Texto</label>
                <input id="label-color" type="color" class="form-control form-control-color" value="#000000">
              </div>
              <div class="col-md-6">
                <div class="form-check form-switch mt-4">
                  <input class="form-check-input" type="checkbox" id="label-bold">
                  <label class="form-check-label" for="label-bold">Negrito</label>
                </div>
              </div>
              <div class="col-md-6">
                <div class="form-check form-switch mt-4">
                  <input class="form-check-input" type="checkbox" id="label-italic">
                  <label class="form-check-label" for="label-italic">Itálico</label>
                </div>
              </div>
              <div class="col-md-6">
                <label class="form-label">Cor do Buffer</label>
                <input id="label-buffer-color" type="color" class="form-control form-control-color" value="#ffffff">
              </div>
              <div class="col-md-6">
                <label class="form-label">Tamanho do Buffer</label>
                <input id="label-buffer-size" type="number" class="form-control" min="0" max="20" value="2" step="0.5">
              </div>
              <div class="col-md-6">
                <label class="form-label">Opacidade do Buffer</label>
                <input id="label-buffer-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="0.8">
                <small class="text-muted">Valor: <span id="buffer-opacity-value">0.8</span></small>
              </div>
              <div class="col-md-6">
                <label class="form-label">Deslocamento X</label>
                <input id="label-offset-x" type="number" class="form-control" min="-50" max="50" value="0">
              </div>
              <div class="col-md-6">
                <label class="form-label">Deslocamento Y</label>
                <input id="label-offset-y" type="number" class="form-control" min="-50" max="50" value="0">
              </div>
              
              <div class="col-md-12 mt-3">
                <button type="button" id="btn-apply-labels" class="btn btn-success">
                  <i class="fas fa-font"></i> Aplicar Rótulos
                </button>
                <small class="text-muted d-block mt-1">Clique para aplicar as configurações de rótulos ao mapa</small>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    <div class="col-lg-6">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0">Pré-visualização</h5>
        </div>
        <div class="card-body">
          <div class="d-flex justify-content-between align-items-center mb-3">
            <button id="btn-apply" class="btn btn-primary btn-sm">Aplicar Simbologia</button>
            <a class="btn btn-secondary btn-sm" href="{{ url_for('admin_dashboard') }}">Cancelar</a>
          </div>
          <div class="mb-2">
            <label class="form-label">Basemap:</label>
            <select id="basemap-select" class="form-select form-select-sm">
              <option value="osm">OpenStreetMap</option>
              <option value="google-streets">Google Streets</option>
              <option value="google-satellite">Google Satellite</option>
              <option value="google-hybrid">Google Hybrid</option>
              <option value="google-terrain">Google Terrain</option>
            </select>
          </div>
          <div id="symbology-map" style="height: 50vh; min-height: 400px; width: 100%;" class="mb-3 border rounded"></div>
          <div id="preview-legend" class="mb-2"></div>
          <div class="text-muted small">A legenda acima reflete a configuração atual e será exibida no portal.</div>
        </div>
      </div>
    </div>
  </div>


  </div>
</div>
{% endblock %}
{% block scripts %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  let map, layerData, currentLayer, currentBasemap;
  const layerId = {{ layer.id }};
  
  // Paletas de Cores Aprovadas para WebGIS
  const paletasAprovadas = {
    "sequencial": {
      "Viridis": ['#440154', '#472d7b', '#3b528b', '#2c728e', '#21918c', '#28ae80', '#5ec962', '#addc30', '#fde725'],
      "Cividis": ['#00224e', '#1a386f', '#434e6c', '#61656f', '#7d7c78', '#9b9476', '#bcae6c', '#dec958', '#fee838'],
      "Blues": ['#f7fbff', '#deebf7', '#c6dbef', '#9dcae1', '#6aaed6', '#4191c6', '#2070b4', '#08509b', '#08306b'],
      "Greens": ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a0d99b', '#73c476', '#40aa5d', '#228a44', '#006c2c', '#00441b'],
      "YlOrRd": ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8c3c', '#fc4d2a', '#e2191c', '#bb0026', '#800026'],
      "Purples": ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807cba', '#6950a3', '#53268f', '#3f007d'],
      "Greys": ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#959595', '#727272', '#515151', '#242424', '#000000']
    },
    "divergente": {
      "RdYlBu": ['#a50026', '#d62f27', '#f46d43', '#fdad60', '#fee090', '#feffc0', '#e0f3f8', '#aad8e9', '#74add1', '#4574b3', '#313695'],
      "RdYlGn": ['#a50026', '#d62f27', '#f46d43', '#fdad60', '#fee08b', '#feffbe', '#d9ef8b', '#a5d86a', '#66bd63', '#199750', '#006837'],
      "BrBG": ['#543005', '#8b500a', '#bf812d', '#dec17b', '#f6e8c3', '#f4f5f5', '#c7eae5', '#7fccc0', '#35978f', '#01655d', '#003c30'],
      "PiYG": ['#8e0152', '#c41a7c', '#de77ae', '#f1b5d9', '#fde0ef', '#f7f7f6', '#e6f5d0', '#b7e085', '#7fbc41', '#4c9121', '#276419'],
      "Coolwarm": ['#3b4cc0', '#5977e3', '#7b9ff9', '#9ebeff', '#c0d4f5', '#dddcdc', '#f2cbb7', '#f7ac8e', '#ee8468', '#d65244', '#b40426'],
      "Spectral": ['#9e0142', '#d43d4f', '#f46d43', '#fdad60', '#fee08b', '#ffffbe', '#e6f598', '#abdda4', '#66c2a5', '#3387bc', '#5e4fa2']
    },
    "qualitativo": {
      "Vivid (Início Verde)": ['#16d916', '#16d98b', '#16b2d9', '#163dd9', '#6416d9', '#d916d9', '#d91664', '#d93d16', '#d9b216', '#8bd916'],
      "Vivid (Início Azul)": ['#1616d9', '#8b16d9', '#d916b2', '#d9163d', '#d96416', '#d9d916', '#64d916', '#16d93d', '#16d9b2', '#168bd9'],
      "Tableau Tab10": ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
      "ColorBrewer Paired": ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a6a6a', '#ffff99', '#b15928'],
      "ColorBrewer Set3": ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f']
    }
  };

  // Paletas ColorBrewer expandidas (mantidas para compatibilidade)
  const colorBrewer = {
    sequential: ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'BuGn', 'BuPu', 'GnBu', 'OrRd', 'PuBu', 'PuRd', 'RdPu', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd'],
    diverging: ['RdBu', 'RdYlBu', 'RdYlGn', 'BrBG', 'PiYG', 'PRGn', 'PuOr', 'Spectral'],
    qualitative: ['Set1', 'Set2', 'Set3', 'Paired', 'Accent', 'Dark2', 'Pastel1', 'Pastel2', 'tab10', 'tab20', 'tab20b', 'tab20c']
  };

  // Função para gerar cores únicas baseadas em HSL
  function generateUniqueColors(count) {
    const colors = [];
    const hueStep = 360 / count;
    const saturation = 70; // 70% saturation
    const lightness = 60;  // 60% lightness
    
    for (let i = 0; i < count; i++) {
      const hue = (i * hueStep) % 360;
      colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
    }
    return colors;
  }

  // Função para converter HSL para HEX
  function hslToHex(h, s, l) {
    s /= 100;
    l /= 100;
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h / 60) % 2 - 1));
    const m = l - c/2;
    let r = 0, g = 0, b = 0;
    if (0 <= h && h < 120) {
      r = c; g = x; b = 0;
    } else if (60 <= h && h < 120) {
      r = x; g = c; b = 0;
    } else if (120 <= h && h < 180) {
      r = 0; g = c; b = x;
    } else if (180 <= h && h < 240) {
      r = 0; g = x; b = c;
    } else if (240 <= h && h < 300) {
      r = x; g = 0; b = c;
    } else if (300 <= h && h < 360) {
      r = c; g = 0; b = x;
    }
    const rHex = Math.round((r + m) * 255).toString(16).padStart(2, '0');
    const gHex = Math.round((g + m) * 255).toString(16).padStart(2, '0');
    const bHex = Math.round((b + m) * 255).toString(16).padStart(2, '0');
    return `#${rHex}${gHex}${bHex}`;
  }

  // Função para converter HEX para RGB
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  // Função para converter RGB para HEX
  function rgbToHex(r, g, b) {
    const toHex = (n) => {
      const hex = Math.max(0, Math.min(255, n)).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }

  // Função para validar código HEX
  function isValidHex(hex) {
    return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);
  }

  // Função para limpar cores personalizadas de um campo
  function clearCustomColors(field) {
    if (field) {
      let clearedCount = 0;
      
      // Limpar cores personalizadas da simbologia graduada
      for (let i = 0; i < 20; i++) { // Limpar até 20 classes para garantir
        if (localStorage.getItem(`graduated_class_color_${layerId}_${field}_${i}`)) {
          localStorage.removeItem(`graduated_class_color_${layerId}_${field}_${i}`);
          clearedCount++;
        }
      }
      
      // Limpar cores personalizadas das categorias da legenda composta
      const categoryColors = Object.keys(localStorage).filter(key => 
        key.startsWith(`category_color_${layerId}_`)
      );
      
      categoryColors.forEach(key => {
        localStorage.removeItem(key);
        clearedCount++;
      });
      
      // Mostrar notificação se cores foram limpas
      if (clearedCount > 0) {
        showToast(`Cores personalizadas resetadas para a nova paleta selecionada`, 'info');
      }
    }
  }

  // Função para atualizar cor de uma classe
  function updateClassColor(index, newColor) {
    // Atualizar preview da cor
    const colorPreview = document.querySelector(`.color-preview[data-index="${index}"]`);
    if (colorPreview) {
      colorPreview.style.backgroundColor = newColor;
    }
    
    // Atualizar seletor de cor
    const colorInput = document.querySelector(`.graduated-class-color[data-index="${index}"]`);
    if (colorInput) {
      colorInput.value = newColor;
    }
    
    // Atualizar campo HEX
    const hexInput = document.querySelector(`.graduated-class-hex[data-index="${index}"]`);
    if (hexInput) {
      hexInput.value = newColor;
    }
    
    // Atualizar campos RGB
    const rgb = hexToRgb(newColor);
    if (rgb) {
      const rgbInputs = document.querySelector(`.graduated-class-rgb-inputs[data-index="${index}"]`);
      if (rgbInputs) {
        const rInput = rgbInputs.querySelector('input[placeholder="R"]');
        const gInput = rgbInputs.querySelector('input[placeholder="G"]');
        const bInput = rgbInputs.querySelector('input[placeholder="B"]');
        if (rInput) rInput.value = rgb.r;
        if (gInput) gInput.value = rgb.g;
        if (bInput) bInput.value = rgb.b;
      }
    }
    
    // Salvar cor personalizada no localStorage
    const field = document.getElementById('field-select').value;
    localStorage.setItem(`graduated_class_color_${layerId}_${field}_${index}`, newColor);
    
    // Atualizar preview do mapa
    renderMapPreview();
    
    // Forçar atualização da legenda
    setTimeout(() => {
      renderPreview();
    }, 100);
    
    // Salvar configuração
    saveUserConfig();
  }

  // Função para gerar cores da paleta com distribuição otimizada (usando paletas aprovadas primeiro)
  function brewer(palette, count, invert = false) {
    // Função auxiliar para distribuir cores de forma otimizada
    function distributeColorsOptimally(paletteColors, numClasses) {
      if (numClasses <= 0) return [];
      if (numClasses === 1) return [paletteColors[0]];
      if (numClasses === 2) return [paletteColors[0], paletteColors[paletteColors.length - 1]];
      
      const result = [];
      result.push(paletteColors[0]); // Primeira classe sempre recebe primeira cor
      
      // Distribuir cores intermediárias uniformemente
      if (numClasses > 2) {
        const step = (paletteColors.length - 1) / (numClasses - 1);
        for (let i = 1; i < numClasses - 1; i++) {
          const index = Math.round(i * step);
          result.push(paletteColors[index]);
        }
      }
      
      result.push(paletteColors[paletteColors.length - 1]); // Última classe sempre recebe última cor
      
      return result;
    }
    
    // Primeiro, tentar usar as paletas aprovadas
    for (const category in paletasAprovadas) {
      if (paletasAprovadas[category][palette]) {
        const paletteColors = paletasAprovadas[category][palette];
        if (count <= paletteColors.length) {
          let selectedColors = distributeColorsOptimally(paletteColors, count);
          if (invert) {
            selectedColors = selectedColors.reverse();
          }
          return selectedColors;
        } else {
          // Se precisar de mais cores, gerar cores únicas
          let uniqueColors = generateUniqueColors(count).map(color => {
            const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
            if (match) {
              return hslToHex(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
            }
            return color;
          });
          if (invert) {
            uniqueColors = uniqueColors.reverse();
          }
          return uniqueColors;
        }
      }
    }
    
    // Segundo, tentar usar paletas personalizadas
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    const customPalette = customPalettes.find(p => p.name === palette);
    if (customPalette) {
      const paletteColors = customPalette.colors;
      if (count <= paletteColors.length) {
        let selectedColors = distributeColorsOptimally(paletteColors, count);
        if (invert) {
          selectedColors = selectedColors.reverse();
        }
        return selectedColors;
      } else {
        // Se precisar de mais cores, gerar cores únicas
        let uniqueColors = generateUniqueColors(count).map(color => {
          const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
          if (match) {
            return hslToHex(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
          }
          return color;
        });
        if (invert) {
          uniqueColors = uniqueColors.reverse();
        }
        return uniqueColors;
      }
    }
    
    // Fallback para paletas ColorBrewer originais
    const palettes = {
      // Sequential palettes
      'viridis': ['#440154', '#482878', '#3e4989', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6ece58', '#b5de2b', '#fde725'],
      'plasma': ['#0d0887', '#41049d', '#6a00a8', '#8f0aa4', '#b12a90', '#cc4778', '#e16462', '#f1834b', '#fca636', '#fcce25'],
      'inferno': ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c5c', '#cf4446', '#ed6925', '#f58b49', '#fdb42f', '#fce762'],
      'magma': ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c5c', '#cf4446', '#ed6925', '#f58b49', '#fdb42f', '#fce762'],
      'cividis': ['#00224f', '#123a5a', '#2d4f69', '#446475', '#5b7a7c', '#729083', '#8aa68a', '#a3bc93', '#bdd3a8', '#d8e5be'],
      'Blues': ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
      'Greens': ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
      'Reds': ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
      'Oranges': ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#e6550d', '#a63603', '#7f2704'],
      'Purples': ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
      
      // Diverging palettes
      'RdBu': ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
      'RdYlBu': ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
      'RdYlGn': ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
      'BrBG': ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
      'PiYG': ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
      'PRGn': ['#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
      'PuOr': ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
      'Spectral': ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
      
      // Qualitative palettes
      'Set1': ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
      'Set2': ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
      'Set3': ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
      'Paired': ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a6a6a', '#ffff99', '#b15928'],
      'Accent': ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
      'Dark2': ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
      'Pastel1': ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
      'Pastel2': ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
      'tab10': ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
      'tab20': ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'],
      'tab20b': ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'],
      'tab20c': ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9']
    };
    
    if (palettes[palette]) {
      const paletteColors = palettes[palette];
      if (count <= paletteColors.length) {
        let selectedColors = distributeColorsOptimally(paletteColors, count);
        if (invert) {
          selectedColors = selectedColors.reverse();
          // Manter a lógica de extremos mesmo após inversão
          if (count > 2) {
            const temp = selectedColors[0];
            selectedColors[0] = selectedColors[selectedColors.length - 1];
            selectedColors[selectedColors.length - 1] = temp;
          }
        }
        return selectedColors;
      }
    }
    
    // Fallback para cores únicas
    let fallbackColors = generateUniqueColors(count).map(color => {
      const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
      if (match) {
        return hslToHex(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
      }
      return color;
    });
    
    if (invert) {
      fallbackColors = fallbackColors.reverse();
    }
    
    return fallbackColors;
  }

  // Função para carregar paletas personalizadas
  function loadCustomPalettes() {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    const customGroup = document.getElementById('custom-palettes-group');
    
    // Limpar opções existentes
    customGroup.innerHTML = '';
    
    customPalettes.forEach(palette => {
      const option = document.createElement('option');
      option.value = palette.name;
      option.textContent = `${palette.name} - ${palette.description}`;
      option.dataset.palette = palette.name;
      customGroup.appendChild(option);
    });
  }

  // Função para salvar paleta personalizada
  function saveCustomPalette(name, description, colors) {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    
    // Verificar se já existe uma paleta com esse nome
    const existingIndex = customPalettes.findIndex(p => p.name === name);
    
    if (existingIndex !== -1) {
      customPalettes[existingIndex] = { name, description, colors };
    } else {
      customPalettes.push({ name, description, colors });
    }
    
    localStorage.setItem('custom_palettes', JSON.stringify(customPalettes));
    loadCustomPalettes();
    
    // Selecionar a paleta recém-criada
    document.getElementById('palette-select').value = name;
    updatePalettePreview();
  }

  // Função para criar nova paleta
  function createNewPalette() {
    const name = prompt('Nome da nova paleta:');
    if (!name) return;
    
    const description = prompt('Descrição da paleta:');
    if (!description) return;
    
    const numColors = parseInt(prompt('Número de cores (3-12):', '5')) || 5;
    if (numColors < 3 || numColors > 12) {
      alert('Número de cores deve ser entre 3 e 12');
      return;
    }
    
    // Gerar cores únicas para a nova paleta
    const colors = generateUniqueColors(numColors).map(color => {
      const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
      if (match) {
        return hslToHex(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
      }
      return color;
    });
    
    saveCustomPalette(name, description, colors);
    showToast(`Paleta "${name}" criada com sucesso!`, 'success');
  }

  // Função para salvar paleta atual
  function saveCurrentPalette() {
    const currentPalette = document.getElementById('palette-select').value;
    const currentColors = brewer(currentPalette, 8, document.getElementById('palette-invert').checked);
    
    const name = prompt('Nome para salvar a paleta atual:', currentPalette);
    if (!name) return;
    
    const description = prompt('Descrição da paleta:', `Paleta baseada em ${currentPalette}`);
    if (!description) return;
    
    saveCustomPalette(name, description, currentColors);
    showToast(`Paleta "${name}" salva com sucesso!`, 'success');
  }

  // Função para gerenciar paletas
  function managePalettes() {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    
    if (customPalettes.length === 0) {
      alert('Nenhuma paleta personalizada encontrada.');
      return;
    }
    
    let message = 'Paletas personalizadas:\n\n';
    customPalettes.forEach((palette, index) => {
      message += `${index + 1}. ${palette.name} - ${palette.description}\n`;
      message += `   Cores: ${palette.colors.length}\n\n`;
    });
    
    message += 'Digite o número da paleta para excluir (ou 0 para cancelar):';
    const choice = parseInt(prompt(message, '0')) || 0;
    
    if (choice > 0 && choice <= customPalettes.length) {
      const paletteToDelete = customPalettes[choice - 1];
      if (confirm(`Tem certeza que deseja excluir a paleta "${paletteToDelete.name}"?`)) {
        customPalettes.splice(choice - 1, 1);
        localStorage.setItem('custom_palettes', JSON.stringify(customPalettes));
        loadCustomPalettes();
        showToast(`Paleta "${paletteToDelete.name}" excluída!`, 'success');
      }
    }
  }

  // Função para salvar configurações do usuário
  function saveUserConfig() {
    const config = {
      field: document.getElementById('field-select').value,
      styleType: document.getElementById('style-type').value,
      geomType: document.getElementById('geom-type').value,
      palette: document.getElementById('palette-select').value,
      paletteOpacity: document.getElementById('palette-opacity').value,
      paletteInvert: document.getElementById('palette-invert').checked,
      classes: document.getElementById('classes').value,
      method: document.getElementById('method').value,
      manualBreaks: document.getElementById('manual-breaks').value,
      strokeColor: document.getElementById('stroke-color').value,
      fillColor: document.getElementById('fill-color').value,
      strokeWeight: document.getElementById('stroke-weight').value,
      fillOpacity: document.getElementById('fill-opacity').value,
      pointRadius: document.getElementById('point-radius').value,
      lineOpacity: document.getElementById('line-opacity').value,
      lineDash: document.getElementById('line-dash').value,
      polygonBorderColor: document.getElementById('polygon-border-color').value,
      polygonBorderWidth: document.getElementById('polygon-border-width').value,
      polygonBorderToggle: document.getElementById('polygon-border-toggle').checked,
      labelField: document.getElementById('label-field-select').value,
      labelFont: document.getElementById('label-font').value,
      labelSize: document.getElementById('label-size').value,
      labelColor: document.getElementById('label-color').value,
      labelBold: document.getElementById('label-bold').checked,
      labelItalic: document.getElementById('label-italic').checked,
      labelBufferColor: document.getElementById('label-buffer-color').value,
      labelBufferSize: document.getElementById('label-buffer-size').value,
      labelBufferOpacity: document.getElementById('label-buffer-opacity').value,
      labelOffsetX: document.getElementById('label-offset-x').value,
      labelOffsetY: document.getElementById('label-offset-y').value,
      labelsEnabled: document.getElementById('labels-enabled').checked,
      compositeLegend: document.getElementById('composite-legend-toggle')?.checked || false,
      timestamp: Date.now() // Adicionar timestamp
    };
    
    localStorage.setItem(`symbology_config_${layerId}`, JSON.stringify(config));
  }
  
  // Função para verificar se um campo é numérico
  function isNumericField(field) {
    if (!layerData || !layerData.features || layerData.features.length === 0) {
      return false;
    }
    
    // Verificar os primeiros valores do campo para determinar se é numérico
    const sampleValues = layerData.features.slice(0, 10).map(f => f.properties[field]);
    
    return sampleValues.every(value => {
      if (value === null || value === undefined || value === '') return false;
      // Aceitar tanto vírgula quanto ponto como separador decimal
      const normalizedValue = value.toString().replace(',', '.');
      const num = parseFloat(normalizedValue);
      return !isNaN(num) && isFinite(num);
    });
  }

  // Função para mostrar aviso sobre campo não numérico
  function showNumericFieldWarning(field) {
    // Verificar se já existe um modal
    let existingModal = document.querySelector('.numeric-validation-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Criar modal estilizado
    const modal = document.createElement('div');
    modal.className = 'numeric-validation-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(5px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease-out;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      background: linear-gradient(135deg, #ffffff, #f8f9fa);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.15);
      max-width: 500px;
      width: 90%;
      position: relative;
      animation: slideInScale 0.3s ease-out;
      border: 1px solid #e9ecef;
    `;
    
    modalContent.innerHTML = `
      <div style="text-align: center; margin-bottom: 20px;">
        <div style="
          width: 60px;
          height: 60px;
          background: linear-gradient(135deg, #ffc107, #fd7e14);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          margin: 0 auto 15px;
          box-shadow: 0 8px 16px rgba(255, 193, 7, 0.3);
        ">
          <i class="fas fa-exclamation-triangle" style="font-size: 24px; color: white;"></i>
        </div>
        <h4 style="color: #212529; margin: 0; font-weight: 600;">Problema na Simbologia do Mapa</h4>
      </div>
      
      <div style="margin-bottom: 25px;">
        <p style="color: #6c757d; margin-bottom: 15px; font-size: 16px; line-height: 1.5;">
          O campo <strong style="color: #dc3545;">"${field}"</strong> não pode ser usado para simbologia graduada porque não contém valores numéricos válidos.
        </p>
        
        <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; border-left: 4px solid #28a745;">
          <p style="margin: 0 0 15px 0; color: #495057; font-weight: 500;">
            <i class="fas fa-info-circle" style="color: #17a2b8; margin-right: 8px;"></i>
            Para simbologia graduada, selecione um campo com:
          </p>
          <ul style="margin: 0; padding-left: 20px; color: #6c757d;">
            <li style="margin-bottom: 8px;">
              <strong>Números inteiros:</strong> 1, 2, 100, 500
            </li>
            <li style="margin-bottom: 8px;">
              <strong>Números decimais:</strong> 1,5 • 23,7 • 99,99
            </li>
          </ul>
        </div>
        
        <div style="background: #e7f3ff; padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #007bff;">
          <p style="margin: 0; color: #495057; font-size: 14px;">
            <i class="fas fa-lightbulb" style="color: #ffc107; margin-right: 8px;"></i>
            <strong>Dica:</strong> A simbologia graduada representa variação numérica através de cores, 
            criando uma representação visual da intensidade dos dados. Selecione um campo com números para continuar.
          </p>
        </div>
      </div>
      
      <div style="text-align: center;">
        <button id="close-numeric-modal" style="
          background: linear-gradient(135deg, #007bff, #0056b3);
          color: white;
          border: none;
          padding: 12px 30px;
          border-radius: 8px;
          font-size: 16px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 123, 255, 0.4)';" 
           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0, 123, 255, 0.3)';">
          <i class="fas fa-check" style="margin-right: 8px;"></i>
          Entendi
        </button>
      </div>
    `;
    
    // Adicionar CSS de animações se não existir
    if (!document.querySelector('#numeric-modal-animations')) {
      const style = document.createElement('style');
      style.id = 'numeric-modal-animations';
      style.textContent = `
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideInScale {
          from { 
            opacity: 0;
            transform: scale(0.8) translateY(-20px);
          }
          to { 
            opacity: 1;
            transform: scale(1) translateY(0);
          }
        }
        @keyframes fadeOut {
          from { opacity: 1; }
          to { opacity: 0; }
        }
        @keyframes slideOutScale {
          from { 
            opacity: 1;
            transform: scale(1) translateY(0);
          }
          to { 
            opacity: 0;
            transform: scale(0.8) translateY(-20px);
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Event listener para fechar modal
    const closeBtn = modal.querySelector('#close-numeric-modal');
    const closeModal = () => {
      modal.style.animation = 'fadeOut 0.3s ease-out';
      modalContent.style.animation = 'slideOutScale 0.3s ease-out';
      setTimeout(() => {
        if (modal.parentNode) {
          modal.remove();
        }
      }, 300);
    };
    
    closeBtn.addEventListener('click', closeModal);
    
    // Fechar ao clicar no fundo
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeModal();
      }
    });
    
    // Fechar com ESC
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        closeModal();
        document.removeEventListener('keydown', handleEsc);
      }
    };
    document.addEventListener('keydown', handleEsc);
  }

  // Função para mostrar mensagem de sucesso da simbologia com timeout
  function showSymbologySuccessMessage() {
    // Verificar se já existe uma mensagem ativa
    let existingMessage = document.querySelector('.symbology-success-message');
    if (existingMessage) {
      existingMessage.remove();
    }
    
    // Criar nova mensagem
    const message = document.createElement('div');
    message.className = 'alert alert-success symbology-success-message';
    message.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border: none;
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      font-weight: 500;
      max-width: 400px;
      animation: slideInRight 0.3s ease-out;
    `;
    
    message.innerHTML = `
      <div style="display: flex; align-items: center; gap: 10px;">
        <i class="fas fa-check-circle" style="font-size: 18px;"></i>
        <div>
          <strong>Simbologia aplicada com sucesso!</strong><br>
          <small>A camada será exibida com o novo estilo no portal.</small><br>
          <small style="opacity: 0.8;">Esta mensagem se fechará em <span id="countdown">5</span>s</small>
        </div>
        <button type="button" class="btn-close btn-close-white ms-auto" style="font-size: 12px;"></button>
      </div>
    `;
    
    // Adicionar CSS de animação se não existir
    if (!document.querySelector('#symbology-animations')) {
      const style = document.createElement('style');
      style.id = 'symbology-animations';
      style.textContent = `
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
          from { transform: translateX(0); opacity: 1; }
          to { transform: translateX(100%); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Event listener para o botão de fechar
    const closeBtn = message.querySelector('.btn-close');
    closeBtn.addEventListener('click', () => {
      message.style.animation = 'slideOutRight 0.3s ease-out';
      setTimeout(() => message.remove(), 300);
    });
    
    // Adicionar ao documento
    document.body.appendChild(message);
    
    // Implementar contador regressivo
    let countdown = 5;
    const countdownElement = message.querySelector('#countdown');
    
    const countdownInterval = setInterval(() => {
      countdown--;
      if (countdownElement) {
        countdownElement.textContent = countdown;
      }
      
      if (countdown <= 0) {
        clearInterval(countdownInterval);
        if (message.parentNode) {
          message.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => {
            if (message.parentNode) {
              message.remove();
            }
          }, 300);
        }
      }
    }, 1000);
    
    // Limpar interval se a mensagem for fechada manualmente
    const originalCloseHandler = closeBtn.onclick;
    closeBtn.addEventListener('click', () => {
      clearInterval(countdownInterval);
    });
  }

  // Função para salvar simbologia no banco de dados
  async function saveSymbologyToDatabase(config) {
    try {
      const style = computeStyle();
      
      // Adicionar nomes personalizados das classes
      if (style.classes) {
        style.custom_class_names = [];
        for (let i = 0; i < style.classes; i++) {
          const className = localStorage.getItem(`graduated_class_${layerId}_${style.field}_${i}`) || `Classe ${i + 1}`;
          style.custom_class_names.push(className);
        }
      }
      
      // Adicionar configuração da legenda composta
      style.composite_legend = document.getElementById('composite-legend-toggle')?.checked || false;
      
      // Adicionar informações de faixas de valores para a legenda
      if (style.field && layerData) {
        const values = layerData.features
          .map(f => parseFloat(f.properties[style.field]))
          .filter(v => !isNaN(v))
          .sort((a, b) => a - b);
        
        if (values.length > 0) {
          const min = values[0];
          const max = values[values.length - 1];
          const classes = style.classes || 5;
          
          // Gerar breaks baseado no método
          let breaks = [];
          if (style.method === 'equal') {
            const step = (max - min) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(min + (i * step));
            }
          } else if (style.method === 'quantile') {
            const step = values.length / classes;
            for (let i = 0; i <= classes; i++) {
              const index = Math.floor(i * step);
              breaks.push(values[Math.min(index, values.length - 1)]);
            }
          } else if (style.method === 'jenks') {
            const step = values.length / classes;
            for (let i = 0; i <= classes; i++) {
              const index = Math.floor(i * step);
              breaks.push(values[Math.min(index, values.length - 1)]);
            }
          } else if (style.method === 'log') {
            const logMin = Math.log(Math.max(min, 0.1));
            const logMax = Math.log(max);
            const step = (logMax - logMin) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(Math.exp(logMin + (i * step)));
            }
          } else if (style.method === 'stddev') {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            const stddev = Math.sqrt(variance);
            const stddevStep = (2 * stddev) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(mean - stddev + (i * stddevStep));
            }
          } else if (style.method === 'arithmetic') {
            const step = (max - min) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(min + (i * step));
            }
          } else if (style.method === 'geometric') {
            const ratio = Math.pow(max / min, 1 / classes);
            for (let i = 0; i <= classes; i++) {
              breaks.push(min * Math.pow(ratio, i));
            }
          } else if (style.method === 'manual' && style.breaks) {
            breaks = style.breaks;
          }
          
          style.class_breaks = breaks;
        }
      }
      
      console.log('Enviando simbologia para o banco:', style);
      
      const response = await fetch(`/admin/layer/${layerId}/symbology/save`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(style)
      });
      
      if (response.ok) {
        console.log('Simbologia salva no banco de dados com sucesso');
        showSymbologySuccessMessage();
        return true;
      } else {
        const errorData = await response.json();
        console.error('Erro ao salvar simbologia no banco de dados:', errorData);
        showToast(`Erro ao salvar simbologia: ${errorData.message || 'Erro desconhecido'}`, 'error');
      }
    } catch (error) {
      console.error('Erro ao salvar simbologia:', error);
      showToast('Erro ao salvar simbologia no portal', 'error');
    }
  }

  // Função para carregar configurações salvas do usuário
  function loadUserConfig() {
    try {
      const savedConfig = localStorage.getItem(`symbology_config_${layerId}`);
      if (savedConfig) {
        const config = JSON.parse(savedConfig);
        
        // Restaurar configurações básicas
        if (config.field) {
          document.getElementById('field-select').value = config.field;
        }
        if (config.styleType) {
          document.getElementById('style-type').value = config.styleType;
        }
        if (config.geomType) {
          document.getElementById('geom-type').value = config.geomType;
        }
        if (config.palette) {
          document.getElementById('palette-select').value = config.palette;
        }
        if (config.paletteOpacity) {
          document.getElementById('palette-opacity').value = config.paletteOpacity || 1;
          document.getElementById('opacity-value').textContent = config.paletteOpacity;
        }
        if (config.paletteInvert !== undefined) {
          document.getElementById('palette-invert').checked = config.paletteInvert;
        }
        
        // Restaurar configurações de classes e método
        if (config.classes) {
          document.getElementById('classes').value = config.classes;
        }
        if (config.method) {
          document.getElementById('method').value = config.method;
        }
        if (config.manualBreaks) {
          document.getElementById('manual-breaks').value = config.manualBreaks;
        }
        
        // Restaurar configurações de cor personalizada
        if (config.strokeColor) {
          document.getElementById('stroke-color').value = config.strokeColor;
        }
        if (config.fillColor) {
          document.getElementById('fill-color').value = config.fillColor;
        }
        if (config.strokeWeight) {
          document.getElementById('stroke-weight').value = config.strokeWeight;
        }
        if (config.fillOpacity) {
          document.getElementById('fill-opacity').value = config.fillOpacity;
        }
        if (config.pointRadius) {
          document.getElementById('point-radius').value = config.pointRadius;
        }
        if (config.lineOpacity) {
          document.getElementById('line-opacity').value = config.lineOpacity;
        }
        if (config.lineDash) {
          document.getElementById('line-dash').value = config.lineDash;
        }
        
        // Restaurar configurações de polígono
        if (config.polygonBorderColor) {
          document.getElementById('polygon-border-color').value = config.polygonBorderColor;
        }
        if (config.polygonBorderWidth) {
          document.getElementById('polygon-border-width').value = config.polygonBorderWidth;
        }
        if (config.polygonBorderToggle !== undefined) {
          document.getElementById('polygon-border-toggle').checked = config.polygonBorderToggle;
        }
        
        // Restaurar configurações de rótulos
        if (config.labelField) {
          document.getElementById('label-field-select').value = config.labelField;
        }
        if (config.labelFont) {
          document.getElementById('label-font').value = config.labelFont;
        }
        if (config.labelSize) {
          document.getElementById('label-size').value = config.labelSize;
        }
        if (config.labelColor) {
          document.getElementById('label-color').value = config.labelColor;
        }
        if (config.labelBold !== undefined) {
          document.getElementById('label-bold').checked = config.labelBold;
        }
        if (config.labelItalic !== undefined) {
          document.getElementById('label-italic').checked = config.labelItalic;
        }
        if (config.labelBufferColor) {
          document.getElementById('label-buffer-color').value = config.labelBufferColor;
        }
        if (config.labelBufferSize) {
          document.getElementById('label-buffer-size').value = config.labelBufferSize;
        }
        if (config.labelBufferOpacity) {
          document.getElementById('label-buffer-opacity').value = config.labelBufferOpacity;
          document.getElementById('buffer-opacity-value').textContent = config.labelBufferOpacity;
        }
        if (config.labelOffsetX) {
          document.getElementById('label-offset-x').value = config.labelOffsetX;
        }
        if (config.labelOffsetY) {
          document.getElementById('label-offset-y').value = config.labelOffsetY;
        }
        if (config.labelsEnabled !== undefined) {
          document.getElementById('labels-enabled').checked = config.labelsEnabled;
        }
        
        // Restaurar configuração da legenda composta
        if (config.compositeLegend !== undefined) {
          const compositeToggle = document.getElementById('composite-legend-toggle');
          if (compositeToggle) {
            compositeToggle.checked = config.compositeLegend;
          }
        }
        
        return true;
      }
    } catch (error) {
      console.error('Erro ao carregar configurações salvas:', error);
    }
    return false;
  }

  // Função para limpar configurações antigas (mais de 30 dias)
  function clearOldConfigs() {
    const now = Date.now();
    const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
    
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('symbology_config_')) {
        try {
          const config = JSON.parse(localStorage.getItem(key));
          if (config.timestamp && config.timestamp < thirtyDaysAgo) {
            localStorage.removeItem(key);
          }
        } catch (e) {
          // Se não conseguir parsear, remove o item corrompido
          localStorage.removeItem(key);
        }
      }
    });
  }

  // Função para adicionar timestamp às configurações
  function addTimestampToConfig(config) {
    config.timestamp = Date.now();
    return config;
  }

  // Função para mostrar toast de feedback
  function showToast(message, type = 'info') {
    // Criar toast
    const toastDiv = document.createElement('div');
    toastDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
    toastDiv.style.cssText = `
      top: 20px;
      right: 20px;
      z-index: 9999;
      min-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    `;
    
    const iconClass = type === 'success' ? 'fa-check-circle' : 
                     type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle';
    
    toastDiv.innerHTML = `
      <i class="fas ${iconClass}"></i>
      <strong>${type === 'success' ? 'Sucesso!' : type === 'error' ? 'Erro!' : 'Info!'}</strong> ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(toastDiv);
    
    // Auto-remover após 3 segundos
    setTimeout(() => {
      if (toastDiv.parentNode) {
        toastDiv.remove();
      }
    }, 3000);
  }

  // Função para mostrar feedback visual de configurações carregadas
  function showConfigLoadedFeedback() {
    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'alert alert-info alert-dismissible fade show';
    feedbackDiv.innerHTML = `
      <i class="fas fa-info-circle"></i>
      <strong>Configurações restauradas!</strong> Suas últimas configurações foram carregadas automaticamente.
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    const container = document.querySelector('.container-fluid');
    container.insertBefore(feedbackDiv, container.firstChild);
    
    // Auto-remover após 5 segundos
    setTimeout(() => {
      if (feedbackDiv.parentNode) {
        feedbackDiv.remove();
      }
    }, 5000);
  }

  // Função para limpar configurações da camada atual
  function clearCurrentConfig() {
    if (confirm('Tem certeza que deseja limpar todas as configurações salvas para esta camada?')) {
      localStorage.removeItem(`symbology_config_${layerId}`);
      alert('Configurações salvas limpas com sucesso!');
      location.reload(); // Recarrega a página para mostrar que as configurações foram removidas
    }
  }

  // Função para inicializar o mapa
  function initMap() {
    console.log('Inicializando mapa...');
    
    // Verificar se o container existe
    const mapContainer = document.getElementById('symbology-map');
    if (!mapContainer) {
      console.error('Container do mapa não encontrado!');
      return;
    }
    
    // Inicializar mapa Leaflet com coordenadas do Brasil
    map = L.map('symbology-map').setView([-15.7801, -47.9292], 4); // Centro do Brasil
    
    console.log('Mapa criado:', map);
    
    // Adicionar basemap padrão (OpenStreetMap)
    currentBasemap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);
    
    console.log('Basemap padrão adicionado:', currentBasemap);
    
    // Event listener para mudança de basemap
    document.getElementById('basemap-select').addEventListener('change', function() {
      const basemapType = this.value;
      console.log('Mudando basemap para:', basemapType);
      
      // Remover basemap atual
      if (currentBasemap) {
        map.removeLayer(currentBasemap);
      }
      
      // Adicionar novo basemap
      switch (basemapType) {
        case 'osm':
          currentBasemap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
          }).addTo(map);
          break;
        case 'google-streets':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
        case 'google-satellite':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
        case 'google-hybrid':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
        case 'google-terrain':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
      }
      
      console.log('Novo basemap aplicado:', currentBasemap);
    });
    
    // Forçar atualização do mapa
    setTimeout(() => {
      if (map) {
        map.invalidateSize();
        console.log('Mapa atualizado com sucesso');
      }
    }, 100);
  }

  // Função para inicializar a página
  async function initializePage() {
    console.log('Inicializando página...');
    
    // Limpar configurações antigas
    clearOldConfigs();
    
    // Aguardar um pouco para garantir que o DOM esteja pronto
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Inicializar mapa
    initMap();
    
    // Aguardar um pouco para o mapa ser inicializado
    await new Promise(resolve => setTimeout(resolve, 200));
    
    // Carregar campos da camada
    await loadLayerFields();
    
    // Carregar dados da camada (que também restaura configurações)
    await loadLayerData();
    
    // Inicializar visualização da paleta
    updatePalettePreview();
    
    // Forçar atualização do mapa novamente
    if (map) {
      setTimeout(() => {
        map.invalidateSize();
        console.log('Mapa finalizado com sucesso');
      }, 300);
    }
    
    // Mostrar feedback se configurações foram carregadas
    if (localStorage.getItem(`symbology_config_${layerId}`)) {
      showConfigLoadedFeedback();
    }
    
    console.log('Página inicializada com sucesso');
  }

  // Função para aplicar visibilidade dos blocos
  function applyVisibility() {
    const styleType = document.getElementById('style-type').value;
    const geomType = document.getElementById('geom-type').value;
    
    // Blocos condicionais
    document.getElementById('block-classes').classList.toggle('d-none', !['graduated', 'raster'].includes(styleType));
    document.getElementById('block-method').classList.toggle('d-none', !['graduated'].includes(styleType));
    document.getElementById('block-manual').classList.toggle('d-none', !(styleType === 'graduated' && document.getElementById('method').value === 'manual'));
    document.getElementById('block-category-editor').classList.toggle('d-none', styleType !== 'categorized');
    document.getElementById('block-custom-color').classList.toggle('d-none', styleType !== 'single');
    document.getElementById('block-polygon-border').classList.toggle('d-none', geomType !== 'polygon');
    document.getElementById('block-point-only').classList.toggle('d-none', geomType !== 'point');
    document.getElementById('block-line-only').classList.toggle('d-none', geomType !== 'line');
    
    // Ocultar paleta de cores para símbolo único e mostrar cor personalizada
    document.getElementById('block-palette').classList.toggle('d-none', styleType === 'single');
    
    // Mostrar editor de classes para simbologia graduada
    document.getElementById('block-graduated-classes').classList.toggle('d-none', styleType !== 'graduated');
    
    // Mostrar informações do método selecionado
    showMethodInfo();
  }
  
  // Função para mostrar informações padrão quando nenhum método está selecionado
  function showDefaultMethodInfo() {
    const infoContainer = document.getElementById('method-info');
    if (!infoContainer) return;
    
    infoContainer.innerHTML = `
      <div class="method-header">
        <div class="method-icon">
          <i class="fas fa-info-circle"></i>
        </div>
        <div class="method-title-section">
          <div class="method-title">Métodos de Classificação</div>
          <div class="method-description">Escolha um método para ver informações detalhadas</div>
        </div>
      </div>
      <div class="method-content-grid">
        <div class="method-detail-card">
          <div class="detail-header">
            <span class="detail-icon">🔵</span>
            <span class="detail-label">Como funciona</span>
          </div>
          <div class="detail-text">Selecione um método de classificação para visualizar informações detalhadas sobre como ele funciona, quando usá-lo e exemplos práticos.</div>
        </div>
        <div class="method-detail-card">
          <div class="detail-header">
            <span class="detail-icon">🟢</span>
            <span class="detail-label">Ideal para</span>
          </div>
          <div class="detail-text">Cada método tem suas características específicas. Escolha baseado no tipo de dados e objetivo da análise.</div>
        </div>
        <div class="method-detail-card">
          <div class="detail-header">
            <span class="detail-icon">🟡</span>
            <span class="detail-label">Exemplo</span>
          </div>
          <div class="detail-text">Após selecionar um método, você verá exemplos práticos de como ele classifica os dados.</div>
        </div>
      </div>
    `;
  }
  
  // Função para mostrar informações do método de classificação
  function showMethodInfo() {
    const methodSelect = document.getElementById('method');
    const infoContainer = document.getElementById('method-info');
    
    if (!methodSelect || !infoContainer) return;
    
    const selectedMethod = methodSelect.value;
    
    if (!selectedMethod) {
      // Se não há método selecionado, mostra informações padrão
      showDefaultMethodInfo();
      return;
    }
    
    const methodInfos = {
      'equal': {
        icon: 'fa-equals',
        title: 'Intervalos Iguais',
        description: 'Divide o range em classes de mesmo tamanho',
        howItWorks: 'O valor máximo menos o mínimo é dividido pelo número de classes',
        idealFor: 'Dados uniformemente distribuídos',
        example: 'Se os dados vão de 0 a 100 com 5 classes: 0-20, 20-40, 40-60, 60-80, 80-100'
      },
      'quantiles': {
        icon: 'fa-chart-pie',
        title: 'Quantis (Equal Count)',
        description: 'Cada classe tem o mesmo número de elementos',
        howItWorks: 'Os dados são ordenados e divididos em grupos com igual quantidade de registros',
        idealFor: 'Comparações percentuais e dados com distribuição desigual',
        example: 'Com 100 registros e 4 classes: 25 registros por classe (0-25%, 25-50%, 50-75%, 75-100%)'
      },
      'jenks': {
        icon: 'fa-chart-line',
        title: 'Quebras Naturais (Jenks)',
        description: 'Otimiza a separação natural dos dados',
        howItWorks: 'Algoritmo que minimiza variância dentro das classes e maximiza entre classes',
        idealFor: 'Dados com padrões naturais de agrupamento',
        example: 'Identifica automaticamente onde os dados "quebram" naturalmente, como mudanças bruscas de tendência'
      },
      'log': {
        icon: 'fa-chart-area',
        title: 'Classificação Logarítmica',
        description: 'Aplica escala logarítmica antes da classificação',
        howItWorks: 'Transforma os dados usando logaritmo (ln ou log10) antes de aplicar a classificação',
        idealFor: 'Dados com crescimento exponencial ou distribuição log-normal',
        example: 'Para dados de 1 a 1000: log(1)=0, log(10)=1, log(100)=2, log(1000)=3'
      },
      'stddev': {
        icon: 'fa-chart-bar',
        title: 'Desvio Padrão',
        description: 'Cria classes baseadas na média ± múltiplos do desvio padrão',
        howItWorks: 'Calcula a média e desvio padrão, criando classes como: média±1σ, média±2σ, etc.',
        idealFor: 'Destacar valores extremos, anomalias e distribuições normais',
        example: 'Se média=50 e σ=10: 40-60 (1σ), 30-40 e 60-70 (2σ), <30 e >70 (3σ)'
      },
      'arithmetic': {
        icon: 'fa-plus',
        title: 'Progressão Aritmética',
        description: 'Cada classe aumenta por uma diferença constante',
        howItWorks: 'Define uma razão constante (ex: +10) para cada classe subsequente',
        idealFor: 'Dados com crescimento linear constante',
        example: 'Com razão +15: 0-15, 15-30, 30-45, 45-60, 60-75'
      },
      'geometric': {
        icon: 'fa-times',
        title: 'Progressão Geométrica',
        description: 'Cada classe multiplica por uma razão constante',
        howItWorks: 'Define uma razão multiplicativa constante (ex: ×2) para cada classe',
        idealFor: 'Dados com crescimento exponencial ou multiplicativo',
        example: 'Com razão ×2: 1-2, 2-4, 4-8, 8-16, 16-32'
      },
      'manual': {
        icon: 'fa-edit',
        title: 'Classificação Manual',
        description: 'Defina exatamente onde cada classe começa e termina',
        howItWorks: 'Você especifica manualmente os valores de corte para cada classe',
        idealFor: 'Controle total sobre os intervalos e conhecimento específico do domínio',
        example: 'Defina classes como: 0-5, 5-10, 10-20, 20-50, >50'
      }
    };
    
    const info = methodInfos[selectedMethod];
    if (info) {
      infoContainer.innerHTML = `
        <div class="method-header">
          <div class="method-icon">
            <i class="fas ${info.icon}"></i>
          </div>
          <div class="method-title-section">
            <div class="method-title">${info.title}</div>
            <div class="method-description">${info.description}</div>
          </div>
        </div>
        <div class="method-content-grid">
          <div class="method-detail-card">
            <div class="detail-header">
              <span class="detail-icon">🔵</span>
              <span class="detail-label">Como funciona</span>
            </div>
            <div class="detail-text">${info.howItWorks}</div>
          </div>
          <div class="method-detail-card">
            <div class="detail-header">
              <span class="detail-icon">🟢</span>
              <span class="detail-label">Ideal para</span>
            </div>
            <div class="detail-text">${info.idealFor}</div>
          </div>
          <div class="method-detail-card">
            <div class="detail-header">
              <span class="detail-icon">🟡</span>
              <span class="detail-label">Exemplo</span>
            </div>
            <div class="detail-text">${info.example}</div>
          </div>
        </div>
      `;
      infoContainer.classList.remove('d-none');
    } else {
      infoContainer.classList.add('d-none');
    }
  }

  // Função para detectar tipo de geometria da camada
  function detectGeometryType(layerData) {
    if (!layerData || !layerData.features || layerData.features.length === 0) {
      return 'polygon'; // padrão
    }
    
    const firstFeature = layerData.features[0];
    if (!firstFeature.geometry) {
      return 'polygon'; // padrão
    }
    
    const geomType = firstFeature.geometry.type;
    
    switch (geomType.toLowerCase()) {
      case 'point':
      case 'multipoint':
        return 'point';
      case 'linestring':
      case 'multilinestring':
        return 'line';
      case 'polygon':
      case 'multipolygon':
        return 'polygon';
      default:
        return 'polygon'; // padrão
    }
  }

  // Função para carregar campos da camada
  async function loadLayerFields() {
    try {
      const response = await fetch(`/admin/layer/${layerId}/fields`);
      const data = await response.json();
      
      const fieldSelect = document.getElementById('field-select');
      const labelFieldSelect = document.getElementById('label-field-select');
      
      fieldSelect.innerHTML = '<option value="">Selecione uma coluna...</option>';
      labelFieldSelect.innerHTML = '<option value="">Selecione uma coluna...</option>';
      
      data.fields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.name;
        option.textContent = `${field.name} (${field.dtype})`;
        fieldSelect.appendChild(option);
        
        const labelOption = document.createElement('option');
        labelOption.value = field.name;
        labelOption.textContent = `${field.name} (${field.dtype})`;
        labelFieldSelect.appendChild(labelOption);
      });
    } catch (error) {
      console.error('Erro ao carregar campos:', error);
    }
  }

  // Função para carregar categorias para um campo
  async function loadCategoriesForField(field) {
    try {
      const response = await fetch(`/admin/layer/${layerId}/classify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ field, mode: 'categorized' })
      });
      
      const data = await response.json();
      if (data.categories) {
        return data.categories;
      }
    } catch (error) {
      console.error('Erro ao carregar categorias:', error);
    }
    return [];
  }

  // Função para criar interface de cores por categoria com nomes editáveis
  function createCategoryColorInterface(categories) {
    const container = document.getElementById('category-list');
    container.innerHTML = '';
    
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    const colors = brewer(palette, categories.length, invert);
    
    categories.forEach((category, index) => {
      let color;
      
      // Tentar carregar cor personalizada salva
      const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
      
      if (savedColor) {
        // Usar cor personalizada salva
        color = savedColor;
      } else if (index < colors.length) {
        // Usar cor da paleta se disponível
        color = colors[index];
      } else {
        // Gerar cor aleatória para classes excedentes
        const hue = Math.random() * 360;
        const saturation = 60 + Math.random() * 30; // 60-90%
        const lightness = 40 + Math.random() * 30;  // 40-70%
        color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
      }
      
      const div = document.createElement('div');
      div.className = 'd-flex align-items-center gap-2 p-2 border rounded';
      div.innerHTML = `
        <div class="d-flex align-items-center gap-2">
          <input type="color" class="form-control form-control-color category-color" 
                 value="${color}" data-category="${category}" style="width: 40px;">
          <input type="text" class="form-control form-control-sm category-name" 
                 value="${category}" data-original="${category}" style="min-width: 120px;"
                 placeholder="Nome da classe">
        </div>
        <div class="d-flex gap-1">
          <button type="button" class="btn btn-outline-primary btn-sm category-hex-btn" 
                  data-category="${category}" title="Inserir cor HEX">
            <i class="fas fa-hashtag"></i> HEX
          </button>
          <button type="button" class="btn btn-outline-success btn-sm category-rgb-btn" 
                  data-category="${category}" title="Inserir cor RGB">
            <i class="fas fa-palette"></i> RGB
          </button>
        </div>
        <div class="flex-grow-1 d-none category-hex-input" data-category="${category}">
          <input type="text" class="form-control form-control-sm category-hex" 
                 placeholder="HEX (ex: #FF5733)" value="${color}" data-category="${category}">
        </div>
        <div class="flex-grow-1 d-none category-rgb-input" data-category="${category}">
          <input type="text" class="form-control form-control-sm category-rgb" 
                 placeholder="RGB (ex: 255,87,51)" data-category="${category}">
        </div>
      `;
      
      // Event listeners para mudanças de cor
      const colorInput = div.querySelector('.category-color');
      const nameInput = div.querySelector('.category-name');
      const hexBtn = div.querySelector('.category-hex-btn');
      const rgbBtn = div.querySelector('.category-rgb-btn');
      const hexInputContainer = div.querySelector('.category-hex-input');
      const rgbInputContainer = div.querySelector('.category-rgb-input');
      const hexInput = div.querySelector('.category-hex');
      const rgbInput = div.querySelector('.category-rgb');
      
      // Event listener para mudança de nome da classe
      nameInput.addEventListener('input', (e) => {
        // Atualizar o data-category para manter referência
        const newName = e.target.value;
        div.querySelectorAll('[data-category]').forEach(el => {
          el.dataset.category = newName;
        });
        refreshPreview();
        saveUserConfig();
      });
      
      // Toggle dos campos de entrada - apenas um por vez
      hexBtn.addEventListener('click', function() {
        // Fechar campo RGB se estiver aberto
        rgbInputContainer.classList.add('d-none');
        // Toggle campo HEX
        hexInputContainer.classList.toggle('d-none');
        if (!hexInputContainer.classList.contains('d-none')) {
          hexInput.focus();
        }
      });
      
      rgbBtn.addEventListener('click', function() {
        // Fechar campo HEX se estiver aberto
        hexInputContainer.classList.add('d-none');
        // Toggle campo RGB
        rgbInputContainer.classList.toggle('d-none');
        if (!rgbInputContainer.classList.contains('d-none')) {
          rgbInput.focus();
        }
      });
      
      colorInput.addEventListener('change', (e) => {
        const newColor = e.target.value;
        hexInput.value = newColor;
        
        // Salvar cor personalizada
        localStorage.setItem(`category_color_${layerId}_${category}`, newColor);
        
        refreshPreview();
        saveUserConfig();
      });
      
      hexInput.addEventListener('input', (e) => {
        if (e.target.value.match(/^#[0-9A-Fa-f]{6}$/)) {
          const newColor = e.target.value;
          colorInput.value = newColor;
          
          // Salvar cor personalizada
          localStorage.setItem(`category_color_${layerId}_${category}`, newColor);
          
          refreshPreview();
          saveUserConfig();
        }
      });
      
      rgbInput.addEventListener('input', (e) => {
        const rgb = e.target.value.match(/^(\d+),\s*(\d+),\s*(\d+)$/);
        if (rgb) {
          const hex = '#' + [parseInt(rgb[1]), parseInt(rgb[2]), parseInt(rgb[3])]
            .map(x => x.toString(16).padStart(2, '0')).join('');
          colorInput.value = hex;
          hexInput.value = hex;
          
          // Salvar cor personalizada
          localStorage.setItem(`category_color_${layerId}_${category}`, hex);
          
          refreshPreview();
          saveUserConfig();
        }
      });
      
      container.appendChild(div);
    });
  }

  // Função para atualizar visualização da paleta selecionada
  function updatePalettePreview() {
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    const colorsContainer = document.getElementById('palette-colors');
    const paletteNameSpan = document.getElementById('palette-name');
    
    // Atualizar nome da paleta
    if (paletteNameSpan) {
      paletteNameSpan.textContent = palette;
    }
    
    // Limpar container
    colorsContainer.innerHTML = '';
    
    // Gerar cores da paleta selecionada
    const colors = brewer(palette, 8, invert); // Mostrar 8 cores para preview
    
    // Criar elementos de cor
    colors.forEach(color => {
      const colorDiv = document.createElement('div');
      colorDiv.style.cssText = `
        width: 35px; 
        height: 35px; 
        background-color: ${color}; 
        border: 2px solid #fff; 
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      `;
      
      // Tooltip com valor HEX
      colorDiv.title = `Clique para copiar: ${color}`;
      
      // Efeito hover
      colorDiv.addEventListener('mouseenter', () => {
        colorDiv.style.transform = 'scale(1.15)';
        colorDiv.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
      });
      
      colorDiv.addEventListener('mouseleave', () => {
        colorDiv.style.transform = 'scale(1)';
        colorDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
      });
      
      // Clique para copiar cor
      colorDiv.addEventListener('click', () => {
        navigator.clipboard.writeText(color).then(() => {
          // Feedback visual
          const originalBorder = colorDiv.style.border;
          colorDiv.style.border = '2px solid #28a745';
          colorDiv.style.transform = 'scale(1.2)';
          
          setTimeout(() => {
            colorDiv.style.border = originalBorder;
            colorDiv.style.transform = 'scale(1)';
          }, 500);
          
          // Mostrar toast ou alert
          showToast(`Cor ${color} copiada para a área de transferência!`, 'success');
        }).catch(err => {
          console.error('Erro ao copiar cor:', err);
          showToast('Erro ao copiar cor', 'error');
        });
      });
      
      colorsContainer.appendChild(colorDiv);
    });
  }

  // Função para atualizar cores da paleta visual (mantida para compatibilidade)
  function updatePaletteVisualColors() {
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    
    // Atualizar cores na visualização da paleta
    document.querySelectorAll('.palette-item').forEach(paletteItem => {
      const paletteName = paletteItem.dataset.palette;
      if (paletteName === palette) {
        const colors = brewer(paletteName, 5, invert);
        const colorDivs = paletteItem.querySelectorAll('div[style*="background-color"]');
        colors.forEach((color, index) => {
          if (colorDivs[index]) {
            colorDivs[index].style.backgroundColor = color;
          }
        });
      }
    });
  }
  
  // Função para criar interface de classes da simbologia graduada
  function createGraduatedClassesInterface(style) {
    const container = document.getElementById('graduated-classes-list');
    container.innerHTML = '';
    
    if (!style || !style.field || !style.classes) {
      container.innerHTML = '<div class="text-muted">Selecione um campo e número de classes para editar as classes.</div>';
      return;
    }
    
    const palette = style.palette || 'Blues';
    const colors = brewer(palette, style.classes, style.palette_invert);
    
    // Gerar nomes padrão para as classes
    const classNames = [];
    for (let i = 0; i < style.classes; i++) {
      const className = localStorage.getItem(`graduated_class_${layerId}_${style.field}_${i}`) || `Classe ${i + 1}`;
      classNames.push(className);
    }
    
    // Carregar cores personalizadas salvas ou usar cores da paleta
    const customColors = [];
    for (let i = 0; i < style.classes; i++) {
      const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
      customColors.push(savedColor || colors[i]);
    }
    
    customColors.forEach((color, index) => {
      const div = document.createElement('div');
      div.className = 'd-flex align-items-center gap-2 p-2 border rounded';
      div.innerHTML = `
        <div class="d-flex align-items-center gap-2">
          <div class="color-preview" style="width: 30px; height: 30px; background-color: ${color}; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;" data-index="${index}"></div>
          <input type="text" class="form-control form-control-sm graduated-class-name" 
                 value="${classNames[index]}" data-index="${index}" data-field="${style.field}"
                 style="min-width: 150px;" placeholder="Nome da classe">
        </div>
        <div class="d-flex align-items-center gap-2">
          <input type="color" class="form-control form-control-color graduated-class-color" 
                 value="${color}" data-index="${index}" style="width: 40px; height: 30px;" title="Seletor de cor">
          <input type="text" class="form-control form-control-sm graduated-class-hex" 
                 value="${color}" data-index="${index}" style="width: 80px;" placeholder="HEX" title="Código HEX">
          <button type="button" class="btn btn-outline-secondary btn-sm graduated-class-rgb-btn" 
                  data-index="${index}" title="Mostrar/ocultar campos RGB">
            <i class="fas fa-palette"></i> RGB
          </button>
        </div>
        <div class="d-flex align-items-center gap-2">
          <div class="text-muted small">
            <span class="class-range" data-index="${index}">Faixa de valores</span>
          </div>
          <div class="graduated-class-rgb-inputs d-none" data-index="${index}">
            <input type="number" class="form-control form-control-sm" min="0" max="255" 
                   placeholder="R" style="width: 50px;" title="Valor Vermelho (0-255)">
            <input type="number" class="form-control form-control-sm" min="0" max="255" 
                   placeholder="G" style="width: 50px;" title="Valor Verde (0-255)">
            <input type="number" class="form-control form-control-sm" min="0" max="255" 
                   placeholder="B" style="width: 50px;" title="Valor Azul (0-255)">
          </div>
        </div>
      `;
      
      container.appendChild(div);
      
      // Event listeners para edição de cores
      const colorPreview = div.querySelector('.color-preview');
      const colorInput = div.querySelector('.graduated-class-color');
      const hexInput = div.querySelector('.graduated-class-hex');
      const rgbBtn = div.querySelector('.graduated-class-rgb-btn');
      const rgbInputs = div.querySelector('.graduated-class-rgb-inputs');
      const rInput = rgbInputs.querySelector('input[placeholder="R"]');
      const gInput = rgbInputs.querySelector('input[placeholder="G"]');
      const bInput = rgbInputs.querySelector('input[placeholder="B"]');
      
      // Converter cor inicial para RGB
      const rgb = hexToRgb(color);
      if (rgb) {
        rInput.value = rgb.r;
        gInput.value = rgb.g;
        bInput.value = rgb.b;
      }
      
      // Event listener para seletor de cor
      colorInput.addEventListener('input', function() {
        const newColor = this.value;
        updateClassColor(index, newColor);
      });
      
      // Event listener para campo HEX
      hexInput.addEventListener('input', function() {
        const newColor = this.value;
        if (isValidHex(newColor)) {
          updateClassColor(index, newColor);
        }
      });
      
      // Event listener para botão RGB
      rgbBtn.addEventListener('click', function() {
        rgbInputs.classList.toggle('d-none');
        this.classList.toggle('btn-secondary');
        this.classList.toggle('btn-outline-secondary');
      });
      
      // Event listeners para campos RGB
      [rInput, gInput, bInput].forEach(input => {
        input.addEventListener('input', function() {
          const r = parseInt(rInput.value) || 0;
          const g = parseInt(gInput.value) || 0;
          const b = parseInt(bInput.value) || 0;
          const newColor = rgbToHex(r, g, b);
          updateClassColor(index, newColor);
        });
      });
      
      // Event listener para edição do nome da classe
      const nameInput = div.querySelector('.graduated-class-name');
      nameInput.addEventListener('input', function() {
        const newName = this.value;
        const index = this.dataset.index;
        const field = this.dataset.field;
        
        // Salvar no localStorage
        localStorage.setItem(`graduated_class_${layerId}_${field}_${index}`, newName);
        
        // Atualizar preview (sem recriar a interface para evitar travamento)
        updateGraduatedClassRanges(style);
        renderMapPreview();
        
        // Forçar atualização da legenda
        setTimeout(() => {
          renderPreview();
        }, 100);
        
        // Salvar configuração e enviar para o banco
        saveUserConfig();
      });
      
      // Limitar a 50 caracteres
      nameInput.setAttribute('maxlength', '50');
    });
    
    // Atualizar faixas de valores quando possível
    updateGraduatedClassRanges(style);
  }
  
  // Função para atualizar as faixas de valores das classes graduadas
  function updateGraduatedClassRanges(style) {
    if (!layerData || !style.field) return;
    
    const values = layerData.features
      .map(f => parseFloat(f.properties[style.field]))
      .filter(v => !isNaN(v))
      .sort((a, b) => a - b);
    
    if (values.length === 0) return;
    
    const min = values[0];
    const max = values[values.length - 1];
    const classes = style.classes || 5;
    
    // Gerar breaks baseado no método
    let breaks = [];
    if (style.method === 'equal') {
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    } else if (style.method === 'quantile') {
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'jenks') {
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'log') {
      const logMin = Math.log(Math.max(min, 0.1));
      const logMax = Math.log(max);
      const step = (logMax - logMin) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(Math.exp(logMin + (i * step)));
      }
    } else if (style.method === 'stddev') {
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
      const stddev = Math.sqrt(variance);
      const stddevStep = (2 * stddev) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(mean - stddev + (i * stddevStep));
      }
    } else if (style.method === 'arithmetic') {
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    } else if (style.method === 'geometric') {
      const ratio = Math.pow(max / min, 1 / classes);
      for (let i = 0; i <= classes; i++) {
        breaks.push(min * Math.pow(ratio, i));
      }
    } else if (style.method === 'manual' && style.breaks) {
      breaks = style.breaks;
    }
    
    // Atualizar as faixas de valores na interface
    document.querySelectorAll('.class-range').forEach((rangeSpan, index) => {
      if (index < breaks.length - 1) {
        const start = breaks[index].toFixed(2);
        const end = breaks[index + 1].toFixed(2);
        
        // Formatar números: usar "." como separador de milhar e "," como decimal
        const formatNumber = (num) => {
          const parts = num.split('.');
          if (parts.length === 2) {
            const integerPart = parts[0];
            const decimalPart = parts[1];
            // Adicionar separador de milhar se necessário
            const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
            return `${formattedInteger},${decimalPart}`;
          }
          return num.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
        };
        
        const formattedStart = formatNumber(start);
        const formattedEnd = formatNumber(end);
        rangeSpan.textContent = `${formattedStart} a ${formattedEnd}`;
      }
    });
  }

  // Função para computar o estilo baseado nas seleções
  function computeStyle() {
    const styleType = document.getElementById('style-type').value;
    const geomType = document.getElementById('geom-type').value;
    const field = document.getElementById('field-select').value;
    const palette = document.getElementById('palette-select').value;
    const paletteOpacity = parseFloat(document.getElementById('palette-opacity').value);
    const paletteInvert = document.getElementById('palette-invert').checked;
    
    const style = {
      type: styleType,
      geometry_type: geomType,
      field: field,
      palette: palette,
      palette_opacity: paletteOpacity,
      palette_invert: paletteInvert
    };
    
    if (styleType === 'single') {
      style.stroke_color = document.getElementById('stroke-color').value;
      style.fill_color = document.getElementById('fill-color').value;
      style.stroke_weight = parseInt(document.getElementById('stroke-weight').value);
      style.fill_opacity = parseFloat(document.getElementById('fill-opacity').value);
      
      if (geomType === 'point') {
        style.radius = parseInt(document.getElementById('point-radius').value);
      } else if (geomType === 'line') {
        style.opacity = parseFloat(document.getElementById('line-opacity').value);
        const dash = document.getElementById('line-dash').value;
        if (dash) style.dashArray = dash;
      }
    } else if (styleType === 'categorized') {
      const categories = Array.from(document.querySelectorAll('.category-color')).map(input => {
        const nameInput = input.closest('.d-flex').querySelector('.category-name');
        return {
          category: nameInput.value || input.dataset.category,
          color: input.value,
          original_value: input.dataset.category // Manter valor original para mapeamento
        };
      });
      style.categories = categories;
      
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      }
    } else if (styleType === 'graduated') {
      const classes = parseInt(document.getElementById('classes').value);
      const method = document.getElementById('method').value;
      style.classes = classes;
      
      // Debug: verificar valores coletados
      console.log('Valores coletados para simbologia graduada:', {
        classes: classes,
        method: method,
        field: style.field,
        palette: style.palette
      });
      
      // Mapear valores do dropdown para os valores esperados pela função
      if (method === 'equal') style.method = 'equal';
      else if (method === 'quantiles') style.method = 'quantile';
      else if (method === 'jenks') style.method = 'jenks';
      else if (method === 'log') style.method = 'log';
      else if (method === 'manual') style.method = 'manual';
      else style.method = 'equal'; // Padrão
      
      if (method === 'manual') {
        const breaks = document.getElementById('manual-breaks').value;
        if (breaks) {
          style.breaks = breaks.split(',').map(b => parseFloat(b.trim()));
        }
      }
      
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      }
      
      // Debug: verificar estilo final
      console.log('Estilo graduado final:', style);
    }
    
    return style;
  }

  // Função para renderizar preview da legenda
  function renderPreview() {
    console.log('renderPreview chamada');
    const style = computeStyle();
    console.log('Estilo computado:', style);
    const legendDiv = document.getElementById('preview-legend');
    
    if (style.type === 'single') {
      legendDiv.innerHTML = `
        <div class="d-flex align-items-center gap-2 p-2 border rounded">
          <div style="width: 20px; height: 20px; background-color: ${style.fill_color}; border: 2px solid ${style.stroke_color};"></div>
          <span>${style.field || 'Símbolo único'}</span>
        </div>
      `;
    } else if (style.type === 'categorized' && style.categories) {
      legendDiv.innerHTML = style.categories.map(cat => `
        <div class="d-flex align-items-center gap-2 p-2 border rounded mb-1">
          <div style="width: 20px; height: 20px; background-color: ${cat.color};"></div>
          <span>${cat.category}</span>
        </div>
      `).join('');
    } else if (style.type === 'graduated') {
      // Para dados vetoriais graduados, mostrar legenda discreta
      if (style.geometry_type !== 'raster') {
        // Gerar cores da paleta para a legenda discreta
        const palette = style.palette || 'Blues';
        const classes = style.classes || 5;
        const colors = brewer(palette, classes, style.palette_invert);
        
        // Carregar cores personalizadas se disponíveis
        const customColors = [];
        for (let i = 0; i < classes; i++) {
          const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
          customColors.push(savedColor || colors[i]);
        }
        
        // Criar legenda discreta com cada classe individual
        const legendItems = customColors.map((color, index) => {
          // Obter nome personalizado da classe
          const customClassName = localStorage.getItem(`graduated_class_${layerId}_${style.field}_${index}`) || `Classe ${index + 1}`;
          
          // Verificar se deve mostrar legenda composta
          const compositeLegend = document.getElementById('composite-legend-toggle')?.checked;
          
          let legendText = customClassName;
          
          if (compositeLegend) {
            // Obter intervalo de valores da classe
            const classRangeElement = document.querySelector(`.class-range[data-index="${index}"]`);
            if (classRangeElement) {
              const rangeText = classRangeElement.textContent;
              legendText = `${customClassName} - ${rangeText}`;
            }
          }
          
          console.log(`Classe ${index}: ${customClassName}, Legenda: ${legendText}`);
          
          return `
            <div class="d-flex align-items-center gap-2 p-2 border rounded mb-1">
              <div style="width: 20px; height: 20px; background-color: ${color}; border: 1px solid #ccc;"></div>
              <span>${legendText}</span>
            </div>
          `;
        }).join('');
        
        legendDiv.innerHTML = `
          <div class="mb-2">
            <div><strong>${style.field}</strong></div>
            <div class="small text-muted">Método: ${style.method}</div>
            <div class="small text-muted">Paleta: ${palette}</div>
            <div class="small text-muted">${classes} classes</div>
            <div class="small text-muted">Tipo: Vetorial (discreto)</div>
          </div>
          ${legendItems}
        `;
      } else {
        // Para dados raster, manter legenda contínua
        const palette = style.palette || 'Blues';
        const classes = style.classes || 5;
        const colors = brewer(palette, classes, style.palette_invert);
        
        // Criar gradiente visual para a legenda
        const gradientColors = colors.map(color => color).join(', ');
        
        legendDiv.innerHTML = `
          <div class="d-flex align-items-center gap-2 p-2 border rounded">
            <div class="d-flex flex-column">
              <div style="width: 20px; height: 60px; background: linear-gradient(to bottom, ${gradientColors}); border: 1px solid #ccc;"></div>
              <small class="text-muted text-center">${classes} classes</small>
            </div>
            <div class="flex-grow-1">
              <div><strong>${style.field}</strong></div>
              <div class="small text-muted">Método: ${style.method}</div>
              <div class="small text-muted">Paleta: ${palette}</div>
              <div class="small text-muted">Tipo: Raster (contínuo)</div>
            </div>
          </div>
        `;
      }
    }
  }

  // Função para renderizar rótulos no mapa
  function renderLabelsOnMap() {
    if (!layerData || !map) return;
    
    // Remover rótulos existentes
    map.eachLayer(layer => {
      if (layer._labelLayer) {
        map.removeLayer(layer);
      }
    });
    
    const labelsEnabled = document.getElementById('labels-enabled').checked;
    if (!labelsEnabled) return;
    
    const labelField = document.getElementById('label-field-select').value;
    if (!labelField) return;
    
    const labelConfig = {
      font: document.getElementById('label-font').value,
      size: parseInt(document.getElementById('label-size').value),
      color: document.getElementById('label-color').value,
      bold: document.getElementById('label-bold').checked,
      italic: document.getElementById('label-italic').checked,
      bufferColor: document.getElementById('label-buffer-color').value,
      bufferSize: parseInt(document.getElementById('label-buffer-size').value),
      bufferOpacity: parseFloat(document.getElementById('label-buffer-opacity').value),
      offsetX: parseInt(document.getElementById('label-offset-x').value),
      offsetY: parseInt(document.getElementById('label-offset-y').value)
    };
    
    // Criar camada de rótulos
    const labelLayer = L.layerGroup();
    labelLayer._labelLayer = true;
    
    layerData.features.forEach(feature => {
      if (feature.geometry && feature.properties[labelField]) {
        const labelText = feature.properties[labelField].toString();
        
        // Calcular posição do rótulo baseado na geometria
        let labelPosition;
        if (feature.geometry.type === 'Point') {
          labelPosition = feature.geometry.coordinates;
        } else if (feature.geometry.type === 'LineString') {
          // Posição no meio da linha
          const coords = feature.geometry.coordinates;
          const midIndex = Math.floor(coords.length / 2);
          labelPosition = coords[midIndex];
        } else if (feature.geometry.type === 'Polygon') {
          // Centro do polígono
          const coords = feature.geometry.coordinates[0];
          let sumX = 0, sumY = 0;
          coords.forEach(coord => {
            sumX += coord[0];
            sumY += coord[1];
          });
          labelPosition = [sumX / coords.length, sumY / coords.length];
        }
        
        if (labelPosition) {
          // Converter coordenadas para lat/lng
          const latLng = L.latLng(labelPosition[1], labelPosition[0]);
          
          // Criar elemento HTML para o rótulo
          const labelDiv = document.createElement('div');
          labelDiv.innerHTML = labelText;
          labelDiv.style.cssText = `
            font-family: ${labelConfig.font}, sans-serif;
            font-size: ${labelConfig.size}px;
            color: ${labelConfig.color};
            font-weight: ${labelConfig.bold ? 'bold' : 'normal'};
            font-style: ${labelConfig.italic ? 'italic' : 'normal'};
            text-shadow: 
              -1px -1px 0 ${labelConfig.bufferColor},
              -1px 1px 0 ${labelConfig.bufferColor},
              1px -1px 0 ${labelConfig.bufferColor},
              1px 1px 0 ${labelConfig.bufferColor};
            text-shadow: 
              -1px -1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              -1px 1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              1px -1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              1px 1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor};
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
          `;
          
          // Criar marcador de rótulo
          const labelMarker = L.marker(latLng, {
            icon: L.divIcon({
              html: labelDiv,
              className: 'label-icon',
              iconSize: [labelDiv.offsetWidth, labelDiv.offsetHeight],
              iconAnchor: [labelDiv.offsetWidth / 2, labelDiv.offsetHeight / 2]
            })
          });
          
          // Aplicar deslocamento
          if (labelConfig.offsetX !== 0 || labelConfig.offsetY !== 0) {
            labelMarker.setLatLng([
              latLng.lat + (labelConfig.offsetY / 1000),
              latLng.lng + (labelConfig.offsetX / 1000)
            ]);
          }
          
          labelLayer.addLayer(labelMarker);
        }
      }
    });
    
    labelLayer.addTo(map);
  }

  // Função para renderizar preview no mapa (aplicação instantânea)
  function renderMapPreview() {
    console.log('renderMapPreview chamada');
    if (!currentLayer || !map) {
      console.log('renderMapPreview: currentLayer ou map não disponível');
      return;
    }
    
    // Aplicar mudanças INSTANTANEAMENTE sem remover a camada
    const style = computeStyle();
    
    // Aplicar estilo baseado no tipo
    if (style.type === 'single') {
      currentLayer.setStyle({
        color: style.stroke_color,
        weight: style.stroke_weight,
        fillColor: style.fill_color,
        fillOpacity: style.fill_opacity
      });
      
      if (style.geometry_type === 'point') {
        currentLayer.eachLayer(layer => {
          if (layer.setRadius) {
            layer.setRadius(style.radius);
          }
        });
      } else if (style.geometry_type === 'line') {
        currentLayer.eachLayer(layer => {
          if (style.opacity !== undefined) {
            layer.setStyle({ opacity: style.opacity });
          }
          if (style.dashArray) {
            layer.setStyle({ dashArray: style.dashArray });
          }
        });
      }
    } else if (style.type === 'categorized' && style.categories) {
      // Aplicar estilo categorizado INSTANTANEAMENTE
      currentLayer.eachLayer(layer => {
        if (layer.feature && layer.feature.properties && style.field) {
          const value = layer.feature.properties[style.field];
          const category = style.categories.find(cat => cat.original_value == value);
          if (category) {
            layer.setStyle({
              color: style.border_color || '#333333',
              weight: style.border_width || 1,
              fillColor: category.color,
              fillOpacity: style.palette_opacity || 0.6
            });
          }
        }
      });
    } else if (style.type === 'graduated') {
      // Aplicar estilo graduado
      console.log('renderMapPreview: Aplicando estilo graduado:', style);
      if (style.field && style.classes && style.method) {
        console.log('Aplicando estilo graduado:', style);
        applyGraduatedStyle(currentLayer, style);
      } else {
        console.log('Dados insuficientes para estilo graduado:', {
          field: style.field,
          classes: style.classes,
          method: style.method
        });
      }
    }
    
    // Adicionar camada ao mapa se não estiver presente
    if (!map.hasLayer(currentLayer)) {
      console.log('renderMapPreview: Adicionando camada ao mapa');
      currentLayer.addTo(map);
    }
    
    // Renderizar rótulos se habilitados
    renderLabelsOnMap();
    
    // Atualizar legenda após renderizar o mapa
    setTimeout(() => {
      renderPreview();
    }, 100);
    
    console.log('renderMapPreview concluída - mudanças aplicadas instantaneamente');
  }

  // Função para atualizar preview
  function refreshPreview() {
    console.log('refreshPreview chamada');
    renderPreview();
    renderMapPreview(); // Isso agora inclui renderização de rótulos
    updatePalettePreview(); // Atualizar visualização da paleta
    updatePaletteVisualColors();
    
    // Atualizar interface de classes graduadas se aplicável (apenas se não existir)
    const styleType = document.getElementById('style-type').value;
    if (styleType === 'graduated') {
      const style = computeStyle();
      const existingInterface = document.getElementById('graduated-classes-list');
      if (!existingInterface.children.length) {
        createGraduatedClassesInterface(style);
      } else {
        // Apenas atualizar as faixas de valores sem recriar a interface
        updateGraduatedClassRanges(style);
      }
    }
  }

  // Função para carregar dados da camada
  async function loadLayerData() {
    try {
      console.log('Carregando dados da camada...');
      
      // Usar a URL correta para carregar os dados da camada
      // Primeiro, vamos tentar obter o slug da empresa do usuário logado
      let companySlug = 'amplo'; // Padrão
      
      // Tentar obter do contexto da página ou do usuário
      try {
        // Verificar se há um elemento com o slug da empresa
        const companyElement = document.querySelector('#company-data');
        if (companyElement) {
          companySlug = companyElement.dataset.companySlug;
          console.log('Slug da empresa obtido:', companySlug);
        }
      } catch (e) {
        console.log('Usando slug padrão da empresa:', companySlug);
      }
      
      const url = `/portal/${companySlug}/api/camada_data/${layerId}`;
      console.log('URL da API:', url);
      
      const response = await fetch(url);
      console.log('Resposta da API:', response.status, response.statusText);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      layerData = await response.json();
      console.log('Dados da camada carregados:', layerData);
      
      if (map && layerData.features && layerData.features.length > 0) {
        console.log('Camada tem', layerData.features.length, 'features');
        
        // Remover camada anterior se existir
        if (currentLayer) {
          map.removeLayer(currentLayer);
          console.log('Camada anterior removida');
        }
        
        // Criar nova camada GeoJSON
        currentLayer = L.geoJSON(layerData, {
          style: {
            color: '#333333',
            weight: 2,
            fillColor: '#38bdf8',
            fillOpacity: 0.6
          },
          onEachFeature: function(feature, layer) {
            layer.bindPopup(`
              <strong>${feature.properties[Object.keys(feature.properties)[0]] || 'Sem nome'}</strong><br>
              ${Object.entries(feature.properties).map(([key, value]) => `${key}: ${value}`).join('<br>')}
            `);
          }
        });
        
        // Adicionar ao mapa
        currentLayer.addTo(map);
        console.log('Nova camada adicionada ao mapa');
        
        // Ajustar visualização
        if (currentLayer.getBounds) {
          map.fitBounds(currentLayer.getBounds());
          console.log('Mapa ajustado aos limites da camada');
        }
        
        // Detectar e preselecionar tipo de geometria
        const detectedType = detectGeometryType(layerData);
        document.getElementById('geom-type').value = detectedType;
        console.log('Tipo de geometria detectado:', detectedType);
        
        // Aplicar visibilidade baseada no tipo detectado
        applyVisibility();
        
        // Restaurar configurações salvas do usuário
        const configRestored = loadUserConfig();
        
        // Se configurações foram restauradas, aplicar visibilidade novamente
        if (configRestored) {
          applyVisibility();
          
          // Se tiver campo selecionado e for categorizada, carregar categorias
          const field = document.getElementById('field-select').value;
          const styleType = document.getElementById('style-type').value;
          if (field && styleType === 'categorized') {
            loadCategoriesForField(field).then(categories => {
              createCategoryColorInterface(categories);
              refreshPreview();
            });
          }
        }
        
        refreshPreview();
        console.log('Dados da camada carregados com sucesso');
      } else {
        console.warn('Dados da camada vazios ou mapa não inicializado');
        if (!map) {
          console.error('Mapa não está inicializado!');
        }
        if (!layerData.features || layerData.features.length === 0) {
          console.error('Camada não tem features!');
        }
      }
    } catch (error) {
      console.error('Erro ao carregar dados da camada:', error);
      
      // Mostrar erro para o usuário
      const errorDiv = document.createElement('div');
      errorDiv.className = 'alert alert-danger alert-dismissible fade show';
      errorDiv.innerHTML = `
        <i class="fas fa-exclamation-triangle"></i>
        <strong>Erro ao carregar dados da camada:</strong> ${error.message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      const container = document.querySelector('.container-fluid');
      if (container) {
        container.insertBefore(errorDiv, container.firstChild);
      }
    }
  }

  // Inicialização da página
  document.addEventListener('DOMContentLoaded', function() {
    // Carregar campos e dados
    initializePage();
    
    // Mostrar informações padrão na caixa explicativa
    showDefaultMethodInfo();
    
    // Event listeners para mudanças
    document.getElementById('style-type').addEventListener('change', function() {
      const styleType = this.value;
      const fieldSelect = document.getElementById('field-select');
      const field = fieldSelect.value;
      
      applyVisibility();
      
      // Se mudou para simbologia graduada, verificar se o campo é numérico
      if (styleType === 'graduated') {
        if (field && !isNumericField(field)) {
          showNumericFieldWarning(field);
          // Voltar para o tipo anterior ou padrão
          this.value = 'single';
          applyVisibility();
          return;
        }
        
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      }
      
      // Atualizar informações do método
      showMethodInfo();
      
      refreshPreview();
      saveUserConfig(); // Salvar configuração automaticamente
    });
    document.getElementById('geom-type').addEventListener('change', function() {
      applyVisibility();
      refreshPreview();
      saveUserConfig(); // Salvar configuração automaticamente
    });
    document.getElementById('method').addEventListener('change', function() {
      applyVisibility();
      
      // Atualizar informações do método
      showMethodInfo();
      
      saveUserConfig(); // Salvar configuração automaticamente
    });
    
    // Event listener para seleção de campo
    document.getElementById('field-select').addEventListener('change', async function() {
      const field = this.value;
      const styleType = document.getElementById('style-type').value;
      
      if (field && styleType === 'categorized') {
        const categories = await loadCategoriesForField(field);
        createCategoryColorInterface(categories);
        refreshPreview();
      } else if (field && styleType === 'graduated') {
        // Verificar se o campo é numérico para simbologia graduada
        if (!isNumericField(field)) {
          showNumericFieldWarning(field);
          // Limpar a seleção do campo
          this.value = '';
          return;
        }
        
        // Para simbologia graduada, atualizar interface de classes
        const style = computeStyle();
        createGraduatedClassesInterface(style);
        refreshPreview();
      }
      saveUserConfig(); // Salvar configuração automaticamente
    });
    
    document.getElementById('palette-select').addEventListener('change', function() {
      // Limpar cores personalizadas antes de aplicar nova paleta
      const field = document.getElementById('field-select').value;
      clearCustomColors(field);
      
      updatePalettePreview();
      createCategoryColorInterface([]);
      
      // Se for simbologia graduada, atualizar interface de classes
      if (document.getElementById('style-type').value === 'graduated') {
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      }
      
      refreshPreview();
      saveUserConfig();
    });
    
    document.getElementById('palette-opacity').addEventListener('input', function() {
      // Atualizar valor exibido
      document.getElementById('opacity-value').textContent = this.value;
      
      refreshPreview();
      saveUserConfig();
    });
    
    document.getElementById('palette-invert').addEventListener('change', function() {
      // Limpar cores personalizadas antes de aplicar nova paleta
      const field = document.getElementById('field-select').value;
      clearCustomColors(field);
      
      updatePalettePreview();
      createCategoryColorInterface([]);
      
      // Se for simbologia graduada, atualizar interface de classes
      if (document.getElementById('style-type').value === 'graduated') {
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      }
      
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listener para legenda composta
    document.getElementById('composite-legend-toggle').addEventListener('change', function() {
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listeners para simbologia graduada
    document.getElementById('classes').addEventListener('change', function() {
      refreshPreview();
      
      // Se for simbologia graduada, atualizar interface de classes
      if (document.getElementById('style-type').value === 'graduated') {
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      }
      
      saveUserConfig();
    });
    
    document.getElementById('method').addEventListener('change', function() {
      applyVisibility();
      refreshPreview();
      
      // Se for simbologia graduada, atualizar interface de classes
      if (document.getElementById('style-type').value === 'graduated') {
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      }
      
      // Atualizar informações do método
      showMethodInfo();
      
      saveUserConfig();
    });
    
    // Event listener para breaks manuais
    document.getElementById('manual-breaks').addEventListener('input', function() {
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listeners para campos personalizados
    ['stroke-color', 'fill-color', 'stroke-weight', 'fill-opacity', 'point-radius', 'line-opacity', 'line-dash'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de polígono
    ['polygon-border-color', 'polygon-border-width', 'polygon-border-toggle'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de classificação
    ['classes', 'manual-breaks'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', function() {
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de rótulos
    ['labels-enabled', 'label-field-select', 'label-font', 'label-size', 'label-color', 'label-bold', 'label-italic', 'label-buffer-color', 'label-buffer-size', 'label-buffer-opacity', 'label-offset-x', 'label-offset-y'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listener específico para o slider de opacidade do buffer
    document.getElementById('label-buffer-opacity').addEventListener('input', function() {
      document.getElementById('buffer-opacity-value').textContent = this.value;
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listener para botão de aplicar simbologia
    document.getElementById('btn-apply').addEventListener('click', async function() {
      const style = computeStyle();
      
      if (!style.field) {
        showToast('Por favor, selecione um campo para simbologia.', 'warning');
        return;
      }
      
      try {
        // Salvar configurações do usuário antes de aplicar
        saveUserConfig();
        
        // Usar a função que já tem toda a lógica implementada
        const config = {
          field: style.field,
          styleType: style.type || 'graduated'
        };
        
        const success = await saveSymbologyToDatabase(config);
        
        if (!success) {
          showToast('Erro ao aplicar simbologia no portal', 'error');
        }
      } catch (error) {
        console.error('Erro ao aplicar simbologia:', error);
        showToast('Erro ao aplicar simbologia. Verifique o console para mais detalhes.', 'error');
      }
    });

    // Event listener para botão de aplicar rótulos
    document.getElementById('btn-apply-labels').addEventListener('click', async function() {
      const labelConfig = {
        field: document.getElementById('label-field-select').value,
        font: document.getElementById('label-font').value,
        size: parseInt(document.getElementById('label-size').value),
        color: document.getElementById('label-color').value,
        bold: document.getElementById('label-bold').checked,
        italic: document.getElementById('label-italic').checked,
        bufferColor: document.getElementById('label-buffer-color').value,
        bufferSize: parseInt(document.getElementById('label-buffer-size').value),
        bufferOpacity: parseFloat(document.getElementById('label-buffer-opacity').value),
        offsetX: parseInt(document.getElementById('label-offset-x').value),
        offsetY: parseInt(document.getElementById('label-offset-y').value),
        enabled: document.getElementById('labels-enabled').checked
      };

      if (!labelConfig.field) {
        alert('Por favor, selecione um campo para rótulos.');
        return;
      }

      try {
        saveUserConfig(); // Salvar configurações gerais

        const response = await fetch(`/admin/layer/${layerId}/labels/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(labelConfig)
        });

        if (response.ok) {
          alert('Configurações de rótulos aplicadas com sucesso!');
          refreshPreview(); // Atualizar preview com novas configurações de rótulos
        } else {
          const error = await response.json();
          alert(`Erro ao aplicar configurações de rótulos: ${error.error || 'Erro desconhecido'}`);
        }
      } catch (error) {
        console.error('Erro ao aplicar configurações de rótulos:', error);
        alert('Erro ao aplicar configurações de rótulos. Verifique o console para mais detalhes.');
      }
    });
    
    // Selecionar primeira paleta por padrão (Viridis)
    document.getElementById('palette-select').value = 'Viridis';
    
    // Event listeners para gerenciamento de paletas personalizadas
    document.getElementById('btn-create-palette').addEventListener('click', createNewPalette);
    document.getElementById('btn-save-current-palette').addEventListener('click', saveCurrentPalette);
    document.getElementById('btn-manage-palettes').addEventListener('click', managePalettes);
    
    // Carregar paletas personalizadas ao inicializar
    loadCustomPalettes();
  });

  // Função para aplicar estilo graduado
  function applyGraduatedStyle(layer, style) {
    if (!layerData || !style.field) return;
    
    // Coletar valores do campo selecionado
    const values = layerData.features
      .map(f => parseFloat(f.properties[style.field]))
      .filter(v => !isNaN(v))
      .sort((a, b) => a - b);
    
    if (values.length === 0) return;
    
    const min = values[0];
    const max = values[values.length - 1];
    const classes = style.classes || 5;
    
    // Gerar breaks baseado no método
    let breaks = [];
    if (style.method === 'equal') {
      // Equal Interval
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    } else if (style.method === 'quantile') {
      // Quantiles
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'jenks') {
      // Jenks Natural Breaks (simplificado)
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'log') {
      // Logarithmic
      const logMin = Math.log(Math.max(min, 0.1));
      const logMax = Math.log(max);
      const step = (logMax - logMin) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(Math.exp(logMin + (i * step)));
      }
    } else if (style.method === 'stddev') {
      // Standard Deviation
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
      const stddev = Math.sqrt(variance);
      
      // Criar classes baseadas em desvios padrão
      const stddevStep = (2 * stddev) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(mean - stddev + (i * stddevStep));
      }
    } else if (style.method === 'arithmetic') {
      // Arithmetic Progression
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    } else if (style.method === 'geometric') {
      // Geometric Progression
      const ratio = Math.pow(max / min, 1 / classes);
      for (let i = 0; i <= classes; i++) {
        breaks.push(min * Math.pow(ratio, i));
      }
    } else if (style.method === 'manual' && style.breaks) {
      breaks = style.breaks;
    }
    
    // Gerar cores da paleta
    const palette = style.palette || 'Blues';
    const colors = brewer(palette, classes, style.palette_invert);
    
    // Carregar cores personalizadas se disponíveis
    const customColors = [];
    for (let i = 0; i < classes; i++) {
      const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
      customColors.push(savedColor || colors[i]);
    }
    
    // Aplicar estilo a cada feature
    layer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.properties) {
        const value = parseFloat(featureLayer.feature.properties[style.field]);
        if (isNaN(value)) return;
        
        // Encontrar classe para o valor
        let colorIndex = 0;
        for (let i = 0; i < breaks.length - 1; i++) {
          if (value >= breaks[i] && value < breaks[i + 1]) {
            colorIndex = i;
            break;
          }
        }
        
        // Aplicar cor
        const color = customColors[colorIndex] || customColors[0];
        
        // Configurar estilo base
        const layerStyle = {
          fillColor: color,
          fillOpacity: style.palette_opacity || 1.0
        };
        
        // Aplicar configurações de borda se for polígono
        if (style.geometry_type === 'polygon') {
          if (style.border_color && style.border_width > 0) {
            layerStyle.color = style.border_color;
            layerStyle.weight = style.border_width;
          } else {
            // Se não quiser borda, definir como transparente
            layerStyle.color = 'transparent';
            layerStyle.weight = 0;
          }
        } else {
          // Para pontos e linhas, usar configurações padrão
          layerStyle.color = style.border_color || '#333333';
          layerStyle.weight = style.border_width || 1;
        }
        
        console.log('Aplicando estilo ao feature:', layerStyle);
        featureLayer.setStyle(layerStyle);
      }
    });
    
    // Log de execução da função
    console.log('applyGraduatedStyle executada com sucesso');
    
    // Atualizar legenda após aplicar o estilo
    setTimeout(() => {
      renderPreview();
    }, 100);
  }
</script>
{% endblock %}