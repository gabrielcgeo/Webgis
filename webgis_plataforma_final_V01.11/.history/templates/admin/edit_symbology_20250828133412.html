{% extends 'layout.html' %}
{% block content %}
<!-- Adicionar dados da empresa para JavaScript -->
<div id="company-data" data-company-slug="{{ current_user.company.slug if current_user.company else 'amplo' }}" style="display: none;"></div>

<style>
  #symbology-map {
    height: 50vh !important;
    min-height: 400px !important;
    width: 100% !important;
    z-index: 1;
    position: relative;
  }
  
  .leaflet-container {
    height: 100% !important;
    width: 100% !important;
  }
  
  .leaflet-control-attribution {
    font-size: 10px;
  }
  
  #palette-colors {
    flex-wrap: wrap;
  }
  
  #palette-colors div {
    margin-bottom: 5px;
  }
  
  .palette-preview-container {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 15px;
    margin-bottom: 15px;
  }
  
  /* Caixa explicativa compacta e horizontal - sempre visível */
  .method-info-compact {
    display: flex;
    align-items: flex-start;
    gap: 15px;
    padding: 16px 20px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e3f2fd 100%);
    border: 1px solid #0dcaf0;
    border-left: 4px solid #0dcaf0;
    border-radius: 8px;
    margin-top: 15px;
    margin-bottom: 20px;
    margin-left: 0;
    margin-right: 0;
    font-size: 0.8rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    width: 100%; /* Ocupa toda a largura da coluna col-md-12 */
    max-width: 100%;
    position: relative;
    left: 0;
    grid-column: 1 / -1; /* Estende por todas as colunas do grid */
    z-index: 10; /* Garante que fique acima de outros elementos */
    box-sizing: border-box; /* Inclui padding e border na largura total */
  }
  
  .method-info-compact .method-icon {
    font-size: 1rem;
    color: #0dcaf0;
    flex-shrink: 0;
  }
  
  .method-info-compact .method-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(13, 202, 240, 0.2);
  }
  
  .method-info-compact .method-title-section {
    flex: 1;
  }
  
  .method-info-compact .method-title {
    font-weight: 700;
    color: #0c63e4;
    margin-bottom: 4px;
    font-size: 1rem;
    letter-spacing: 0.5px;
  }
  
  .method-info-compact .method-description {
    color: #495057;
    line-height: 1.4;
    font-size: 0.85rem;
    font-style: italic;
  }
  
  .method-info-compact .method-content-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    width: 100%;
  }
  
  .method-info-compact .method-detail-card {
    background: rgba(255, 255, 255, 0.7);
    border-radius: 6px;
    padding: 12px;
    border: 1px solid rgba(13, 202, 240, 0.15);
    transition: all 0.2s ease;
  }
  
  .method-info-compact .method-detail-card:hover {
    background: rgba(255, 255, 255, 0.9);
    border-color: rgba(13, 202, 240, 0.3);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  
  .method-info-compact .detail-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  
  .method-info-compact .detail-icon {
    font-size: 1rem;
    flex-shrink: 0;
  }
  
  .method-info-compact .detail-label {
    font-weight: 600;
    color: #0c63e4;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .method-info-compact .detail-text {
    color: #495057;
    font-size: 0.75rem;
    line-height: 1.4;
  }
  
  /* Ajuste para responsividade - comporta-se como col-md-12 */
  @media (max-width: 1200px) {
    .method-info-compact {
      margin-left: 0;
      margin-right: 0;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }
  }
  
  @media (max-width: 768px) {
    .method-info-compact {
      margin-left: 0;
      margin-right: 0;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
    }
  }
  
  /* Garante que a caixa se comporte exatamente como uma col-md-12 */
  .method-info-compact {
    flex: 0 0 100%;
    flex-basis: 100%;
    margin-left: 0;
    margin-right: 0;
  }

  /* Estilos para controles de linha avançados */
  .line-controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 15px;
    margin-top: 10px;
  }
  
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  
  .control-group label {
    font-size: 0.8rem;
    font-weight: 600;
    color: #495057;
    margin-bottom: 0;
  }
  
  .control-group input,
  .control-group select {
    font-size: 0.8rem;
    padding: 0.375rem 0.5rem;
  }
  
  .line-spacing-controls {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    padding: 10px;
    margin-top: 10px;
  }
  
  .line-preview-element {
    transition: all 0.3s ease;
  }
  
  /* Estilos para o select customizado de paletas */
  .custom-palette-select {
    position: relative;
    width: 100%;
  }

  .palette-select-header {
    background: #fff;
    border: 1px solid #ced4da;
    border-radius: 0.375rem;
    padding: 0.75rem 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
  }

  .palette-select-header:hover {
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
  }

  .palette-select-header:active {
    background-color: #f8f9fa;
  }

  .palette-select-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: #fff;
    border: 1px solid #ced4da;
    border-radius: 0.375rem;
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    z-index: 1000;
    max-height: 400px;
    overflow-y: auto;
  }

  .palette-options {
    padding: 0.5rem 0;
  }

  .palette-optgroup {
    margin-bottom: 1rem;
  }

  .palette-optgroup-label {
    padding: 0.5rem 1rem;
    font-weight: 600;
    color: #6c757d;
    background-color: #f8f9fa;
    border-bottom: 1px solid #dee2e6;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .palette-option {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    cursor: pointer;
    transition: background-color 0.15s ease;
    border-bottom: 1px solid #f8f9fa;
  }

  .palette-option:hover {
    background-color: #f8f9fa;
  }

  .palette-option:last-child {
    border-bottom: none;
  }

  .palette-preview-mini {
    width: 60px;
    height: 20px;
    border-radius: 4px;
    border: 1px solid #dee2e6;
    flex-shrink: 0;
    background: linear-gradient(to right, var(--color1), var(--color2), var(--color3), var(--color4), var(--color5), var(--color6), var(--color7), var(--color8));
  }

  .palette-option span {
    font-size: 0.875rem;
    color: #495057;
    flex: 1;
  }

  /* Filtros para diferentes tipos de simbologia */
  .palette-optgroup[data-type="qualitative"] {
    display: none;
  }

  .palette-optgroup[data-type="qualitative"].show-for-graduated {
    display: block;
  }
  
  /* Filtro para simbologia categorizada */
  .palette-optgroup[data-type="sequential"].show-for-categorized,
  .palette-optgroup[data-type="divergent"].show-for-categorized {
    display: none !important;
  }
  
  .palette-optgroup[data-type="qualitative"].show-for-categorized,
  .palette-optgroup[data-type="custom"].show-for-categorized {
    display: block !important;
  }
  
  /* Filtro para simbologia única */
  .palette-optgroup.show-for-single {
    display: block !important;
  }
  
  /* ===== MODAL DE CONFIRMAÇÃO CUSTOMIZADO ===== */
  .confirm-dialog-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    animation: fadeIn 0.3s ease-out;
  }
  
  .confirm-dialog-content {
    background: linear-gradient(135deg, #ffffff, #f8f9fa);
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    width: 90%;
    max-width: 450px;
    position: relative;
    animation: slideInScale 0.4s ease-out;
    border: 2px solid var(--bs-primary);
  }
  
  .confirm-dialog-header {
    background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary));
    color: white;
    padding: 20px 25px;
    border-radius: 18px 18px 0 0;
    text-align: center;
    border-bottom: 3px solid #ffd700;
  }
  
  .confirm-dialog-header i {
    font-size: 32px;
    color: #ffd700;
    margin-bottom: 10px;
    display: block;
  }
  
  .confirm-dialog-header h4 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
    color: white;
  }
  
  .confirm-dialog-body {
    padding: 25px;
    text-align: center;
  }
  
  .confirm-dialog-body p {
    margin: 0;
    font-size: 16px;
    line-height: 1.5;
    color: #333;
  }
  
  .confirm-dialog-body strong {
    color: var(--bs-primary);
    font-weight: 700;
  }
  
  .confirm-dialog-footer {
    padding: 20px 25px;
    display: flex;
    gap: 15px;
    justify-content: center;
    border-top: 1px solid #e9ecef;
    background: #f8f9fa;
    border-radius: 0 0 18px 18px;
  }
  
  .confirm-dialog-footer button {
    padding: 12px 24px;
    border: none;
    border-radius: 25px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 120px;
    justify-content: center;
  }
  
  .confirm-dialog-footer .btn-cancel {
    background: #6c757d;
    color: white;
  }
  
  .confirm-dialog-footer .btn-cancel:hover {
    background: #5a6268;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
  }
  
  .confirm-dialog-footer .btn-confirm {
    background: var(--bs-primary);
    color: white;
  }
  
  .confirm-dialog-footer .btn-confirm:hover {
    background: #0056b3;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 123, 255, 0.4);
  }
  
  .confirm-dialog-footer button:active {
    transform: translateY(0);
  }
  
  /* ===== MODAL DE CRIAÇÃO DE PALETAS PERSONALIZADAS ===== */
  .custom-palette-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    animation: fadeIn 0.3s ease-out;
  }
  
  .custom-palette-modal-content {
    background: linear-gradient(135deg, #ffffff, #f8f9fa);
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    width: 90%;
    max-width: 800px;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
    animation: slideInScale 0.4s ease-out;
  }
  
  .custom-palette-modal-header {
    background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary));
    color: white;
    padding: 25px 30px;
    border-radius: 20px 20px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .custom-palette-modal-header h3 {
    margin: 0;
    font-size: 24px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .custom-palette-modal-header h3 i {
    font-size: 28px;
    color: #ffd700;
  }
  
  .btn-close-modal {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .btn-close-modal:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
  }
  
  .custom-palette-modal-body {
    padding: 30px;
  }
  
  .form-group {
    margin-bottom: 25px;
  }
  
  .form-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #333;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .form-group label i {
    color: var(--bs-primary);
    width: 16px;
  }
  
  .form-group input,
  .form-group select,
  .form-group textarea {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid #e9ecef;
    border-radius: 10px;
    font-size: 14px;
    transition: all 0.3s ease;
    background: white;
  }
  
  .form-group input:focus,
  .form-group select:focus,
  .form-group textarea:focus {
    outline: none;
    border-color: var(--bs-primary);
    box-shadow: 0 0 0 3px rgba(var(--bs-primary-rgb), 0.1);
  }
  
  .form-group textarea {
    resize: vertical;
    min-height: 60px;
  }
  
  /* Controles de quantidade de cores */
  .color-count-controls {
    display: flex;
    align-items: center;
    gap: 15px;
    background: #f8f9fa;
    padding: 15px;
    border-radius: 10px;
    border: 2px solid #e9ecef;
  }
  
  .btn-count {
    background: var(--bs-primary);
    color: white;
    border: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .btn-count:hover {
    background: var(--bs-primary);
    filter: brightness(0.9);
    transform: scale(1.1);
  }
  
  .btn-count:disabled {
    background: #6c757d;
    cursor: not-allowed;
    transform: none;
  }
  
  #color-count-display {
    font-size: 24px;
    font-weight: bold;
    color: var(--bs-primary);
    min-width: 30px;
    text-align: center;
  }
  
  .color-count-info {
    color: #6c757d;
    font-size: 12px;
    font-style: italic;
  }
  
  /* Preview da paleta personalizada */
  .palette-preview-container {
    background: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 15px;
    padding: 20px;
    margin-top: 15px;
  }
  
  .palette-preview {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
    min-height: 40px;
    align-items: center;
  }
  
  .preview-color {
    width: 30px;
    height: 30px;
    border-radius: 8px;
    border: 2px solid white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
  }
  
  .preview-color:hover {
    transform: scale(1.2);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.25);
    z-index: 10;
  }
  
  .preview-color::after {
    content: attr(title);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 5px 8px;
    border-radius: 4px;
    font-size: 11px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 1000;
  }
  
  .preview-color:hover::after {
    opacity: 1;
  }
  
  .palette-preview-info {
    text-align: center;
    padding-top: 10px;
    border-top: 1px solid #e9ecef;
  }
  
  .palette-preview-info small {
    color: #6c757d;
    font-size: 12px;
  }
  
  /* Container de cores */
  #palette-colors-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    margin-top: 15px;
    max-height: 400px;
    overflow-y: auto;
    padding-right: 10px;
  }
  
  /* Scrollbar personalizada para o container de cores */
  #palette-colors-container::-webkit-scrollbar {
    width: 8px;
  }
  
  #palette-colors-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }
  
  #palette-colors-container::-webkit-scrollbar-thumb {
    background: var(--bs-primary);
    border-radius: 4px;
  }
  
  #palette-colors-container::-webkit-scrollbar-thumb:hover {
    background: var(--bs-primary);
    filter: brightness(0.8);
  }
  
  .palette-color-item {
    background: white;
    border: 2px solid #e9ecef;
    border-radius: 15px;
    padding: 20px;
    transition: all 0.3s ease;
  }
  
  .palette-color-item:hover {
    border-color: var(--bs-primary);
    box-shadow: 0 5px 20px rgba(var(--bs-primary-rgb), 0.1);
    transform: translateY(-2px);
  }
  
  .color-item-header {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #e9ecef;
  }
  
  .color-number {
    font-weight: 600;
    color: #333;
    font-size: 16px;
    text-align: center;
  }
  
  .color-inputs {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  
  .color-input-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  
  .color-input-group label {
    font-size: 12px;
    font-weight: 600;
    color: #666;
    margin: 0;
  }
  
  .color-input-group input {
    padding: 8px 12px;
    font-size: 13px;
  }
  
  .rgb-inputs {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
  }
  
  .rgb-inputs input {
    text-align: center;
    font-size: 12px;
    padding: 6px 8px;
  }
  
  /* Ferramentas rápidas */
  .quick-tools {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
    margin-top: 15px;
  }
  
  .btn-quick-tool {
    background: linear-gradient(135deg, #6c757d, #495057);
    color: white;
    border: none;
    padding: 12px 16px;
    border-radius: 10px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  
  .btn-quick-tool:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
  }
  
  .btn-quick-tool[data-action="generate-harmonious"] {
    background: linear-gradient(135deg, #28a745, #20c997);
  }
  
  .btn-quick-tool[data-action="generate-gradient"] {
    background: linear-gradient(135deg, #fd7e14, #e83e8c);
  }
  
  .btn-quick-tool[data-action="randomize"] {
    background: linear-gradient(135deg, #6f42c1, #e83e8c);
  }
  
  .btn-quick-tool[data-action="clear-all"] {
    background: linear-gradient(135deg, #dc3545, #c82333);
  }
  
  /* Footer do modal */
  .custom-palette-modal-footer {
    background: #f8f9fa;
    padding: 25px 30px;
    border-radius: 0 0 20px 20px;
    display: flex;
    justify-content: flex-end;
    gap: 15px;
    border-top: 1px solid #e9ecef;
  }
  
  .custom-palette-modal-footer .btn {
    padding: 12px 24px;
    border-radius: 10px;
    font-weight: 600;
    font-size: 14px;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .custom-palette-modal-footer .btn-secondary {
    background: #6c757d;
    color: white;
  }
  
  .custom-palette-modal-footer .btn-secondary:hover {
    background: #5a6268;
    transform: translateY(-1px);
  }
  
  .custom-palette-modal-footer .btn-primary {
    background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary));
    color: white;
  }
  
  .custom-palette-modal-footer .btn-primary:hover {
    background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary));
    filter: brightness(0.9);
    transform: translateY(-1px);
    box-shadow: 0 5px 15px rgba(var(--bs-primary-rgb), 0.3);
  }
  
  /* Animações */
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes slideInScale {
    from {
      opacity: 0;
      transform: scale(0.9) translateY(-20px);
    }
    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }
  
  @keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }
  
  @keyframes slideOutScale {
    from {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
    to {
      opacity: 0;
      transform: scale(0.9) translateY(-20px);
    }
  }
  
  /* Responsividade */
  @media (max-width: 768px) {
    .custom-palette-modal-content {
      width: 95%;
      margin: 20px;
    }
    
    .custom-palette-modal-header {
      padding: 20px;
    }
    
    .custom-palette-modal-header h3 {
      font-size: 20px;
    }
  
    .custom-palette-modal-body {
      padding: 20px;
    }
    
    #palette-colors-container {
      grid-template-columns: 1fr;
      max-height: 300px;
    }
    
    .quick-tools {
      grid-template-columns: repeat(2, 1fr);
    }
    
    .custom-palette-modal-footer {
      flex-direction: column;
      padding: 20px;
    }
  }
  
  /* Para muitas cores, ajustar o grid */
  @media (min-width: 1200px) {
    #palette-colors-container {
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    }
  }
  
  /* Para telas muito pequenas */
  @media (max-width: 480px) {
    #palette-colors-container {
      grid-template-columns: 1fr;
      max-height: 250px;
    }
    
    .palette-color-item {
      padding: 15px;
    }
    
    .rgb-inputs {
      grid-template-columns: 1fr;
      gap: 5px;
    }
    
    .palette-preview-container {
      padding: 15px;
    }
    
    .preview-color {
      width: 25px;
      height: 25px;
    }
  }
  
  /* Animações para os modais */
  @keyframes modalSlideIn {
    from {
      opacity: 0;
      transform: translateY(-50px) scale(0.9);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }
  
  /* Estilos para os modais */
  .save-palette-modal,
  .manage-palettes-modal,
  .custom-palette-modal {
    animation: modalSlideIn 0.3s ease-out;
  }
  
  /* Hover effects para botões */
  .save-palette-modal button:hover,
  .manage-palettes-modal button:hover,
  .custom-palette-modal button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }
  
  /* Transições suaves */
  .save-palette-modal *,
  .manage-palettes-modal *,
  .custom-palette-modal * {
    transition: all 0.2s ease;
  }
  
  /* Scrollbar personalizada para os modais */
  .save-palette-modal ::-webkit-scrollbar,
  .manage-palettes-modal ::-webkit-scrollbar,
  .custom-palette-modal ::-webkit-scrollbar {
    width: 8px;
  }
  
  .save-palette-modal ::-webkit-scrollbar-track,
  .manage-palettes-modal ::-webkit-scrollbar-track,
  .custom-palette-modal ::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }
  
  .save-palette-modal ::-webkit-scrollbar-thumb,
  .manage-palettes-modal ::-webkit-scrollbar-thumb,
  .custom-palette-modal ::-webkit-scrollbar-thumb {
    background: var(--bs-primary);
    border-radius: 4px;
  }
  
  .save-palette-modal ::-webkit-scrollbar-thumb:hover,
  .manage-palettes-modal ::-webkit-scrollbar-thumb:hover,
  .custom-palette-modal ::-webkit-scrollbar-thumb:hover {
    background: var(--bs-primary-rgb, 0.8);
  }
  
  /* Estilos para interface de classes categorizadas */
  .categorized-class-item {
    transition: all 0.2s ease;
    border: 2px solid transparent;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .categorized-class-item:hover {
    border-color: #007bff;
    box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2);
  }
  
  .categorized-class-item.dragging {
    opacity: 0.5;
    transform: rotate(5deg);
    z-index: 1000;
  }
  
  .drag-handle {
    cursor: move;
    color: #6c757d;
    transition: color 0.2s ease;
  }
  
  .drag-handle:hover {
    color: #007bff;
  }
  
  .color-preview {
    transition: all 0.2s ease;
    cursor: pointer;
  }
  
  .color-preview:hover {
    transform: scale(1.1);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  }
  
  .categorized-class-rgb-inputs {
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    background: rgba(0,0,0,0.05);
    border-radius: 0.25rem;
    margin-top: 0.25rem;
  }
  
  /* ========================================
     ESTRUTURA ORGANIZADA DAS CLASSES
     ======================================== */
  
  /* Header da categoria com drag handle */
  .category-header {
    border-bottom: 1px solid #e9ecef;
    padding-bottom: 0.75rem;
    margin-bottom: 1rem;
    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
    border-radius: 0.5rem 0.5rem 0 0;
    padding: 1rem;
    margin: -0.75rem -0.75rem 1rem -0.75rem;
  }
  
  /* Seções de controle organizadas */
  .control-section {
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    border: 1px solid #e9ecef;
    border-radius: 0.75rem;
    padding: 1rem;
    margin-bottom: 1rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    transition: all 0.3s ease;
  }
  
  .control-section:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border-color: #007bff;
  }
  
  .control-section.color-section {
    border-left: 4px solid #007bff;
  }
  
  .control-section.line-section {
    border-left: 4px solid #28a745;
  }
  
  /* Header das seções */
  .section-header {
    color: #495057;
    border-bottom: 2px solid #dee2e6;
    padding-bottom: 0.5rem;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  
  .section-header i {
    font-size: 1rem;
    color: #007bff;
  }
  
  .section-header .small {
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  /* Grid responsivo para controles de linha */
  .line-controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 1.25rem;
    align-items: start;
    padding: 0.5rem;
    background: rgba(40, 167, 69, 0.05);
    border-radius: 0.5rem;
    border: 1px solid rgba(40, 167, 69, 0.2);
  }
  
  /* Grupos de controle */
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 0.75rem;
    background: #ffffff;
    border-radius: 0.5rem;
    border: 1px solid #e9ecef;
    transition: all 0.2s ease;
  }
  
  .control-group:hover {
    border-color: #007bff;
    box-shadow: 0 2px 6px rgba(0,123,255,0.1);
  }
  
  .control-group label {
    font-weight: 600;
    color: #495057;
    font-size: 0.875rem;
    margin-bottom: 0.25rem;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }
  
  /* Controles específicos */
  .control-group input,
  .control-group select {
    border: 2px solid #e9ecef;
    border-radius: 0.375rem;
    transition: all 0.2s ease;
    font-size: 0.875rem;
  }
  
  .control-group input:focus,
  .control-group select:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
    outline: none;
  }
  
  /* Controles de linha específicos */
  .line-control-individual {
    border-color: #28a745 !important;
  }
  
  .line-control-individual:focus {
    border-color: #28a745 !important;
    box-shadow: 0 0 0 3px rgba(40,167,69,0.1) !important;
  }
  
  /* ========================================
     CONTROLES DE LINHA E ESPAÇAMENTO
     ======================================== */
  
  /* Controles de linha organizados */
  .line-controls {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-wrap: wrap;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(0,123,255,0.08) 0%, rgba(0,123,255,0.03) 100%);
    border-radius: 0.75rem;
    margin-top: 0.5rem;
    border: 1px solid rgba(0,123,255,0.2);
    transition: all 0.3s ease;
  }
  
  .line-controls:hover {
    background: linear-gradient(135deg, rgba(0,123,255,0.12) 0%, rgba(0,123,255,0.05) 100%);
    border-color: rgba(0,123,255,0.3);
  }
  
  /* Slider de espaçamento melhorado */
  .line-spacing-slider {
    height: 6px;
    border-radius: 3px;
    background: linear-gradient(90deg, #e9ecef 0%, #dee2e6 100%);
    outline: none;
    border: none;
    transition: all 0.2s ease;
  }
  
  .line-spacing-slider:hover {
    background: linear-gradient(90deg, #007bff 0%, #0056b3 100%);
  }
  
  .line-spacing-slider::-webkit-slider-thumb {
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
    cursor: pointer;
    border: 3px solid #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    transition: all 0.2s ease;
  }
  
  .line-spacing-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }
  
  .line-spacing-slider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
    cursor: pointer;
    border: 3px solid #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    transition: all 0.2s ease;
  }
  
  .line-spacing-slider::-moz-range-thumb:hover {
    transform: scale(1.2);
  }
  
  .line-spacing-slider:focus::-webkit-slider-thumb {
    background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
    box-shadow: 0 0 0 4px rgba(0,123,255,0.3);
  }
  
  .line-spacing-slider:focus::-moz-range-thumb {
    background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
    box-shadow: 0 0 0 4px rgba(0,123,255,0.3);
  }
  
  /* Valor do espaçamento */
  .line-spacing-value {
    font-weight: 600;
    color: #495057;
    background: rgba(0,123,255,0.1);
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    border: 1px solid rgba(0,123,255,0.2);
    min-width: 45px;
    text-align: center;
    font-size: 0.875rem;
  }
  
  /* Controles de espaçamento */
  .line-spacing-controls {
    transition: all 0.3s ease;
    padding: 0.75rem;
    background: rgba(40,167,69,0.05);
    border-radius: 0.5rem;
    border: 1px solid rgba(40,167,69,0.2);
  }
  
  .line-spacing-controls.hidden {
    display: none !important;
  }
  
  /* ========================================
     BOTÕES E CONTROLES DE COR
     ======================================== */
  
  /* Controles de linha em linha */
  .row-controls {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-wrap: wrap;
    padding: 0.5rem;
    background: rgba(0,0,0,0.02);
    border-radius: 0.5rem;
    border: 1px solid #e9ecef;
  }
  
  /* Botão de remover categoria */
  .remove-category-btn {
    transition: all 0.3s ease;
    border-radius: 0.5rem;
    padding: 0.5rem 0.75rem;
    font-weight: 500;
    border: 2px solid #dc3545;
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    color: #dc3545;
  }
  
  .remove-category-btn:hover {
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
    border-color: #c82333;
    color: white;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
  }
  
  .remove-category-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 6px rgba(220, 53, 69, 0.3);
  }
  
  /* Botões de controle de cor */
  .categorized-class-rgb-btn,
  .graduated-class-rgb-btn {
    transition: all 0.3s ease;
    border-radius: 0.5rem;
    padding: 0.5rem 0.75rem;
    font-weight: 500;
    border: 2px solid #6c757d;
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    color: #6c757d;
    font-size: 0.875rem;
  }
  
  .categorized-class-rgb-btn:hover,
  .graduated-class-rgb-btn:hover {
    background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
    border-color: #5a6268;
    color: white;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
  }
  
  .categorized-class-rgb-btn.btn-secondary,
  .graduated-class-rgb-btn.btn-secondary {
    background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
    border-color: #5a6268;
    color: white;
  }
  
  /* Controles de cor */
  .categorized-class-color,
  .graduated-class-color {
    border: 3px solid #e9ecef;
    border-radius: 0.5rem;
    transition: all 0.3s ease;
    cursor: pointer;
  }
  
  .categorized-class-color:hover,
  .graduated-class-color:hover {
    border-color: #007bff;
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(0,123,255,0.3);
  }
  
  .categorized-class-color:focus,
  .graduated-class-color:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 4px rgba(0,123,255,0.2);
    outline: none;
  }
  
  /* Campos de entrada de cor */
  .categorized-class-hex,
  .graduated-class-hex {
    border: 2px solid #e9ecef;
    border-radius: 0.5rem;
    transition: all 0.3s ease;
    font-family: 'Courier New', monospace;
    font-weight: 600;
  }
  
  .categorized-class-hex:focus,
  .graduated-class-hex:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
    outline: none;
  }
  
  /* Campos RGB */
  .categorized-class-rgb-inputs,
  .graduated-class-rgb-inputs {
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 1rem;
    background: linear-gradient(135deg, rgba(0,0,0,0.05) 0%, rgba(0,0,0,0.02) 100%);
    border-radius: 0.75rem;
    margin-top: 0.5rem;
    border: 1px solid #e9ecef;
  }
  
  .categorized-class-rgb-inputs input,
  .graduated-class-rgb-inputs input {
    border: 2px solid #e9ecef;
    border-radius: 0.375rem;
    transition: all 0.2s ease;
    text-align: center;
    font-weight: 600;
    font-family: 'Courier New', monospace;
  }
  
  .categorized-class-rgb-inputs input:focus,
  .graduated-class-rgb-inputs input:focus {
    border-color: #007bff;
    box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
    outline: none;
  }
  
  /* Drop zone visual feedback */
  .category-list {
    min-height: 100px;
    padding: 1rem;
    border: 2px dashed transparent;
    transition: all 0.3s ease;
    border-radius: 0.75rem;
    background: rgba(0,0,0,0.01);
  }
  
  .category-list.drag-over {
    border-color: #007bff;
    background: linear-gradient(135deg, rgba(0,123,255,0.08) 0%, rgba(0,123,255,0.03) 100%);
    box-shadow: 0 4px 12px rgba(0,123,255,0.1);
  }
  
  /* Lista de classes graduadas */
  .graduated-classes-list {
    min-height: 100px;
    padding: 1rem;
    border: 2px dashed transparent;
    transition: all 0.3s ease;
    border-radius: 0.75rem;
    background: rgba(0,0,0,0.01);
  }
  
  .graduated-classes-list.drag-over {
    border-color: #28a745;
    background: linear-gradient(135deg, rgba(40,167,69,0.08) 0%, rgba(40,167,69,0.03) 100%);
    box-shadow: 0 4px 12px rgba(40,167,69,0.1);
  }
  
  /* ========================================
     PROPRIEDADES DA LINHA PARA SIMBOLOGIA GRADUADA
     ======================================== */
  
  /* Container das propriedades de linha */
  .graduated-line-properties {
    background: linear-gradient(135deg, rgba(40,167,69,0.08) 0%, rgba(40,167,69,0.03) 100%);
    border: 1px solid rgba(40,167,69,0.2);
    border-radius: 0.75rem;
    padding: 0.75rem;
    transition: all 0.3s ease;
    flex-wrap: wrap;
    gap: 1rem;
  }
  
  .graduated-line-properties:hover {
    background: linear-gradient(135deg, rgba(40,167,69,0.12) 0%, rgba(40,167,69,0.05) 100%);
    border-color: rgba(40,167,69,0.3);
    box-shadow: 0 2px 8px rgba(40,167,69,0.1);
  }
  
  /* Itens de propriedade individual */
  .line-property-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    background: #ffffff;
    border-radius: 0.5rem;
    border: 1px solid #e9ecef;
    transition: all 0.2s ease;
    min-width: 80px;
  }
  
  .line-property-item:hover {
    border-color: #28a745;
    box-shadow: 0 2px 6px rgba(40,167,69,0.1);
    transform: translateY(-1px);
  }
  
  .line-property-item label {
    font-weight: 600;
    color: #495057;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.3px;
    text-align: center;
    margin-bottom: 0;
  }
  
  /* Controles específicos */
  .line-property-item input,
  .line-property-item select {
    border: 2px solid #e9ecef;
    border-radius: 0.375rem;
    transition: all 0.2s ease;
    font-size: 0.875rem;
    text-align: center;
  }
  
  .line-property-item input:focus,
  .line-property-item select:focus {
    border-color: #28a745;
    box-shadow: 0 0 0 3px rgba(40,167,69,0.1);
    outline: none;
  }
  
  /* Controle de espaçamento específico */
  .line-property-item.graduated-line-spacing-controls {
    min-width: 120px;
  }
  
  .line-property-item.graduated-line-spacing-controls .d-flex {
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
  }
  
  .line-property-item.graduated-line-spacing-controls .graduated-line-spacing-value {
    background: rgba(40,167,69,0.1);
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    border: 1px solid rgba(40,167,69,0.2);
    min-width: 45px;
    text-align: center;
    font-size: 0.75rem;
    font-weight: 600;
  }
  
  /* Responsividade para propriedades de linha */
  @media (max-width: 768px) {
    .graduated-line-properties {
      flex-direction: column;
      align-items: stretch;
    }
    
    .line-property-item {
      min-width: auto;
      width: 100%;
    }
  }

  /* Estilos para o Modal de Propriedades da Linha Graduada */
  #graduatedLinePropertiesModal .modal-dialog {
    max-width: 800px;
  }
  
  #graduatedLinePropertiesModal .modal-content {
    border: none;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
  }
  
  #graduatedLinePropertiesModal .modal-header {
    background: linear-gradient(135deg, #0dcaf0 0%, #0b5ed7 100%);
    color: white;
    border-bottom: none;
    border-radius: 12px 12px 0 0;
    padding: 20px 25px;
  }
  
  #graduatedLinePropertiesModal .modal-title {
    font-weight: 600;
    font-size: 1.1rem;
  }
  
  #graduatedLinePropertiesModal .modal-body {
    padding: 25px;
  }
  
  #graduatedLinePropertiesModal .card {
    border: 1px solid #e9ecef;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  }
  
  #graduatedLinePropertiesModal .card-header {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-bottom: 1px solid #dee2e6;
    padding: 15px 20px;
  }
  
  #graduatedLinePropertiesModal .card-header h6 {
    color: #495057;
    font-weight: 600;
    margin: 0;
  }
  
  #graduatedLinePropertiesModal .form-label {
    font-weight: 500;
    color: #495057;
    margin-bottom: 8px;
  }
  
  #graduatedLinePropertiesModal .form-label i {
    margin-right: 8px;
    color: #0dcaf0;
  }
  
  #graduatedLinePropertiesModal .form-range {
    height: 6px;
    border-radius: 3px;
    background: #e9ecef;
  }
  
  #graduatedLinePropertiesModal .form-range::-webkit-slider-thumb {
    background: #0dcaf0;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  #graduatedLinePropertiesModal .form-range::-moz-range-thumb {
    background: #0dcaf0;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  #graduatedLinePropertiesModal .form-select {
    border: 1px solid #ced4da;
    border-radius: 6px;
    transition: border-color 0.3s ease;
  }
  
  #graduatedLinePropertiesModal .form-select:focus {
    border-color: #0dcaf0;
    box-shadow: 0 0 0 0.2rem rgba(13, 202, 240, 0.25);
  }
  
  #graduatedLinePropertiesModal .badge {
    font-size: 0.8rem;
    padding: 6px 10px;
    border-radius: 20px;
  }
  
  #graduatedLinePropertiesModal .btn {
    border-radius: 6px;
    font-weight: 500;
    padding: 8px 16px;
    transition: all 0.3s ease;
  }
  
  #graduatedLinePropertiesModal .btn-primary {
    background: linear-gradient(135deg, #0dcaf0 0%, #0b5ed7 100%);
    border: none;
    box-shadow: 0 2px 8px rgba(13, 202, 240, 0.3);
  }
  
  #graduatedLinePropertiesModal .btn-primary:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(13, 202, 240, 0.4);
  }
  
  #graduatedLinePropertiesModal .btn-outline-secondary {
    border-color: #6c757d;
    color: #6c757d;
  }
  
  #graduatedLinePropertiesModal .btn-outline-secondary:hover {
    background-color: #6c757d;
    border-color: #6c757d;
    color: white;
  }
  
  .graduated-line-properties-btn {
    background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
    border: none;
    color: white;
    font-weight: 500;
    padding: 8px 16px;
    border-radius: 6px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 6px rgba(40, 167, 69, 0.3);
  }
  
  .graduated-line-properties-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
    background: linear-gradient(135deg, #218838 0%, #1ea085 100%);
  }
  
  .graduated-line-properties-btn i {
    margin-right: 8px;
  }
  
  #graduatedLinePropertiesModal #graduated-line-preview,
  #graduatedLinePropertiesModal #graduated-custom-pattern-preview {
    min-height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f8f9fa;
    border: 2px dashed #dee2e6;
    border-radius: 8px;
  }
  
  #graduatedLinePropertiesModal #graduated-line-preview svg,
  #graduatedLinePropertiesModal #graduated-custom-pattern-preview svg {
    max-width: 100%;
    height: auto;
  }
  
  #graduatedLinePropertiesModal .form-text {
    font-size: 0.8rem;
    color: #6c757d;
    margin-top: 4px;
  }
  
  #graduatedLinePropertiesModal .input-group {
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  
  #graduatedLinePropertiesModal .input-group .form-control {
    border-right: none;
  }
  
  #graduatedLinePropertiesModal .input-group .btn {
    border-left: none;
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
  }

  /* Estilos para o Modal de Tamanho Proporcional */
  #block-proportional-size .card {
    border: 1px solid #17a2b8;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(23, 162, 184, 0.15);
  }
  
  #block-proportional-size .card-header {
    background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
    border-bottom: 1px solid #17a2b8;
    border-radius: 8px 8px 0 0;
  }
  
  #block-proportional-size .card-header h6 {
    color: white;
    font-weight: 600;
    margin: 0;
  }
  
  #block-proportional-size .form-label {
    font-weight: 500;
    color: #495057;
    margin-bottom: 8px;
  }
  
  #block-proportional-size .form-label i {
    margin-right: 8px;
    color: #17a2b8;
  }
  
  #block-proportional-size .form-range {
    height: 6px;
    border-radius: 3px;
    background: #e9ecef;
  }
  
  #block-proportional-size .form-range::-webkit-slider-thumb {
    background: #17a2b8;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  #block-proportional-size .form-range::-moz-range-thumb {
    background: #17a2b8;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  #block-proportional-size .badge {
    font-size: 0.8rem;
    padding: 6px 10px;
    border-radius: 20px;
    min-width: 50px;
    text-align: center;
  }
  
  #block-proportional-size .badge.bg-secondary {
    background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%) !important;
  }
  
  #block-proportional-size .badge.bg-primary {
    background: linear-gradient(135deg, #0d6efd 0%, #0b5ed7 100%) !important;
  }
  
  #proportional-size-preview {
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 2px dashed #17a2b8 !important;
    border-radius: 8px;
  }
  
  #proportional-size-preview svg {
    max-width: 100%;
    height: auto;
  }
  
  #block-proportional-size .text-muted {
    font-size: 0.85rem;
    line-height: 1.4;
  }
  
  #block-proportional-size .text-muted i {
    color: #17a2b8;
  }

  /* Estilos para indicadores de peso na legenda */
  .line-weight-indicator {
    transition: all 0.3s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  
  .line-weight-indicator:hover {
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    transform: scaleY(1.2);
  }
  
  #proportional-size-legend {
    border-left: 4px solid #17a2b8 !important;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  }
  
  #proportional-size-legend h6 {
    color: #17a2b8;
    font-weight: 600;
  }
  
  .graduated-class-item .line-weight-indicator {
    margin: 4px 0;
    border-radius: 2px;
    background: linear-gradient(90deg, #17a2b8 0%, #138496 100%);
  }

  /* Estilos para interface dinâmica do tamanho proporcional */
  #block-proportional-size.active {
    border-color: #28a745 !important;
    box-shadow: 0 4px 12px rgba(40, 167, 69, 0.25) !important;
  }
  
  #block-proportional-size.active .card-header {
    background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
  }
  
  #block-proportional-size .card-header.active {
    background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
  }
  
  #block-proportional-size .save-status-badge,
  #block-proportional-size .error-status-badge {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 1000;
    transition: all 0.3s ease;
  }
  
  #block-proportional-size .form-range:focus {
    box-shadow: 0 0 0 0.2rem rgba(23, 162, 184, 0.25);
  }
  
  #block-proportional-size .form-range::-webkit-slider-thumb:active {
    transform: scale(1.2);
  }
  
  #block-proportional-size .form-range::-moz-range-thumb:active {
    transform: scale(1.2);
  }
  
  /* Animações para feedback visual */
  @keyframes proportionalSizePulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  #block-proportional-size.active .card-header {
    animation: proportionalSizePulse 2s ease-in-out infinite;
  }
  
  /* Estilos para indicadores de peso na legenda */
  .line-weight-indicator {
    transition: all 0.3s ease;
    cursor: pointer;
  }
  
  .line-weight-indicator:hover {
    transform: scaleY(1.3);
    box-shadow: 0 2px 8px rgba(23, 162, 184, 0.4);
  }
  
  /* Responsividade para dispositivos móveis */
  @media (max-width: 768px) {
    #block-proportional-size .card-body {
      padding: 1rem;
    }
    
    #block-proportional-size .row {
      margin: 0;
    }
    
    #block-proportional-size .col-md-6 {
      padding: 0.5rem;
    }
  }
</style>
<h2>Simbologia: {{ layer.name }}</h2>
<div class="row">
  <div class="col-lg-6">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">Configurações de Simbologia</h5>
      </div>
      <div class="card-body">
        <!-- Abas para organizar simbologia e rótulos -->
        <ul class="nav nav-tabs" id="symbologyTabs" role="tablist">
          <li class="nav-item" role="presentation">
            <button class="nav-link active" id="symbology-tab" data-bs-toggle="tab" data-bs-target="#symbology-content" type="button" role="tab">
              <i class="fas fa-palette"></i> Simbologia
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="labels-tab" data-bs-toggle="tab" data-bs-target="#labels-content" type="button" role="tab">
              <i class="fas fa-font"></i> Rótulos
            </button>
          </li>
        </ul>
        
        <div class="tab-content mt-3" id="symbologyTabsContent">
          <!-- Aba de Simbologia -->
          <div class="tab-pane fade show active" id="symbology-content" role="tabpanel">
            <div class="row g-3">
              <div class="col-md-6">
                <label class="form-label">Tipo de Geometria</label>
                <select id="geom-type" class="form-select">
                  <option value="point">Ponto</option>
                  <option value="line">Linha</option>
                  <option value="polygon">Polígono</option>
                  <option value="raster">Raster</option>
                </select>
              </div>
              <div class="col-md-6">
                <label class="form-label">Campo para Simbologia</label>
                <select id="field-select" class="form-select">
                  <option value="">Selecione uma coluna...</option>
                </select>
              </div>
              <div class="col-md-12">
                <label for="style-type" class="form-label">Tipo de Simbologia</label>
                <select class="form-select" id="style-type">
                  <option value="single">Símbolo Único</option>
                  <option value="categorized">Categorizada</option>
                  <option value="graduated">Graduada</option>
                  <option value="raster">Raster</option>
                </select>
              </div>
              
              <!-- Blocos condicionais de simbologia -->
              <div class="col-md-4 d-none" id="block-classes">
                <label class="form-label">Número de classes</label>
                <input id="classes" type="number" class="form-control" min="2" max="20" value="5">
              </div>
              <div class="col-md-4 d-none" id="block-method">
                <label class="form-label">Método de Classificação</label>
                <select id="method" class="form-select">
                  <option value="equal">Intervalos Iguais</option>
                  <option value="quantiles">Quantis (Equal Count)</option>
                  <option value="jenks">Quebras Naturais (Jenks)</option>
                  <option value="log">Logarítmica</option>
                  <option value="stddev">Desvio Padrão</option>
                  <option value="arithmetic">Progressão Aritmética</option>
                  <option value="geometric">Progressão Geométrica</option>
                  <option value="manual">Manual</option>
                </select>
              </div>
              <div class="col-md-12 d-none" id="block-manual">
                <label class="form-label">Intervalos (separados por vírgula)</label>
                <input id="manual-breaks" class="form-control" placeholder="ex.: 0, 10, 25, 50, 100">
              </div>
              
              <!-- Caixa explicativa independente - APENAS para simbologia graduada -->
              <div id="method-info" class="method-info-compact d-none">
                <!-- As informações aparecerão aqui dinamicamente -->
              </div>
              

              
              <!-- Modal de Tamanho Proporcional - APENAS para simbologia graduada + geometria linha -->
              <div class="col-md-12" id="block-proportional-size" style="display: none;">
                <div class="card">
                  <div class="card-header bg-info text-white">
                    <div class="d-flex align-items-center justify-content-between">
                      <h6 class="mb-0">
                        <i class="fas fa-arrows-alt-v"></i> Tamanho Proporcional das Linhas
                      </h6>
                      <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="proportional-size-toggle" 
                               title="Ativar/Desativar tamanho proporcional">
                        <label class="form-check-label text-white" for="proportional-size-toggle">
                          <small>Ativar</small>
                        </label>
                      </div>
                    </div>
                  </div>
                  <div class="card-body" id="proportional-size-content" style="display: none;">
                    <div class="row">
                      <div class="col-md-6">
                        <div class="mb-3">
                          <label for="min-line-weight" class="form-label">
                            <i class="fas fa-minus"></i> Espessura Mínima
                          </label>
                          <div class="d-flex align-items-center gap-2">
                            <input type="range" class="form-range" id="min-line-weight" 
                                   min="1" max="10" step="0.5" value="2"
                                   title="Definir espessura mínima das linhas">
                            <span class="badge bg-secondary" id="min-line-weight-value">2px</span>
                          </div>
                          <small class="text-muted">Espessura da linha com menor valor</small>
                        </div>
                      </div>
                      
                      <div class="col-md-6">
                        <div class="mb-3">
                          <label for="max-line-weight" class="form-label">
                            <i class="fas fa-plus"></i> Espessura Máxima
                          </label>
                          <div class="d-flex align-items-center gap-2">
                            <input type="range" class="form-range" id="max-line-weight" 
                                   min="5" max="20" step="0.5" value="8"
                                   title="Definir espessura máxima das linhas">
                            <span class="badge bg-primary" id="max-line-weight-value">8px</span>
                          </div>
                          <small class="text-muted">Espessura da linha com maior valor</small>
                        </div>
                      </div>
                    </div>
                    
                    <!-- Preview da Distribuição de Tamanhos -->
                    <div class="row mt-3">
                      <div class="col-md-12">
                        <label class="form-label">
                          <i class="fas fa-eye"></i> Preview da Distribuição
                        </label>
                        <div id="proportional-size-preview" class="border rounded p-3 bg-light">
                          <div class="text-muted text-center">Preview da distribuição de tamanhos</div>
                        </div>
                        <small class="text-muted">
                          <i class="fas fa-info-circle"></i> 
                          <strong>Princípio:</strong> Quanto maior o símbolo, maior a quantidade que ele representa. 
                          Os tamanhos são calculados proporcionalmente ao percentual dos dados.
                        </small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Modal de Tamanho Proporcional dos Pontos - APENAS para simbologia graduada + geometria ponto -->
              <div class="col-md-12" id="block-proportional-point-size" style="display: none;">
                <div class="card">
                  <div class="card-header bg-success text-white">
                    <div class="d-flex align-items-center justify-content-between">
                      <h6 class="mb-0">
                        <i class="fas fa-circle"></i> Tamanho Proporcional dos Pontos
                      </h6>
                      <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="proportional-point-size-toggle" 
                               title="Ativar/Desativar tamanho proporcional dos pontos">
                        <label class="form-check-label text-white" for="proportional-point-size-toggle">
                          <small>Ativar</small>
                        </label>
                      </div>
                    </div>
                  </div>
                  <div class="card-body" id="proportional-point-size-content" style="display: none;">
                    <div class="row">
                      <div class="col-md-6">
                        <div class="mb-3">
                          <label for="min-point-radius" class="form-label">
                            <i class="fas fa-minus"></i> Raio Mínimo
                          </label>
                          <div class="d-flex align-items-center gap-2">
                            <input type="range" class="form-range" id="min-point-radius" 
                                   min="2" max="15" step="0.5" value="4"
                                   title="Definir raio mínimo dos pontos">
                            <span class="badge bg-secondary" id="min-point-radius-value">4px</span>
                          </div>
                          <small class="text-muted">Raio do ponto com menor valor</small>
                        </div>
                      </div>
                      
                      <div class="col-md-6">
                        <div class="mb-3">
                          <label for="max-point-radius" class="form-label">
                            <i class="fas fa-plus"></i> Raio Máximo
                          </label>
                          <div class="d-flex align-items-center gap-2">
                            <input type="range" class="form-range" id="max-point-radius" 
                                   min="8" max="30" step="0.5" value="12"
                                   title="Definir raio máximo dos pontos">
                            <span class="badge bg-success" id="max-point-radius-value">12px</span>
                          </div>
                          <small class="text-muted">Raio do ponto com maior valor</small>
                        </div>
                      </div>
                    </div>
                    
                    <!-- Preview da Distribuição de Tamanhos -->
                    <div class="row mt-3">
                      <div class="col-md-12">
                        <label class="form-label">
                          <i class="fas fa-eye"></i> Preview da Distribuição
                        </label>
                        <div id="proportional-point-size-preview" class="border rounded p-3 bg-light">
                          <div class="text-muted text-center">Preview da distribuição de tamanhos</div>
                        </div>
                        <small class="text-muted">
                          <i class="fas fa-info-circle"></i> 
                          <strong>Princípio:</strong> Quanto maior o símbolo, maior a quantidade que ele representa. 
                          Os tamanhos são calculados proporcionalmente ao percentual dos dados.
                        </small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Paleta de cores -->
              <div class="col-md-12" id="block-palette">
                <label class="form-label">Paleta de Cores</label>
                <small class="text-muted d-block mb-2">
                  <i class="fas fa-info-circle"></i> 
                  <strong>Distribuição Otimizada:</strong> A primeira classe sempre recebe a primeira cor da paleta, 
                  a última classe sempre recebe a última cor, e as classes intermediárias são distribuídas uniformemente 
                  entre os extremos para máxima variação visual.
                </small>
                <!-- Select customizado com previews de cores -->
                <div class="custom-palette-select mb-3">
                  <div class="palette-select-header" id="palette-select-header">
                    <div class="d-flex align-items-center justify-content-between w-100">
                      <span id="palette-select-text">Selecione uma paleta...</span>
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                  <div class="palette-select-dropdown d-none" id="palette-select-dropdown">
                    <div class="palette-options">
                      <div class="palette-optgroup" data-type="sequential">
                        <div class="palette-optgroup-label">Sequencial (Dados Quantitativos Ordenados)</div>
                        <div class="palette-option" data-value="Blues" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="Blues"></div>
                          <span>Blues - Água/Precipitação</span>
                        </div>
                        <div class="palette-option" data-value="Greens" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="Greens"></div>
                          <span>Greens - Vegetação/Agricultura</span>
                        </div>
                        <div class="palette-option" data-value="YlOrRd" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="YlOrRd"></div>
                          <span>YlOrRd - Calor/Densidade</span>
                        </div>
                        <div class="palette-option" data-value="Purples" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="Purples"></div>
                          <span>Purples - Magnitude</span>
                        </div>
                        <div class="palette-option" data-value="Greys" data-type="sequential">
                          <div class="palette-preview-mini" data-palette="Greys"></div>
                          <span>Greys - Mapa Base</span>
                        </div>
                      </div>
                      <div class="palette-optgroup" data-type="divergent">
                        <div class="palette-optgroup-label">Divergente (Dados com Ponto Central)</div>
                        <div class="palette-option" data-value="Viridis" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="Viridis"></div>
                          <span>Viridis - Científica Moderna</span>
                        </div>
                        <div class="palette-option" data-value="Cividis" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="Cividis"></div>
                          <span>Cividis - Daltonismo Seguro</span>
                        </div>
                        <div class="palette-option" data-value="RdYlBu" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="RdYlBu"></div>
                          <span>RdYlBu - Anomalias (Seguro)</span>
                        </div>
                        <div class="palette-option" data-value="RdYlGn" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="RdYlGn"></div>
                          <span>RdYlGn - Clássica</span>
                        </div>
                        <div class="palette-option" data-value="BrBG" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="BrBG"></div>
                          <span>BrBG - Vegetação vs Solo</span>
                        </div>
                        <div class="palette-option" data-value="PiYG" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="PiYG"></div>
                          <span>PiYG - Alternativa Verde</span>
                        </div>
                        <div class="palette-option" data-value="Coolwarm" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="Coolwarm"></div>
                          <span>Coolwarm - Azul-Vermelho</span>
                        </div>
                        <div class="palette-option" data-value="Spectral" data-type="divergent">
                          <div class="palette-preview-mini" data-palette="Spectral"></div>
                          <span>Spectral - Topografia</span>
                        </div>
                      </div>
                      <div class="palette-optgroup" data-type="qualitative">
                        <div class="palette-optgroup-label">Qualitativo (Dados Categóricos)</div>
                        <div class="palette-option" data-value="Vivid (Início Verde)" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="Vivid (Início Verde)"></div>
                          <span>Vivid (Início Verde) - Personalizada</span>
                        </div>
                        <div class="palette-option" data-value="Vivid (Início Azul)" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="Vivid (Início Azul)"></div>
                          <span>Vivid (Início Azul) - Personalizada</span>
                        </div>
                        <div class="palette-option" data-value="Tableau Tab10" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="Tableau Tab10"></div>
                          <span>Tableau Tab10 - Moderna</span>
                        </div>
                        <div class="palette-option" data-value="ColorBrewer Paired" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="ColorBrewer Paired"></div>
                          <span>ColorBrewer Paired - Pares</span>
                        </div>
                        <div class="palette-option" data-value="ColorBrewer Set3" data-type="qualitative">
                          <div class="palette-preview-mini" data-palette="ColorBrewer Set3"></div>
                          <span>ColorBrewer Set3 - Suave</span>
                        </div>
                      </div>
                      <div class="palette-optgroup" id="custom-palettes-group" data-type="custom">
                        <div class="palette-optgroup-label">Paletas Criadas pelo Usuário</div>
                        <!-- Paletas personalizadas serão adicionadas aqui dinamicamente -->
                      </div>
                    </div>
                  </div>
                  <!-- Input hidden para manter compatibilidade -->
                  <input type="hidden" id="palette-select" value="">
                </div>
                
                <!-- Controles para paletas personalizadas -->
                <div class="d-flex gap-2 mb-3">
                  <button type="button" id="btn-create-palette" class="btn btn-outline-primary btn-sm">
                    <i class="fas fa-plus"></i> Criar Nova Paleta
                  </button>
                  <button type="button" id="btn-save-current-palette" class="btn btn-outline-success btn-sm">
                    <i class="fas fa-save"></i> Salvar Paleta Atual
                  </button>
                  <button type="button" id="btn-manage-palettes" class="btn btn-outline-info btn-sm">
                    <i class="fas fa-cog"></i> Gerenciar Paletas
                  </button>
                </div>
                
                <!-- Visualização da paleta selecionada com nome -->
                <div id="palette-preview" class="palette-preview-container">
                  <div class="d-flex align-items-center gap-2 mb-2">
                    <label class="form-label mb-0 fw-bold">Paleta Selecionada:</label>
                    <span id="palette-name" class="badge bg-primary fs-6"></span>
                  </div>
                  <div class="mb-2">
                    <small class="text-muted">Clique nas cores para copiar o valor HEX</small>
                  </div>
                  <div id="palette-colors" class="d-flex gap-1 flex-wrap"></div>
                </div>
                

                
                <div class="row g-2">
                  <div class="col-md-6">
                    <label class="form-label">Opacidade da paleta</label>
                    <input id="palette-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="1">
                    <small class="text-muted">Valor: <span id="opacity-value">1.0</span></small>
                  </div>
                  <div class="col-md-6">
                    <div class="form-check form-switch mt-4">
                      <input class="form-check-input" type="checkbox" id="palette-invert">
                      <label class="form-check-label" for="palette-invert">Inverter ordem das cores</label>
                    </div>
                    <small class="text-muted d-block">Inverte a ordem das cores da paleta selecionada</small>
                  </div>
                </div>
                <div class="row g-2 mt-2">
                  <div class="col-md-6 d-none" id="block-polygon-border">
                    <label class="form-label">Cor da borda</label>
                    <input type="color" id="polygon-border-color" class="form-control form-control-color" value="#333333">
                    <label class="form-label mt-2">Espessura da borda</label>
                    <input type="number" id="polygon-border-width" class="form-control" min="0" max="10" value="2">
                    <div class="form-check form-switch mt-2">
                      <input class="form-check-input" type="checkbox" id="polygon-border-toggle" checked>
                      <label class="form-check-label" for="polygon-border-toggle">Exibir borda dos polígonos</label>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Editor de categorias -->
              <div class="col-md-12 d-none" id="block-category-editor">
                <div class="d-flex justify-content-between align-items-center mb-2">
                  <label class="form-label mb-0">Cores e Nomes das Classes</label>
                  <button type="button" class="btn btn-outline-warning btn-sm" onclick="resetCategorizedLegend()" title="Resetar legenda para o estado inicial">
                    <i class="fas fa-undo"></i> Resetar Legenda
                  </button>
                </div>
                <div class="alert alert-info">
                  <i class="fas fa-info-circle"></i>
                  <strong>Dica:</strong> Clique no nome da classe para editá-lo. As mudanças são aplicadas automaticamente ao mapa.
                </div>
                
                <!-- Controles específicos para linhas (apenas quando geom-type = line) -->
                <div class="col-md-12 d-none" id="block-line-specific-controls">
                  <div class="card border-info mb-3">
                    <div class="card-header bg-info text-white">
                      <h6 class="mb-0"><i class="fas fa-minus"></i> Controles Específicos para Linhas</h6>
                    </div>
                    <div class="card-body">
                      <div class="row g-3">
                        <div class="col-md-3">
                          <label class="form-label">Espessura Padrão das Linhas</label>
                          <input type="number" id="line-weight-default" class="form-control" value="2" min="1" max="10" step="0.5">
                          <small class="text-muted">Espessura padrão para todas as linhas (pode ser personalizada por categoria)</small>
                        </div>
                        <div class="col-md-3">
                          <label class="form-label">Opacidade Padrão das Linhas</label>
                          <input type="range" id="line-opacity-default" class="form-range" min="0" max="1" step="0.05" value="1">
                          <small class="text-muted">Valor: <span id="line-opacity-value">1.0</span></small>
                        </div>
                        <div class="col-md-3">
                          <label class="form-label">Estilo Padrão das Linhas</label>
                          <select id="line-style-default" class="form-select">
                            <option value="">Contínua (padrão)</option>
                            <option value="5,5">Tracejada (5,5)</option>
                            <option value="10,5">Tracejada Longa (10,5)</option>
                            <option value="2,2">Pontilhada (2,2)</option>
                            <option value="1,1">Pontilhada Fina (1,1)</option>
                            <option value="5,2,1,2">Traço-Ponto (5,2,1,2)</option>
                            <option value="10,2,1,2">Traço-Ponto Longo (10,2,1,2)</option>
                            <option value="15,3,3,3">Traço-Ponto-Ponto (15,3,3,3)</option>
                            <option value="20,5,5,5">Traço-Ponto-Ponto Longo (20,5,5,5)</option>
                            <option value="custom">Personalizado...</option>
                          </select>
                          <small class="text-muted">Estilo padrão para todas as linhas</small>
                        </div>
                        <div class="col-md-3">
                          <label class="form-label">Espaçamento Padrão</label>
                          <input type="range" id="line-spacing-default" class="form-range" min="1" max="30" step="0.5" value="10">
                          <small class="text-muted">Valor: <span id="line-spacing-value">10px</span></small>
                        </div>
                      </div>
                      
                      <!-- Controle de Estilo Personalizado (inicialmente oculto) -->
                      <div class="row g-3 mt-2 d-none" id="custom-line-style-controls">
                        <div class="col-md-6">
                          <label class="form-label">Padrão de Linha Personalizado</label>
                          <input type="text" id="custom-line-pattern" class="form-control" placeholder="ex: 8,4,2,4" 
                                 title="Formato: traço,espaço,traço,espaço... (em pixels)">
                          <small class="text-muted">Defina o padrão de linha personalizado (traço,espaço,traço,espaço...)</small>
                        </div>
                        <div class="col-md-6">
                          <label class="form-label">Preview do Estilo</label>
                          <div id="custom-line-preview" class="border rounded p-2" style="height: 40px; background: #f8f9fa;">
                            <div class="line-preview-element" style="height: 3px; background: #333; margin: 18px 0;"></div>
                          </div>
                        </div>
                      </div>
                      
                      <div class="row g-3 mt-2">
                        <div class="col-md-12">
                          <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="line-allow-custom-per-category" checked>
                            <label class="form-check-label" for="line-allow-custom-per-category">
                              <strong>Permitir personalização individual por categoria</strong>
                            </label>
                            <small class="text-muted d-block">Quando marcado, cada categoria pode ter espessura, opacidade e estilo próprios</small>
                          </div>
                        </div>
                      </div>
                      
                      <!-- Controles Avançados de Linha -->
                      <div class="row g-3 mt-3">
                        <div class="col-md-12">
                          <div class="card border-info">
                            <div class="card-header bg-info text-white">
                              <i class="fas fa-cog"></i> Controles Avançados de Linha
                            </div>
                            <div class="card-body">
                              <div class="row g-3">
                                <div class="col-md-4">
                                  <label class="form-label">Cap das Linhas</label>
                                  <select id="line-cap-default" class="form-select">
                                    <option value="round">Arredondado</option>
                                    <option value="butt">Reto</option>
                                    <option value="square">Quadrado</option>
                                  </select>
                                  <small class="text-muted">Forma das extremidades das linhas</small>
                                </div>
                                <div class="col-md-4">
                                  <label class="form-label">Junção das Linhas</label>
                                  <select id="line-join-default" class="form-select">
                                    <option value="round">Arredondada</option>
                                    <option value="miter">Em ângulo</option>
                                    <option value="bevel">Chanfrada</option>
                                  </select>
                                  <small class="text-muted">Forma das junções entre segmentos</small>
                                </div>
                                <div class="col-md-4">
                                  <label class="form-label">Miter Limit</label>
                                  <input type="number" id="line-miter-limit" class="form-control" value="4" min="1" max="10" step="0.1">
                                  <small class="text-muted">Limite para junções em ângulo</small>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- Controles específicos para pontos (apenas quando geom-type = point) -->
                <div class="col-md-12 d-none" id="block-point-specific-controls">
                  <div class="card border-success mb-3">
                    <div class="card-header bg-success text-white">
                      <h6 class="mb-0"><i class="fas fa-circle"></i> Controles Específicos para Pontos</h6>
                    </div>
                    <div class="card-body">
                      <div class="row g-3">
                        <div class="col-md-3">
                          <label class="form-label">Raio Padrão dos Pontos</label>
                          <input type="number" id="point-radius-default" class="form-control" value="6" min="2" max="25" step="0.5">
                          <small class="text-muted">Raio padrão para todos os pontos (pode ser personalizado por categoria)</small>
                        </div>
                        <div class="col-md-3">
                          <label class="form-label">Opacidade Padrão dos Pontos</label>
                          <input type="range" id="point-opacity-default" class="form-range" min="0" max="1" step="0.05" value="1">
                          <small class="text-muted">Valor: <span id="point-opacity-value">1.0</span></small>
                        </div>
                                         <div class="col-md-3">
                   <label class="form-label">Forma Padrão dos Pontos</label>
                   <select id="point-shape-default" class="form-select">
                     <option value="circle">Círculo</option>
                     <option value="square">Quadrado</option>
                     <option value="diamond">Losango</option>
                     <option value="triangle">Triângulo</option>
                     <option value="star">Estrela</option>
                     <option value="cross">Cruz</option>
                     <option value="pin">Pin</option>
                     <option value="marker">Marcador</option>
                     <option value="custom">Personalizado...</option>
                   </select>
                   <small class="text-muted">Forma padrão para todos os pontos</small>
                 </div>
                        <div class="col-md-3">
                          <label class="form-label">Borda Padrão</label>
                          <input type="range" id="point-border-width-default" class="form-range" min="0" max="5" step="0.5" value="1">
                          <small class="text-muted">Valor: <span id="point-border-width-value">1px</span></small>
                        </div>
                      </div>
                      
                      <!-- Controle de Forma Personalizada (inicialmente oculto) -->
                      <div class="row g-3 mt-2 d-none" id="custom-point-shape-controls">
                        <div class="col-md-6">
                          <label class="form-label">Forma Personalizada</label>
                          <input type="text" id="custom-point-shape" class="form-control" placeholder="ex: M 0,0 L 10,0 L 5,10 Z" 
                                 title="Formato SVG path para forma personalizada">
                          <small class="text-muted">Defina uma forma personalizada usando SVG path</small>
                        </div>
                        <div class="col-md-6">
                          <label class="form-label">Preview da Forma</label>
                          <div id="custom-point-preview" class="border rounded p-2" style="height: 40px; background: #f8f9fa;">
                            <div class="point-preview-element" style="width: 20px; height: 20px; background: #333; margin: 10px auto; border-radius: 50%;"></div>
                          </div>
                        </div>
                      </div>
                      
                      <div class="row g-3 mt-2">
                        <div class="col-md-12">
                          <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="point-allow-custom-per-category" checked>
                            <label class="form-check-label" for="point-allow-custom-per-category">
                              <strong>Permitir personalização individual por categoria</strong>
                            </label>
                            <small class="text-muted d-block">Quando marcado, cada categoria pode ter raio, opacidade e forma próprios</small>
                          </div>
                        </div>
                      </div>
                      
                      <!-- Controles Avançados de Ponto -->
                      <div class="row g-3 mt-3">
                        <div class="col-md-12">
                          <div class="card border-success">
                            <div class="card-header bg-success text-white">
                              <i class="fas fa-cog"></i> Controles Avançados de Ponto
                            </div>
                            <div class="card-body">
                              <div class="row g-3">
                                <div class="col-md-4">
                                  <label class="form-label">Cor da Borda</label>
                                  <input type="color" id="point-border-color-default" class="form-control form-control-color" value="#000000">
                                  <small class="text-muted">Cor da borda dos pontos</small>
                                </div>
                                <div class="col-md-4">
                                  <label class="form-label">Estilo da Borda</label>
                                  <select id="point-border-style-default" class="form-select">
                                    <option value="solid">Sólida</option>
                                    <option value="dashed">Tracejada</option>
                                    <option value="dotted">Pontilhada</option>
                                  </select>
                                  <small class="text-muted">Estilo da borda dos pontos</small>
                                </div>
                                <div class="col-md-4">
                                  <label class="form-label">Sombra</label>
                                  <input type="range" id="point-shadow-default" class="form-range" min="0" max="10" step="0.5" value="0">
                                  <small class="text-muted">Valor: <span id="point-shadow-value">0px</span></small>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- Biblioteca de Ícones Temáticos -->
                <div class="row g-3 mt-3">
                  <div class="col-md-12">
                    <div class="card border-primary">
                      <div class="card-header bg-primary text-white">
                        <i class="fas fa-icons"></i> Biblioteca de Ícones Temáticos
                      </div>
                      <div class="card-body">
                        <div class="row g-3">
                          <div class="col-md-3">
                            <label class="form-label">Categoria Temática</label>
                            <select id="icon-theme-category" class="form-select">
                              <option value="">Selecionar categoria...</option>
                              <option value="transport">Transporte</option>
                              <option value="emergency">Serviços de Emergência</option>
                              <option value="commerce">Comércio</option>
                              <option value="education">Educação</option>
                              <option value="nature">Natureza</option>
                              <option value="health">Saúde</option>
                              <option value="government">Governo</option>
                              <option value="recreation">Recreação</option>
                            </select>
                            <small class="text-muted">Categoria temática do ícone</small>
                          </div>
                          <div class="col-md-3">
                            <label class="form-label">Ícone Específico</label>
                            <select id="icon-specific-type" class="form-select" disabled>
                              <option value="">Primeiro selecione uma categoria...</option>
                            </select>
                            <small class="text-muted">Ícone específico da categoria</small>
                          </div>
                          <div class="col-md-3">
                            <label class="form-label">Tamanho do Ícone</label>
                            <input type="range" id="icon-size-slider" class="form-range" min="12" max="48" step="2" value="24">
                            <small class="text-muted">Valor: <span id="icon-size-value">24px</span></small>
                          </div>
                          <div class="col-md-3">
                            <label class="form-label">Cor do Ícone</label>
                            <input type="color" id="icon-color-picker" class="form-control form-control-color" value="#ff0000">
                            <small class="text-muted">Cor principal do ícone</small>
                          </div>
                        </div>
                        
                        <!-- Preview do Ícone Selecionado -->
                        <div class="row mt-3">
                          <div class="col-md-12">
                            <label class="form-label">
                              <i class="fas fa-eye"></i> Preview do Ícone
                            </label>
                            <div id="icon-preview-container" class="border rounded p-3 bg-light text-center" style="height: 80px;">
                              <div class="text-muted">Selecione uma categoria e ícone para visualizar</div>
                            </div>
                            <small class="text-muted">
                              <i class="fas fa-info-circle"></i> 
                              O ícone será aplicado a todos os pontos da camada. Use cores que contrastem com o fundo do mapa.
                            </small>
                          </div>
                        </div>
                        
                        <!-- Botões de Ação -->
                        <div class="row mt-3">
                          <div class="col-md-12">
                            <div class="d-flex gap-2">
                              <button type="button" id="apply-icon-to-points" class="btn btn-primary" disabled>
                                <i class="fas fa-check"></i> Aplicar Ícone aos Pontos
                              </button>
                              <button type="button" id="reset-icon-settings" class="btn btn-secondary">
                                <i class="fas fa-undo"></i> Resetar Configurações
                              </button>
                              <button type="button" id="export-icon-settings" class="btn btn-success">
                                <i class="fas fa-download"></i> Exportar Configurações
                              </button>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <div id="category-list" class="d-flex flex-column gap-2"></div>
              </div>
              
              <!-- Editor de classes para simbologia graduada -->
              <div class="col-md-12 d-none" id="block-graduated-classes">
                <label class="form-label">Editor de Classes da Simbologia Graduada</label>
                <div class="alert alert-info">
                  <i class="fas fa-info-circle"></i>
                  <strong>Dica:</strong> Edite os nomes das classes para personalizar a legenda. As mudanças são aplicadas automaticamente.
                </div>
                
                <!-- Opção de legenda composta -->
                <div class="form-check form-switch mb-3">
                  <input class="form-check-input" type="checkbox" id="composite-legend-toggle" checked>
                  <label class="form-check-label" for="composite-legend-toggle">
                    <strong>Legenda Composta:</strong> Nome da classe + intervalo de valores
                  </label>
                  <small class="text-muted d-block">Exemplo: "Muito Bom - 1,0 a 1,80" (quando marcado) ou "1,0 a 1,80" (quando desmarcado)</small>
                </div>
                
                <!-- Opção para inverter ordem das classes - APENAS para simbologia graduada -->
                <div class="col-md-4 d-none" id="block-class-invert">
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="class-invert">
                    <label class="form-check-label" for="class-invert">Inverter ordem das classes</label>
                  </div>
                  <small class="text-muted d-block">Inverte a ordem visual das classes na legenda</small>
                </div>
                
                <!-- Botão para omitir valores de intervalo (apenas quando legenda composta estiver ativa) -->
                <div class="mb-3 d-none" id="block-hide-intervals">
                  <button type="button" class="btn btn-outline-secondary btn-sm" id="toggle-intervals">
                    <i class="fas fa-eye-slash"></i> Ocultar Valores de Intervalo
                  </button>
                  <small class="text-muted d-block mt-1">Remove os valores de intervalo da legenda, mostrando apenas o nome da classe</small>
                </div>
                
                <div id="graduated-classes-list" class="d-flex flex-column gap-2"></div>
              </div>
              
              <!-- Cor personalizada (apenas Símbolo Único) -->
              <div class="col-md-12 d-none" id="block-custom-color">
                <label class="form-label">Cor Personalizada (apenas Símbolo Único)</label>
                <div class="row g-3">
                  <div class="col-md-6">
                    <label class="form-label">Borda</label>
                    <input id="stroke-color" type="color" class="form-control form-control-color" value="#333333">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Preenchimento</label>
                    <input id="fill-color" type="color" class="form-control form-control-color" value="#38bdf8">
                  </div>
                </div>
                <div class="row g-3 mt-2">
                  <div class="col-md-6">
                    <label class="form-label">Espessura</label>
                    <input id="stroke-weight" type="number" class="form-control" value="2" min="0" max="10">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Opacidade</label>
                    <input id="fill-opacity" type="number" class="form-control" value="0.3" step="0.05" min="0" max="1">
                  </div>
                </div>
                <div class="row g-3 mt-2" id="block-point-only">
                  <div class="col-md-6">
                    <label class="form-label">Raio (ponto)</label>
                    <input id="point-radius" type="number" class="form-control" value="6" min="1" max="50">
                  </div>
                </div>
                <div class="row g-3 mt-2 d-none" id="block-line-only">
                  <div class="col-md-6">
                    <label class="form-label">Opacidade da linha</label>
                    <input id="line-opacity" type="number" class="form-control" value="1" step="0.05" min="0" max="1">
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Tracejado</label>
                    <input id="line-dash" class="form-control" placeholder="ex.: 4,2 (padrão: contínua)">
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Aba de Rótulos -->
          <div class="tab-pane fade" id="labels-content" role="tabpanel">
            <div class="row g-3">
              <!-- Configurações Gerais -->
              <div class="col-md-12">
                <div class="card border-primary">
                  <div class="card-header bg-primary text-white">
                    <h6 class="mb-0"><i class="fas fa-font"></i> Configurações Gerais</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="labels-enabled" checked>
                          <label class="form-check-label" for="labels-enabled">
                            <strong>Habilitar Rótulos</strong>
                          </label>
                          <small class="text-muted d-block">Marque para exibir rótulos na camada</small>
                        </div>
                      </div>
                      
                      <div class="col-md-6">
                        <label class="form-label">Campo para Rótulo</label>
                        <select id="label-field-select" class="form-select">
                          <option value="">Selecione uma coluna...</option>
                        </select>
                      </div>
                      <div class="col-md-6">
                        <label class="form-label">Fonte</label>
                        <select id="label-font" class="form-select">
                          <option value="Arial">Arial</option>
                          <option value="Helvetica">Helvetica</option>
                          <option value="Times New Roman">Times New Roman</option>
                          <option value="Georgia">Georgia</option>
                          <option value="Verdana">Verdana</option>
                          <option value="Courier New">Courier New</option>
                          <option value="Roboto">Roboto</option>
                          <option value="Open Sans">Open Sans</option>
                          <option value="Lato">Lato</option>
                          <option value="Montserrat">Montserrat</option>
                        </select>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Aparência do Texto -->
              <div class="col-md-12">
                <div class="card border-info">
                  <div class="card-header bg-info text-white">
                    <h6 class="mb-0"><i class="fas fa-palette"></i> Aparência do Texto</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-4">
                        <label class="form-label">Tamanho da Fonte</label>
                        <input id="label-size" type="number" class="form-control" min="8" max="72" value="12">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Cor do Texto</label>
                        <input id="label-color" type="color" class="form-control form-control-color" value="#000000">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Opacidade do Texto</label>
                        <input id="label-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="1">
                        <small class="text-muted">Valor: <span id="text-opacity-value">1.0</span></small>
                      </div>
                      
                      <div class="col-md-3">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-bold">
                          <label class="form-check-label" for="label-bold">Negrito</label>
                        </div>
                      </div>
                      <div class="col-md-3">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-italic">
                          <label class="form-check-label" for="label-italic">Itálico</label>
                        </div>
                      </div>
                      <div class="col-md-3">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-underline">
                          <label class="form-check-label" for="label-underline">Sublinhado</label>
                        </div>
                      </div>
                      <div class="col-md-3">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-uppercase">
                          <label class="form-check-label" for="label-uppercase">MAIÚSCULA</label>
                        </div>
                      </div>

                      <div class="col-md-6">
                        <label class="form-label">Rotação do Texto (graus)</label>
                        <input id="label-rotation" type="range" class="form-range" min="0" max="360" step="5" value="0">
                        <small class="text-muted">Valor: <span id="rotation-value">0°</span></small>
                      </div>
                      <div class="col-md-6">
                        <label class="form-label">Alinhamento</label>
                        <select id="label-alignment" class="form-select">
                          <option value="center">Centro</option>
                          <option value="left">Esquerda</option>
                          <option value="right">Direita</option>
                          <option value="top">Superior</option>
                          <option value="bottom">Inferior</option>
                          <option value="top-left">Superior Esquerda</option>
                          <option value="top-right">Superior Direita</option>
                          <option value="bottom-left">Inferior Esquerda</option>
                          <option value="bottom-right">Inferior Direita</option>
                        </select>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Buffer e Contorno -->
              <div class="col-md-12">
                <div class="card border-warning">
                  <div class="card-header bg-warning text-dark">
                    <h6 class="mb-0"><i class="fas fa-circle-notch"></i> Buffer e Contorno</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-buffer-enabled" checked>
                          <label class="form-check-label" for="label-buffer-enabled">
                            <strong>Habilitar Buffer</strong>
                          </label>
                          <small class="text-muted d-block">Buffer melhora a legibilidade do texto sobre fundos complexos</small>
                        </div>
                      </div>
                      
                      <div class="col-md-4">
                        <label class="form-label">Cor do Buffer</label>
                        <input id="label-buffer-color" type="color" class="form-control form-control-color" value="#ffffff">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Tamanho do Buffer</label>
                        <input id="label-buffer-size" type="number" class="form-control" min="0" max="20" value="2" step="0.5">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Opacidade do Buffer</label>
                        <input id="label-buffer-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="0.8">
                        <small class="text-muted">Valor: <span id="buffer-opacity-value">0.8</span></small>
                      </div>

                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-stroke-enabled">
                          <label class="form-check-label" for="label-stroke-enabled">
                            <strong>Habilitar Contorno</strong>
                          </label>
                          <small class="text-muted d-block">Contorno adiciona uma borda ao redor do texto</small>
                        </div>
                      </div>

                      <div class="col-md-4">
                        <label class="form-label">Cor do Contorno</label>
                        <input id="label-stroke-color" type="color" class="form-control form-control-color" value="#000000">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Espessura do Contorno</label>
                        <input id="label-stroke-width" type="number" class="form-control" min="0" max="10" value="1" step="0.5">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Opacidade do Contorno</label>
                        <input id="label-stroke-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="1">
                        <small class="text-muted">Valor: <span id="stroke-opacity-value">1.0</span></small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Posicionamento e Deslocamento -->
              <div class="col-md-12">
                <div class="card border-success">
                  <div class="card-header bg-success text-white">
                    <h6 class="mb-0"><i class="fas fa-arrows-alt"></i> Posicionamento e Deslocamento</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-6">
                        <label class="form-label">Deslocamento X (pixels)</label>
                        <input id="label-offset-x" type="number" class="form-control" min="-100" max="100" value="0">
                        <small class="text-muted">Valores negativos movem para esquerda, positivos para direita</small>
                      </div>
                      <div class="col-md-6">
                        <label class="form-label">Deslocamento Y (pixels)</label>
                        <input id="label-offset-y" type="number" class="form-control" min="-100" max="100" value="0">
                        <small class="text-muted">Valores negativos movem para cima, positivos para baixo</small>
                      </div>

                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-collision-detection" checked>
                          <label class="form-check-label" for="label-collision-detection">
                            <strong>Detecção de Sobreposição</strong>
                          </label>
                          <small class="text-muted d-block">Evita sobreposição automática de rótulos</small>
                        </div>
                      </div>

                      <div class="col-md-4">
                        <label class="form-label">Distância Mínima (pixels)</label>
                        <input id="label-min-distance" type="number" class="form-control" min="0" max="100" value="10">
                        <small class="text-muted">Distância mínima entre rótulos</small>
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Prioridade</label>
                        <select id="label-priority" class="form-select">
                          <option value="high">Alta</option>
                          <option value="medium" selected>Média</option>
                          <option value="low">Baixa</option>
                        </select>
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Máximo por Tela</label>
                        <input id="label-max-per-screen" type="number" class="form-control" min="0" max="1000" value="100">
                        <small class="text-muted">0 = ilimitado</small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Setas e Linhas de Chamada -->
              <div class="col-md-12">
                <div class="card border-secondary">
                  <div class="card-header bg-secondary text-white">
                    <h6 class="mb-0"><i class="fas fa-long-arrow-alt-right"></i> Setas e Linhas de Chamada</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-callout-enabled">
                          <label class="form-check-label" for="label-callout-enabled">
                            <strong>Habilitar Linhas de Chamada</strong>
                          </label>
                          <small class="text-muted d-block">Conecta rótulos deslocados ao ponto original com setas</small>
                        </div>
                      </div>

                      <div class="col-md-3">
                        <label class="form-label">Cor da Linha</label>
                        <input id="label-callout-color" type="color" class="form-control form-control-color" value="#666666">
                      </div>
                      <div class="col-md-3">
                        <label class="form-label">Espessura da Linha</label>
                        <input id="label-callout-width" type="number" class="form-control" min="0.5" max="10" value="1" step="0.5">
                      </div>
                      <div class="col-md-3">
                        <label class="form-label">Estilo da Linha</label>
                        <select id="label-callout-style" class="form-select">
                          <option value="solid">Sólida</option>
                          <option value="dashed">Tracejada</option>
                          <option value="dotted">Pontilhada</option>
                        </select>
                      </div>
                      <div class="col-md-3">
                        <label class="form-label">Opacidade da Linha</label>
                        <input id="label-callout-opacity" type="range" class="form-range" min="0" max="1" step="0.05" value="0.7">
                        <small class="text-muted">Valor: <span id="callout-opacity-value">0.7</span></small>
                      </div>

                      <div class="col-md-4">
                        <label class="form-label">Tipo de Seta</label>
                        <select id="label-arrow-type" class="form-select">
                          <option value="none">Sem Seta</option>
                          <option value="simple" selected>Seta Simples</option>
                          <option value="filled">Seta Preenchida</option>
                          <option value="double">Seta Dupla</option>
                          <option value="circle">Círculo</option>
                        </select>
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Tamanho da Seta</label>
                        <input id="label-arrow-size" type="number" class="form-control" min="2" max="20" value="6">
                      </div>
                      <div class="col-md-4">
                        <label class="form-label">Distância Máxima</label>
                        <input id="label-callout-max-distance" type="number" class="form-control" min="10" max="200" value="50">
                        <small class="text-muted">Distância máxima da linha de chamada</small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Filtros e Condições -->
              <div class="col-md-12">
                <div class="card border-dark">
                  <div class="card-header bg-dark text-white">
                    <h6 class="mb-0"><i class="fas fa-filter"></i> Filtros e Condições</h6>
                  </div>
                  <div class="card-body">
                    <div class="row g-3">
                      <div class="col-md-6">
                        <label class="form-label">Zoom Mínimo</label>
                        <input id="label-min-zoom" type="number" class="form-control" min="1" max="20" value="1">
                        <small class="text-muted">Zoom mínimo para exibir rótulos</small>
                      </div>
                      <div class="col-md-6">
                        <label class="form-label">Zoom Máximo</label>
                        <input id="label-max-zoom" type="number" class="form-control" min="1" max="20" value="20">
                        <small class="text-muted">Zoom máximo para exibir rótulos</small>
                      </div>

                      <div class="col-md-12">
                        <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="label-filter-enabled">
                          <label class="form-check-label" for="label-filter-enabled">
                            <strong>Habilitar Filtro por Expressão</strong>
                          </label>
                          <small class="text-muted d-block">Exibe rótulos apenas para features que atendem a condição</small>
                        </div>
                      </div>

                      <div class="col-md-12">
                        <label class="form-label">Expressão de Filtro</label>
                        <textarea id="label-filter-expression" class="form-control" rows="2" placeholder="Ex: valor > 100 OR categoria = 'importante'"></textarea>
                        <small class="text-muted">Use operadores: >, <, =, !=, AND, OR, LIKE</small>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Botões de Ação -->
              <div class="col-md-12 mt-4">
                <div class="d-flex gap-2">
                  <button type="button" id="btn-apply-labels" class="btn btn-success">
                    <i class="fas fa-font"></i> Aplicar Rótulos
                  </button>
                  <button type="button" id="btn-preview-labels" class="btn btn-info">
                    <i class="fas fa-eye"></i> Pré-visualizar
                  </button>
                  <button type="button" id="btn-reset-labels" class="btn btn-warning">
                    <i class="fas fa-undo"></i> Resetar
                  </button>
                </div>
                <small class="text-muted d-block mt-1">Clique em "Aplicar Rótulos" para salvar as configurações no mapa</small>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    <div class="col-lg-6">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0">Pré-visualização</h5>
        </div>
        <div class="card-body">
          <div class="d-flex justify-content-between align-items-center mb-3">
            <button id="btn-apply" class="btn btn-primary btn-sm">Aplicar Simbologia</button>
            <a class="btn btn-secondary btn-sm" href="{{ url_for('admin_dashboard') }}">Cancelar</a>
          </div>
          <div class="mb-2">
            <label class="form-label">Basemap:</label>
            <select id="basemap-select" class="form-select form-select-sm">
              <option value="osm">OpenStreetMap</option>
              <option value="google-streets">Google Streets</option>
              <option value="google-satellite">Google Satellite</option>
              <option value="google-hybrid">Google Hybrid</option>
              <option value="google-terrain">Google Terrain</option>
            </select>
          </div>
          <div id="symbology-map" style="height: 50vh; min-height: 400px; width: 100%;" class="mb-3 border rounded"></div>
          <div id="preview-legend" class="mb-2"></div>
          <div class="text-muted small">A legenda acima reflete a configuração atual e será exibida no portal.</div>
        </div>
      </div>
    </div>
  </div>


  </div>
</div>
{% endblock %}
{% block scripts %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  let map, layerData, currentLayer, currentBasemap;
  const layerId = {{ layer.id }};
  
  // Paletas de Cores Aprovadas para WebGIS
  const paletasAprovadas = {
    "sequencial": {
      "Viridis": ['#440154', '#472d7b', '#3b528b', '#2c728e', '#21918c', '#28ae80', '#5ec962', '#addc30', '#fde725'],
      "Cividis": ['#00224e', '#1a386f', '#434e6c', '#61656f', '#7d7c78', '#9b9476', '#bcae6c', '#dec958', '#fee838'],
      "Blues": ['#f7fbff', '#deebf7', '#c6dbef', '#9dcae1', '#6aaed6', '#4191c6', '#2070b4', '#08509b', '#08306b'],
      "Greens": ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a0d99b', '#73c476', '#40aa5d', '#228a44', '#006c2c', '#00441b'],
      "YlOrRd": ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8c3c', '#fc4d2a', '#e2191c', '#bb0026', '#800026'],
      "Purples": ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807cba', '#6950a3', '#53268f', '#3f007d'],
      "Greys": ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#959595', '#727272', '#515151', '#242424', '#000000']
    },
    "divergente": {
      "RdYlBu": ['#a50026', '#d62f27', '#f46d43', '#fdad60', '#fee090', '#feffc0', '#e0f3f8', '#aad8e9', '#74add1', '#4574b3', '#313695'],
      "RdYlGn": ['#a50026', '#d62f27', '#f46d43', '#fdad60', '#fee08b', '#feffbe', '#d9ef8b', '#a5d86a', '#66bd63', '#199750', '#006837'],
      "BrBG": ['#543005', '#8b500a', '#bf812d', '#dec17b', '#f6e8c3', '#f4f5f5', '#c7eae5', '#7fccc0', '#35978f', '#01655d', '#003c30'],
      "PiYG": ['#8e0152', '#c41a7c', '#de77ae', '#f1b5d9', '#fde0ef', '#f7f7f6', '#e6f5d0', '#b7e085', '#7fbc41', '#4c9121', '#276419'],
      "Coolwarm": ['#3b4cc0', '#5977e3', '#7b9ff9', '#9ebeff', '#c0d4f5', '#dddcdc', '#f2cbb7', '#f7ac8e', '#ee8468', '#d65244', '#b40426'],
      "Spectral": ['#9e0142', '#d43d4f', '#f46d43', '#fdad60', '#fee08b', '#ffffbe', '#e6f598', '#abdda4', '#66c2a5', '#3387bc', '#5e4fa2']
    },
    "qualitativo": {
      "Vivid (Início Verde)": ['#16d916', '#16d98b', '#16b2d9', '#163dd9', '#6416d9', '#d916d9', '#d91664', '#d93d16', '#d9b216', '#8bd916'],
      "Vivid (Início Azul)": ['#1616d9', '#8b16d9', '#d916b2', '#d9163d', '#d96416', '#d9d916', '#64d916', '#16d93d', '#16d9b2', '#168bd9'],
      "Tableau Tab10": ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
      "ColorBrewer Paired": ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a6a6a', '#ffff99', '#b15928'],
      "ColorBrewer Set3": ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f']
    }
  };

  // Paletas ColorBrewer expandidas (mantidas para compatibilidade)
  const colorBrewer = {
    sequential: ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'BuGn', 'BuPu', 'GnBu', 'OrRd', 'PuBu', 'PuRd', 'RdPu', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd'],
    diverging: ['RdBu', 'RdYlBu', 'RdYlGn', 'BrBG', 'PiYG', 'PRGn', 'PuOr', 'Spectral'],
    qualitative: ['Set1', 'Set2', 'Set3', 'Paired', 'Accent', 'Dark2', 'Pastel1', 'Pastel2', 'tab10', 'tab20', 'tab20b', 'tab20c']
  };

  // Função para gerar cores únicas baseadas em HSL
  function generateUniqueColors(count) {
    // Limitar a 1000 cores para performance
    const maxCount = Math.min(count, 1000);
    const colors = [];
    const hueStep = 360 / maxCount;
    const saturation = 70; // 70% saturation
    const lightness = 60;  // 60% lightness
    
    for (let i = 0; i < maxCount; i++) {
      const hue = (i * hueStep) % 360;
      colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
    }
    return colors;
  }
  
  // Função para expandir paleta para qualquer número de cores usando interpolação
  function expandPalette(paletteColors, targetCount) {
    // Limitar a 1000 cores para performance
    const maxTargetCount = Math.min(targetCount, 1000);
    
    if (maxTargetCount <= paletteColors.length) {
      return paletteColors;
    }
    
    const colors = [];
    const step = (paletteColors.length - 1) / (maxTargetCount - 1);
    
    for (let i = 0; i < maxTargetCount; i++) {
      const index = i * step;
      const lowerIndex = Math.floor(index);
      const upperIndex = Math.min(lowerIndex + 1, paletteColors.length - 1);
      const fraction = index - lowerIndex;
      
      if (fraction === 0) {
        colors.push(paletteColors[lowerIndex]);
      } else {
        const lowerColor = hexToRgb(paletteColors[lowerIndex]);
        const upperColor = hexToRgb(paletteColors[upperIndex]);
        
        if (lowerColor && upperColor) {
          const r = Math.round(lowerColor.r + (upperColor.r - lowerColor.r) * fraction);
          const g = Math.round(lowerColor.g + (upperColor.g - lowerColor.g) * fraction);
          const b = Math.round(lowerColor.b + (upperColor.b - lowerColor.b) * fraction);
          colors.push(rgbToHex(r, g, b));
        } else {
          colors.push(paletteColors[lowerIndex]);
        }
      }
    }
    
    return colors;
  }

  // Função para converter HSL para HEX
  function hslToHex(h, s, l) {
    s /= 100;
    l /= 100;
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h / 60) % 2 - 1));
    const m = l - c/2;
    let r = 0, g = 0, b = 0;
    if (0 <= h && h < 60) {
      r = c; g = x; b = 0;
    } else if (60 <= h && h < 120) {
      r = x; g = c; b = 0;
    } else if (120 <= h && h < 180) {
      r = 0; g = c; b = x;
    } else if (180 <= h && h < 240) {
      r = 0; g = x; b = c;
    } else if (240 <= h && h < 300) {
      r = x; g = 0; b = c;
    } else if (300 <= h && h < 360) {
      r = c; g = 0; b = x;
    }
    const rHex = Math.round((r + m) * 255).toString(16).padStart(2, '0');
    const gHex = Math.round((g + m) * 255).toString(16).padStart(2, '0');
    const bHex = Math.round((b + m) * 255).toString(16).padStart(2, '0');
    return `#${rHex}${gHex}${bHex}`;
  }

  // Função para converter HEX para RGB
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  // Função para converter RGB para HEX
  function rgbToHex(r, g, b) {
    const toHex = (n) => {
      const hex = Math.max(0, Math.min(255, n)).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }

  // Função para validar código HEX
  function isValidHex(hex) {
    return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);
  }

  // Função para limpar cores personalizadas de um campo
  function clearCustomColors(field) {
    if (field) {
      let clearedCount = 0;
      
      // Limpar cores personalizadas da simbologia graduada
      for (let i = 0; i < 20; i++) { // Limpar até 20 classes para garantir
        if (localStorage.getItem(`graduated_class_color_${layerId}_${field}_${i}`)) {
          localStorage.removeItem(`graduated_class_color_${layerId}_${field}_${i}`);
          clearedCount++;
        }
      }
      
      // Limpar cores personalizadas das categorias da legenda composta
      const categoryColors = Object.keys(localStorage).filter(key => 
        key.startsWith(`category_color_${layerId}_`)
      );
      
      categoryColors.forEach(key => {
        localStorage.removeItem(key);
        clearedCount++;
      });
      
      // Mostrar notificação se cores foram limpas
      if (clearedCount > 0) {
        showToast(`Cores personalizadas resetadas para a nova paleta selecionada`, 'info');
      }
    }
  }

  // Função para atualizar cor de uma classe
  function updateClassColor(index, newColor) {
    // Atualizar preview da cor
    const colorPreview = document.querySelector(`.color-preview[data-index="${index}"]`);
    if (colorPreview) {
      colorPreview.style.backgroundColor = newColor;
    }
    
    // Atualizar seletor de cor
    const colorInput = document.querySelector(`.graduated-class-color[data-index="${index}"]`);
    if (colorInput) {
      colorInput.value = newColor;
    }
    
    // Atualizar campo HEX
    const hexInput = document.querySelector(`.graduated-class-hex[data-index="${index}"]`);
    if (hexInput) {
      hexInput.value = newColor;
    }
    
    // Atualizar campos RGB
    const rgb = hexToRgb(newColor);
    if (rgb) {
      const rgbInputs = document.querySelector(`.graduated-class-rgb-inputs[data-index="${index}"]`);
      if (rgbInputs) {
        const rInput = rgbInputs.querySelector('input[placeholder="R"]');
        const gInput = rgbInputs.querySelector('input[placeholder="G"]');
        const bInput = rgbInputs.querySelector('input[placeholder="B"]');
        if (rInput) rInput.value = rgb.r;
        if (gInput) gInput.value = rgb.g;
        if (bInput) bInput.value = rgb.b;
      }
    }
    
    // Salvar cor personalizada no localStorage
    const field = document.getElementById('field-select').value;
    localStorage.setItem(`graduated_class_color_${layerId}_${field}_${index}`, newColor);
    
    // Atualizar preview do mapa
    renderMapPreview();
    
    // Forçar atualização da legenda
    setTimeout(() => {
      renderPreview();
    }, 100);
    
    // Salvar configuração
    saveUserConfig();
  }

  // Função para gerar cores da paleta com distribuição otimizada (usando paletas aprovadas primeiro)
  function brewer(palette, count, invert = false) {
    // Função auxiliar para distribuir cores de forma otimizada
    function distributeColorsOptimally(paletteColors, numClasses) {
      if (numClasses <= 0) return [];
      if (numClasses === 1) return [paletteColors[0]];
      if (numClasses === 2) return [paletteColors[0], paletteColors[paletteColors.length - 1]];
      
      // Limitar a 1000 classes para performance
      const maxClasses = Math.min(numClasses, 1000);
      
      const result = [];
      result.push(paletteColors[0]); // Primeira classe sempre recebe primeira cor
      
      // Distribuir cores intermediárias uniformemente
      if (maxClasses > 2) {
        const step = (paletteColors.length - 1) / (maxClasses - 1);
        for (let i = 1; i < maxClasses - 1; i++) {
          const index = Math.round(i * step);
          result.push(paletteColors[index]);
        }
      }
      
      result.push(paletteColors[paletteColors.length - 1]); // Última classe sempre recebe última cor
      
      return result;
    }
    
    // Primeiro, tentar usar as paletas aprovadas
    for (const category in paletasAprovadas) {
      if (paletasAprovadas[category][palette]) {
        const paletteColors = paletasAprovadas[category][palette];
        // Expandir paleta para o número de cores solicitado (até 1000)
        const expandedColors = expandPalette(paletteColors, Math.min(count, 1000));
        let selectedColors = distributeColorsOptimally(expandedColors, Math.min(count, 1000));
        if (invert) {
          selectedColors = selectedColors.reverse();
        }
        return selectedColors;
      }
    }
    
    // Segundo, tentar usar paletas personalizadas
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    const customPalette = customPalettes.find(p => p.name === palette);
    if (customPalette) {
      const paletteColors = customPalette.colors;
      // Expandir paleta para o número de cores solicitado (até 1000)
      const expandedColors = expandPalette(paletteColors, Math.min(count, 1000));
      let selectedColors = distributeColorsOptimally(expandedColors, Math.min(count, 1000));
      if (invert) {
        selectedColors = selectedColors.reverse();
      }
      return selectedColors;
    }
    
    // Fallback para paletas ColorBrewer originais
    const palettes = {
      // Sequential palettes
      'viridis': ['#440154', '#482878', '#3e4989', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6ece58', '#b5de2b', '#fde725'],
      'plasma': ['#0d0887', '#41049d', '#6a00a8', '#8f0aa4', '#b12a90', '#cc4778', '#e16462', '#f1834b', '#fca636', '#fcce25'],
      'inferno': ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c5c', '#cf4446', '#ed6925', '#f58b49', '#fdb42f', '#fce762'],
      'magma': ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c5c', '#cf4446', '#ed6925', '#f58b49', '#fdb42f', '#fce762'],
      'cividis': ['#00224f', '#123a5a', '#2d4f69', '#446475', '#5b7a7c', '#729083', '#8aa68a', '#a3bc93', '#bdd3a8', '#d8e5be'],
      'Blues': ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
      'Greens': ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
      'Reds': ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
      'Oranges': ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#e6550d', '#a63603', '#7f2704'],
      'Purples': ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
      
      // Diverging palettes
      'RdBu': ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
      'RdYlBu': ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
      'RdYlGn': ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
      'BrBG': ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
      'PiYG': ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
      'PRGn': ['#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
      'PuOr': ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
      'Spectral': ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
      
      // Qualitative palettes
      'Set1': ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
      'Set2': ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
      'Set3': ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
      'Paired': ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a6a6a', '#ffff99', '#b15928'],
      'Accent': ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
      'Dark2': ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
      'Pastel1': ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2'],
      'Pastel2': ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
      'tab10': ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'],
      'tab20': ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'],
      'tab20b': ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'],
      'tab20c': ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9']
    };
    
    if (palettes[palette]) {
      const paletteColors = palettes[palette];
      // Expandir paleta para o número de cores solicitado (até 1000)
      const expandedColors = expandPalette(paletteColors, Math.min(count, 1000));
      let selectedColors = distributeColorsOptimally(expandedColors, Math.min(count, 1000));
      if (invert) {
        selectedColors = selectedColors.reverse();
        // Manter a lógica de extremos mesmo após inversão
        if (count > 2) {
          const temp = selectedColors[0];
          selectedColors[0] = selectedColors[selectedColors.length - 1];
          selectedColors[selectedColors.length - 1] = temp;
        }
      }
      return selectedColors;
    }
    
    // Fallback para cores únicas (limitado a 1000 cores)
    const maxCount = Math.min(count, 1000);
    let fallbackColors = generateUniqueColors(maxCount).map(color => {
      const match = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
      if (match) {
        return hslToHex(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]));
      }
      return color;
    });
    
    if (invert) {
      fallbackColors = fallbackColors.reverse();
    }
    
    return fallbackColors;
  }

  // Função para carregar paletas personalizadas
  function loadCustomPalettes() {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    const customGroup = document.getElementById('custom-palettes-group');
    
    // Limpar opções existentes mas manter o label
    customGroup.innerHTML = '<div class="palette-optgroup-label">Paletas Criadas pelo Usuário</div>';
    
    if (customPalettes.length === 0) {
      // Se não há paletas, mostrar mensagem informativa
      const emptyMessage = document.createElement('div');
      emptyMessage.className = 'palette-empty-message';
      emptyMessage.innerHTML = `
        <div style="padding: 10px; color: #6c757d; font-style: italic; text-align: center;">
          <i class="fas fa-palette"></i> Nenhuma paleta personalizada criada ainda.
          <br><small>Use "Criar Nova Paleta" para começar!</small>
        </div>
      `;
      customGroup.appendChild(emptyMessage);
      return;
    }
    
    customPalettes.forEach(palette => {
      const option = document.createElement('div');
      option.className = 'palette-option';
      option.dataset.value = palette.name;
      option.dataset.type = 'custom';
      
      // Criar preview da paleta
      const preview = document.createElement('div');
      preview.className = 'palette-preview-mini';
      preview.dataset.palette = palette.name;
      
      // Aplicar cores da paleta ao preview
      if (palette.colors && palette.colors.length > 0) {
        const gradientColors = palette.colors.map(color => color).join(', ');
        preview.style.background = `linear-gradient(to right, ${gradientColors})`;
      }
      
      // Criar texto da opção
      const text = document.createElement('span');
      text.textContent = `${palette.name} - ${palette.description}`;
      
      // Adicionar elementos à opção
      option.appendChild(preview);
      option.appendChild(text);
      
      // Adicionar evento de clique
      option.addEventListener('click', function() {
        // Selecionar a paleta
        document.getElementById('palette-select').value = palette.name;
        document.getElementById('palette-select-text').textContent = `${palette.name} - ${palette.description}`;
        
        // Fechar dropdown
        document.getElementById('palette-select-dropdown').classList.add('d-none');
        
        // Atualizar preview da paleta imediatamente
        updatePalettePreview();
        
        // Disparar evento de mudança após a atualização visual
        setTimeout(() => {
          const changeEvent = new Event('change', { bubbles: true });
          document.getElementById('palette-select').dispatchEvent(changeEvent);
        }, 50);
      });
      
      customGroup.appendChild(option);
    });
    
    // Atualizar previews das paletas personalizadas
    updateCustomPalettePreviews();
  }
  
  // Função para atualizar previews das paletas personalizadas
  function updateCustomPalettePreviews() {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    
    customPalettes.forEach(palette => {
      const previewElement = document.querySelector(`[data-palette="${palette.name}"]`);
      if (previewElement && palette.colors && palette.colors.length > 0) {
        const gradientColors = palette.colors.map(color => color).join(', ');
        previewElement.style.background = `linear-gradient(to right, ${gradientColors})`;
      }
    });
  }

  // Função para exibir modal de confirmação customizado
  function showConfirmDialog(message, onConfirm, onCancel = null) {
    // Remover modal existente se houver
    const existingModal = document.querySelector('.confirm-dialog-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Criar modal de confirmação
    const modal = document.createElement('div');
    modal.className = 'confirm-dialog-modal';
    modal.innerHTML = `
      <div class="confirm-dialog-content">
        <div class="confirm-dialog-header">
          <i class="fas fa-exclamation-triangle"></i>
          <h4>Confirmação</h4>
        </div>
        <div class="confirm-dialog-body">
          <p>${message}</p>
        </div>
        <div class="confirm-dialog-footer">
          <button type="button" class="btn-cancel" id="btn-cancel-confirm">
            <i class="fas fa-times"></i> Cancelar
          </button>
          <button type="button" class="btn-confirm" id="btn-confirm-ok">
            <i class="fas fa-check"></i> Confirmar
          </button>
        </div>
      </div>
    `;
    
    // Adicionar ao DOM
    document.body.appendChild(modal);
    
    // Event listeners
    const confirmBtn = modal.querySelector('#btn-confirm-ok');
    const cancelBtn = modal.querySelector('#btn-cancel-confirm');
    
    confirmBtn.addEventListener('click', () => {
      modal.remove();
      if (onConfirm) onConfirm();
    });
    
    cancelBtn.addEventListener('click', () => {
      modal.remove();
      if (onCancel) onCancel();
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
        if (onCancel) onCancel();
      }
    });
    
    // Escape para fechar
    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        modal.remove();
        if (onCancel) onCancel();
      }
    });
    
    // Foco automático no botão de confirmação
    setTimeout(() => confirmBtn.focus(), 100);
  }
  
  // Função para salvar paleta personalizada
  function saveCustomPalette(name, description, colors, paletteData = null) {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    
    // Verificar se já existe uma paleta com esse nome
    const existingIndex = customPalettes.findIndex(p => p.name === name);
    
    if (existingIndex !== -1) {
      // Usar modal customizado em vez de confirm padrão
      showConfirmDialog(
        `Paleta <strong>"${name}"</strong> já existe. Deseja substituir?`,
        () => {
          // Usuário confirmou - substituir paleta
          customPalettes.splice(existingIndex, 1);
          savePaletteAndContinue();
        },
        () => {
          // Usuário cancelou
          return;
        }
      );
      return;
    }
    
    // Se não existe, salvar diretamente
    savePaletteAndContinue();
    
    // Função auxiliar para salvar a paleta
    function savePaletteAndContinue() {
      // Usar paletteData se fornecido, senão criar um novo
      const finalPaletteData = paletteData || {
        name: name,
        description: description,
        colors: colors,
        created: new Date().toISOString()
      };
      
      customPalettes.push(finalPaletteData);
      localStorage.setItem('custom_palettes', JSON.stringify(customPalettes));
      loadCustomPalettes();
      
      // Selecionar a paleta recém-criada
      document.getElementById('palette-select').value = name;
      updatePalettePreview();
    }
  }

  // Função para criar nova paleta
  function createNewPalette() {
    // Criar modal moderno
    const modal = document.createElement('div');
    modal.className = 'custom-palette-modal';
    modal.innerHTML = `
      <div class="custom-palette-modal-content">
        <div class="custom-palette-modal-header">
          <h3><i class="fas fa-palette"></i> Criar Nova Paleta de Cores</h3>
          <button type="button" class="btn-close-modal">
            <i class="fas fa-times"></i>
          </button>
        </div>
        
        <div class="custom-palette-modal-body">
          <div class="form-group">
            <label for="palette-name">
              <i class="fas fa-tag"></i> Nome da Paleta *
            </label>
            <input type="text" id="palette-name" placeholder="Ex: Minha Paleta Personalizada" maxlength="50">
          </div>
          
          <div class="form-group">
            <label for="palette-description">
              <i class="fas fa-info-circle"></i> Descrição
            </label>
            <textarea id="palette-description" placeholder="Descreva o uso ou tema da paleta..." maxlength="200" rows="2"></textarea>
          </div>
          
          <div class="form-group">
            <label for="palette-type">
              <i class="fas fa-layer-group"></i> Tipo de Paleta
            </label>
            <select id="palette-type">
              <option value="custom">Personalizada</option>
              <option value="sequential">Sequencial</option>
              <option value="divergent">Divergente</option>
              <option value="qualitative">Qualitativa</option>
            </select>
          </div>
          
          <div class="form-group">
            <label>
              <i class="fas fa-paint-brush"></i> Quantidade de Cores
            </label>
            <div class="color-count-controls">
              <button type="button" class="btn-count" data-action="decrease">-</button>
              <span id="color-count-display">5</span>
              <button type="button" class="btn-count" data-action="increase">+</button>
              <span class="color-count-info">(3-1000 cores)</span>
            </div>
            <div class="mt-2">
              <input type="number" id="color-count-input" class="form-control" placeholder="Digite um número específico" min="3" max="1000" value="5">
            </div>
          </div>
          
          <div class="form-group">
            <label>
              <i class="fas fa-palette"></i> Cores da Paleta
            </label>
            <div id="palette-colors-container">
              <!-- Cores serão geradas dinamicamente -->
            </div>
          </div>
          
          <div class="form-group">
            <label>
              <i class="fas fa-palette"></i> Paleta Personalizada
            </label>
            <div class="palette-preview-container">
              <div id="palette-preview" class="palette-preview">
                <!-- Preview da paleta será gerado dinamicamente -->
              </div>
              <div class="palette-preview-info">
                <small class="text-muted">
                  <i class="fas fa-info-circle"></i> 
                  Preview em tempo real da sua paleta personalizada
                </small>
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label>
              <i class="fas fa-magic"></i> Ferramentas Rápidas
            </label>
            <div class="quick-tools">
              <button type="button" class="btn-quick-tool" data-action="generate-harmonious">
                <i class="fas fa-magic"></i> Divergente
              </button>
              <button type="button" class="btn-quick-tool" data-action="generate-gradient">
                <i class="fas fa-gradient"></i> Gradiente
              </button>
              <button type="button" class="btn-quick-tool" data-action="randomize">
                <i class="fas fa-random"></i> Aleatória
              </button>
              <button type="button" class="btn-quick-tool" data-action="clear-all">
                <i class="fas fa-trash"></i> Limpar
              </button>
            </div>
          </div>
        </div>
        
        <div class="custom-palette-modal-footer">
          <button type="button" class="btn btn-secondary" id="btn-cancel-palette">
            <i class="fas fa-times"></i> Cancelar
          </button>
          <button type="button" class="btn btn-primary" id="btn-save-palette">
            <i class="fas fa-save"></i> Salvar Paleta
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Inicializar controles
    let colorCount = 5;
    const colorCountDisplay = modal.querySelector('#color-count-display');
    const colorsContainer = modal.querySelector('#palette-colors-container');
    
    // Função para gerar interface de cores
    function generateColorInputs(count) {
      colorsContainer.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const colorItem = document.createElement('div');
        colorItem.className = 'palette-color-item';
        colorItem.innerHTML = `
          <div class="color-item-header">
            <span class="color-number">Cor ${i + 1}</span>
          </div>
          <div class="color-inputs">
            <div class="color-input-group">
              <label>Seletor:</label>
              <input type="color" class="color-picker" value="#007bff" data-index="${i}">
            </div>
            <div class="color-input-group">
              <label>HEX:</label>
              <input type="text" class="color-hex" value="#007bff" placeholder="#000000" maxlength="7" data-index="${i}">
            </div>
            <div class="color-input-group">
              <label>RGB:</label>
              <div class="rgb-inputs">
                <input type="number" class="rgb-r" placeholder="R" min="0" max="255" value="0" data-index="${i}">
                <input type="number" class="rgb-g" placeholder="G" min="0" max="255" value="123" data-index="${i}">
                <input type="number" class="rgb-b" placeholder="B" min="0" max="255" value="255" data-index="${i}">
              </div>
            </div>
          </div>
        `;
        colorsContainer.appendChild(colorItem);
      }
      
      // Adicionar event listeners para as cores
      addColorEventListeners();
    }
    
    // Função para adicionar event listeners das cores
    function addColorEventListeners() {
      const colorPickers = colorsContainer.querySelectorAll('.color-picker');
      const hexInputs = colorsContainer.querySelectorAll('.color-hex');
      const rgbInputs = colorsContainer.querySelectorAll('.rgb-r, .rgb-g, .rgb-b');
      
      colorPickers.forEach((picker, index) => {
        picker.addEventListener('input', (e) => {
          const color = e.target.value;
          updateColorFromPicker(index, color);
        });
      });
      
      hexInputs.forEach((hexInput, index) => {
        hexInput.addEventListener('input', (e) => {
          const color = e.target.value;
          if (isValidHex(color)) {
            updateColorFromHex(index, color);
          }
        });
      });
      
      rgbInputs.forEach((rgbInput) => {
        rgbInput.addEventListener('input', (e) => {
          const index = parseInt(e.target.dataset.index);
          updateColorFromRGB(index);
        });
      });
    }
    
    // Funções de atualização de cores
    function updateColorFromPicker(index, color) {
      const hexInput = colorsContainer.querySelector(`.color-hex[data-index="${index}"]`);
      const colorPicker = colorsContainer.querySelector(`.color-picker[data-index="${index}"]`);
      
      if (hexInput) hexInput.value = color;
      if (colorPicker) colorPicker.value = color;
      
      const rgb = hexToRgb(color);
      if (rgb) {
        const rInput = colorsContainer.querySelector(`.rgb-r[data-index="${index}"]`);
        const gInput = colorsContainer.querySelector(`.rgb-g[data-index="${index}"]`);
        const bInput = colorsContainer.querySelector(`.rgb-b[data-index="${index}"]`);
        if (rInput) rInput.value = rgb.r;
        if (gInput) gInput.value = rgb.g;
        if (bInput) bInput.value = rgb.b;
      }
      
      // NÃO atualizar preview aqui - será feito pela função chamadora
    }
    
    function updateColorFromHex(index, color) {
      if (!isValidHex(color)) return;
      
      const colorPicker = colorsContainer.querySelector(`.color-picker[data-index="${index}"]`);
      
      if (colorPicker) colorPicker.value = color;
      
      const rgb = hexToRgb(color);
      if (rgb) {
        const rInput = colorsContainer.querySelector(`.rgb-r[data-index="${index}"]`);
        const gInput = colorsContainer.querySelector(`.rgb-g[data-index="${index}"]`);
        const bInput = colorsContainer.querySelector(`.rgb-b[data-index="${index}"]`);
        if (rInput) rInput.value = rgb.r;
        if (gInput) gInput.value = rgb.g;
        if (bInput) bInput.value = rgb.b;
      }
      
      // Atualizar preview da paleta dentro do modal
      updateModalPalettePreview();
    }
    
    function updateColorFromRGB(index) {
      const rInput = colorsContainer.querySelector(`.rgb-r[data-index="${index}"]`);
      const gInput = colorsContainer.querySelector(`.rgb-g[data-index="${index}"]`);
      const bInput = colorsContainer.querySelector(`.rgb-b[data-index="${index}"]`);
      
      if (!rInput || !gInput || !bInput) return;
      
      const r = parseInt(rInput.value) || 0;
      const g = parseInt(gInput.value) || 0;
      const b = parseInt(bInput.value) || 0;
      
      if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) return;
      
      const hex = rgbToHex(r, g, b);
      const colorPicker = colorsContainer.querySelector(`.color-picker[data-index="${index}"]`);
      const hexInput = colorsContainer.querySelector(`.color-hex[data-index="${index}"]`);
      
      if (colorPicker) colorPicker.value = hex;
      if (hexInput) hexInput.value = hex;
      
      // Atualizar preview da paleta dentro do modal
      updateModalPalettePreview();
    }
    
    // Controles de quantidade
    modal.querySelectorAll('.btn-count').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const action = e.target.dataset.action;
        if (action === 'increase' && colorCount < 1000) {
          colorCount++;
        } else if (action === 'decrease' && colorCount > 3) {
          colorCount--;
        }
        colorCountDisplay.textContent = colorCount;
        generateColorInputs(colorCount);
      });
    });
    
    // Input direto para quantidade de cores
    const colorCountInput = modal.querySelector('#color-count-input');
    colorCountInput.addEventListener('input', (e) => {
      const newCount = parseInt(e.target.value) || 5;
      if (newCount >= 3 && newCount <= 1000) {
        colorCount = newCount;
        colorCountDisplay.textContent = colorCount;
        generateColorInputs(colorCount);
      }
    });
    
    // Ferramentas rápidas
    modal.querySelectorAll('.btn-quick-tool').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const action = e.target.dataset.action;
        
        switch(action) {
          case 'generate-harmonious':
            generateHarmoniousColors(colorCount);
            break;
          case 'generate-gradient':
            generateGradientColors(colorCount);
            break;
          case 'randomize':
            generateRandomColors(colorCount);
            break;
          case 'clear-all':
            clearAllColors(colorCount);
            break;
        }
      });
    });
    
    // Funções das ferramentas rápidas - Versões Avançadas com Grande Variabilidade
    function generateHarmoniousColors(count) {
      console.log('generateHarmoniousColors (divergente) chamada com count:', count);
      
      // Escolher um esquema divergente aleatoriamente com grande variedade
      const schemes = [
        // PALETAS QUENTES (Vermelho/Laranja → Neutro → Frio)
        {
          name: 'Vermelho → Branco → Azul',
          startColor: '#67001f',    // Vermelho escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        },
        {
          name: 'Vermelho → Amarelo → Azul',
          startColor: '#a50026',    // Vermelho escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#313695'       // Azul escuro
        },
        {
          name: 'Vermelho → Amarelo → Verde',
          startColor: '#a50026',    // Vermelho escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#006837'       // Verde escuro
        },
        {
          name: 'Rosa → Amarelo → Azul',
          startColor: '#9e0142',    // Rosa escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#5e4fa2'       // Azul escuro
        },
        {
          name: 'Laranja → Branco → Roxo',
          startColor: '#7f3b08',    // Laranja escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#2d004b'       // Roxo escuro
        },
        {
          name: 'Vermelho → Branco → Cinza',
          startColor: '#67001f',    // Vermelho escuro
          middleColor: '#ffffff',   // Branco
          endColor: '#1a1a1a'       // Cinza escuro
        },
        
        // PALETAS NEUTRAS (Marrom/Terra → Neutro → Verde)
        {
          name: 'Marrom → Branco → Verde',
          startColor: '#543005',    // Marrom escuro
          middleColor: '#f5f5f5',   // Branco
          endColor: '#003c30'       // Verde escuro
        },
        {
          name: 'Rosa → Branco → Verde',
          startColor: '#8e0152',    // Rosa escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Roxo → Branco → Verde',
          startColor: '#40004b',    // Roxo escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        
        // PALETAS FRIAS (Azul/Ciano → Neutro → Verde)
        {
          name: 'Azul → Branco → Verde',
          startColor: '#053061',    // Azul escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Ciano → Branco → Verde',
          startColor: '#01665e',    // Ciano escuro
          middleColor: '#f5f5f5',   // Branco
          endColor: '#003c30'       // Verde escuro
        },
        {
          name: 'Azul → Amarelo → Verde',
          startColor: '#313695',    // Azul escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#006837'       // Verde escuro
        },
        
        // PALETAS ESPECIAIS (Divergentes únicas)
        {
          name: 'Dourado → Branco → Azul',
          startColor: '#b35806',    // Dourado escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        },
        {
          name: 'Violeta → Branco → Verde',
          startColor: '#762a83',    // Violeta escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        {
          name: 'Coral → Branco → Azul',
          startColor: '#d53e4f',    // Coral escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#5e4fa2'       // Azul escuro
        },
        {
          name: 'Oliva → Branco → Roxo',
          startColor: '#7fbc41',    // Oliva
          middleColor: '#f7f7f7',   // Branco
          endColor: '#2d004b'       // Roxo escuro
        },
        {
          name: 'Esmeralda → Branco → Rosa',
          startColor: '#1a9850',    // Esmeralda
          middleColor: '#f7f7f7',   // Branco
          endColor: '#8e0152'       // Rosa escuro
        },
        {
          name: 'Safira → Branco → Laranja',
          startColor: '#4575b4',    // Safira
          middleColor: '#f7f7f7',   // Branco
          endColor: '#b35806'       // Laranja escuro
        },
        {
          name: 'Rubi → Branco → Verde',
          startColor: '#d73027',    // Rubi
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Turquesa → Branco → Vermelho',
          startColor: '#66c2a5',    // Turquesa
          middleColor: '#f7f7f7',   // Branco
          endColor: '#a50026'       // Vermelho escuro
        },
        {
          name: 'Lavanda → Branco → Verde',
          startColor: '#9970ab',    // Lavanda
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        {
          name: 'Âmbar → Branco → Azul',
          startColor: '#fdae61',    // Âmbar
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        }
      ];
      
      const selectedScheme = schemes[Math.floor(Math.random() * schemes.length)];
      console.log('Esquema divergente selecionado:', selectedScheme.name);
      
      const colors = [];
      
      // Gerar sequência contínua: início → meio → fim
      for (let i = 0; i < count; i++) {
        const ratio = i / (count - 1);
        let color;
        
        if (ratio <= 0.5) {
          // Primeira metade: início → meio
          const localRatio = ratio * 2; // 0 → 1
          color = interpolateColors(selectedScheme.startColor, selectedScheme.middleColor, localRatio);
        } else {
          // Segunda metade: meio → fim
          const localRatio = (ratio - 0.5) * 2; // 0 → 1
          color = interpolateColors(selectedScheme.middleColor, selectedScheme.endColor, localRatio);
        }
        
        colors.push(color);
      }
      
      console.log('Paleta divergente contínua gerada:', colors);
      applyGeneratedColors(colors);
    }
    
    // Função para converter HSL para HEX
    function hslToHex(h, s, l) {
      l /= 100;
      const a = s * Math.min(l, 1 - l) / 100;
      const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
      };
      return `#${f(0)}${f(8)}${f(4)}`;
    }
    
    function generateGradientColors(count) {
      console.log('generateGradientColors chamada com count:', count);
      
      // Escolher aleatoriamente entre cores primárias e secundárias
      const gradientTypes = [
        // Cores primárias
        'red', 'green', 'blue', 'yellow', 'cyan', 'magenta',
        // Cores secundárias
        'orange', 'purple', 'pink', 'brown', 'teal', 'lime',
        // Cores terciárias
        'indigo', 'violet', 'gold', 'silver', 'copper', 'emerald',
        'sapphire', 'ruby', 'coral', 'olive', 'navy', 'maroon'
      ];
      
      const type = gradientTypes[Math.floor(Math.random() * gradientTypes.length)];
      const colors = [];
      
      // Gerar gradiente SEQUENCIAL (uma cor do claro ao escuro)
      for (let i = 0; i < count; i++) {
        const ratio = i / (count - 1);
        let hue, saturation, lightness;
        
        switch(type) {
          case 'red':
            hue = 0;
            saturation = 85; // Saturação fixa para consistência
            lightness = Math.round(90 - (ratio * 60)); // 90% (claro) → 30% (escuro)
            break;
          case 'green':
            hue = 120;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'blue':
            hue = 240;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'yellow':
            hue = 60;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'cyan':
            hue = 180;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'magenta':
            hue = 300;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'orange':
            hue = 30;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'purple':
            hue = 270;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'pink':
            hue = 330;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'brown':
            hue = 20;
            saturation = 75;
            lightness = Math.round(85 - (ratio * 65));
            break;
          case 'teal':
            hue = 180;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'lime':
            hue = 120;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'indigo':
            hue = 240;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'violet':
            hue = 270;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'gold':
            hue = 45;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'silver':
            hue = 0;
            saturation = 0;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'copper':
            hue = 20;
            saturation = 75;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'emerald':
            hue = 150;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'sapphire':
            hue = 210;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'ruby':
            hue = 0;
            saturation = 90;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'coral':
            hue = 15;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'olive':
            hue = 60;
            saturation = 60;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'navy':
            hue = 240;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          case 'maroon':
            hue = 0;
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
            break;
          default:
            hue = Math.round(Math.random() * 360);
            saturation = 85;
            lightness = Math.round(90 - (ratio * 60));
        }
        
        const color = hslToHex(hue, saturation, lightness);
        colors.push(color);
      }
      
      console.log('Gradiente SEQUENCIAL gerado:', colors);
      applyGeneratedColors(colors);
    }
    
    function generateRandomColors(count) {
      console.log('generateRandomColors chamada com count:', count);
      
      const colors = [];
      for (let i = 0; i < count; i++) {
        const hue = Math.round(Math.random() * 360);
        const saturation = Math.round(60 + Math.random() * 30);
        const lightness = Math.round(40 + Math.random() * 30);
        const color = hslToHex(hue, saturation, lightness);
        colors.push(color);
      }
      
      console.log('Cores aleatórias geradas:', colors);
      applyGeneratedColors(colors);
    }
    
    function clearAllColors(count) {
      const colors = [];
      for (let i = 0; i < count; i++) {
        colors.push('#cccccc');
      }
      applyGeneratedColors(colors);
    }
    
    function applyGeneratedColors(colors) {
      console.log('applyGeneratedColors chamada com:', colors);
      
      // Verificar se estamos no modal de criação de paletas
      const modal = document.querySelector('.custom-palette-modal');
      if (modal) {
        console.log('Estamos no modal de criação de paletas');
        
        // Estamos no modal - aplicar cores usando a função original
        colors.forEach((color, index) => {
          updateColorFromPicker(index, color);
        });
        
        // Atualizar preview da paleta após aplicar todas as cores
        updateModalPalettePreview();
      } else {
        // Estamos fora do modal - aplicar cores diretamente aos inputs existentes
        const colorPickers = document.querySelectorAll('.color-picker');
        const hexInputs = document.querySelectorAll('.color-hex');
        const rgbInputs = document.querySelectorAll('.rgb-r, .rgb-g, .rgb-b');
        
        colors.forEach((color, index) => {
          // Atualizar color picker
          if (colorPickers[index]) {
            colorPickers[index].value = color;
          }
          
          // Atualizar input HEX
          if (hexInputs[index]) {
            hexInputs[index].value = color;
          }
          
          // Atualizar inputs RGB
          if (rgbInputs[index * 3]) {
            const rgb = hexToRgb(color);
            if (rgb) {
              rgbInputs[index * 3].value = rgb.r;     // R
              rgbInputs[index * 3 + 1].value = rgb.g; // G
              rgbInputs[index * 3 + 2].value = rgb.b; // B
            }
          }
        });
        
        // Atualizar preview da paleta se existir
        const palettePreview = document.querySelector('#palette-preview');
        if (palettePreview) {
          updatePalettePreview();
        }
      }
    }
    
    // Botões de ação
    modal.querySelector('#btn-cancel-palette').addEventListener('click', () => {
      modal.remove();
    });
    
    modal.querySelector('#btn-save-palette').addEventListener('click', () => {
      const name = modal.querySelector('#palette-name').value.trim();
      const description = modal.querySelector('#palette-description').value.trim();
      const type = modal.querySelector('#palette-type').value;
      
      if (!name) {
        showToast('Nome da paleta é obrigatório!', 'error');
        return;
      }
      
      // Coletar cores
      const colors = [];
      const colorPickers = colorsContainer.querySelectorAll('.color-picker');
      colorPickers.forEach(picker => {
        colors.push(picker.value);
      });
      
      if (colors.length < 3) {
        showToast('Mínimo de 3 cores é necessário!', 'error');
        return;
      }
      
      // Salvar paleta
      const paletteData = {
        name: name,
        description: description,
        type: type,
        colors: colors,
        created: new Date().toISOString()
      };
      
      saveCustomPalette(name, description, colors, paletteData);
      showToast('Paleta criada com sucesso!', 'success');
      modal.remove();
      
      // Recarregar paletas
      loadCustomPalettes();
    });
    
    // Fechar modal com ESC ou clicando fora
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
    
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        modal.remove();
      }
    });
    
    // Função para atualizar preview da paleta dentro do modal
    function updateModalPalettePreview() {
      console.log('updateModalPalettePreview chamada');
      
      const previewContainer = modal.querySelector('#palette-preview');
      if (!previewContainer) {
        console.log('Preview container não encontrado');
        return;
      }
      
      const colorPickers = colorsContainer.querySelectorAll('.color-picker');
      const colors = Array.from(colorPickers).map(picker => picker.value);
      
      console.log('Cores encontradas nos color pickers:', colors);
      
      if (colors.length === 0) {
        console.log('Nenhuma cor encontrada');
        return;
      }
      
      // Limitar a exibição para não sobrecarregar visualmente
      const maxDisplayColors = Math.min(colors.length, 50);
      const step = Math.max(1, Math.floor(colors.length / maxDisplayColors));
      
      let previewHTML = '';
      for (let i = 0; i < maxDisplayColors; i++) {
        const colorIndex = i * step;
        const color = colors[colorIndex];
        previewHTML += `<div class="preview-color" style="background-color: ${color};" title="Cor ${colorIndex + 1}: ${color}"></div>`;
      }
      
      console.log('Preview HTML gerado:', previewHTML.substring(0, 100) + '...');
      previewContainer.innerHTML = previewHTML;
      
      // Adicionar contador de cores
      const colorCount = colors.length;
      const previewInfo = modal.querySelector('.palette-preview-info small');
      if (previewInfo) {
        previewInfo.innerHTML = `
          <i class="fas fa-info-circle"></i> 
          Preview em tempo real da sua paleta personalizada (${colorCount} cores)
        `;
      }
      
      console.log('Preview atualizado com sucesso');
    }
    
    // Gerar interface inicial
    generateColorInputs(colorCount);
    
    // Inicializar preview da paleta
    updateModalPalettePreview();
  }

  // Função global para gerar cores gradiente (disponível para todos os modais)
  function generateGradientColors(count) {
    console.log('generateGradientColors called with count:', count);
    
    // Escolher aleatoriamente entre diferentes tipos de gradientes baseados em cores predefinidas
    const gradientTypes = [
      'red',           // Vermelho: claro para escuro
      'green',         // Verde: claro para escuro
      'blue',          // Azul: claro para escuro
      'yellow',        // Amarelo: claro para escuro
      'cyan',          // Ciano: claro para escuro
      'magenta',       // Magenta: claro para escuro
      'orange',        // Laranja: claro para escuro
      'purple',        // Roxo: claro para escuro
      'pink',          // Rosa: claro para escuro
      'brown',         // Marrom: claro para escuro
      'teal',          // Verde-azulado: claro para escuro
      'lime',          // Lima: claro para escuro
      'indigo',        // Índigo: claro para escuro
      'violet',        // Violeta: claro para escuro
      'gold',          // Dourado: claro para escuro
      'silver',        // Prateado: claro para escuro
      'copper',        // Cobre: claro para escuro
      'emerald',       // Esmeralda: claro para escuro
      'sapphire',      // Safira: claro para escuro
      'ruby'           // Rubi: claro para escuro
    ];
    
    const type = gradientTypes[Math.floor(Math.random() * gradientTypes.length)];
    const colors = [];
    
    switch(type) {
      case 'red':
        // Vermelho: do mais claro ao mais escuro
        const redGradient = ['#FFE6E6', '#FFCCCC', '#FFB3B3', '#FF9999', '#FF8080', '#FF6666', '#FF4D4D', '#FF3333', '#FF1A1A', '#FF0000', '#E60000', '#CC0000', '#B30000', '#990000', '#800000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (redGradient.length - 1));
          colors.push(redGradient[colorIndex]);
        }
        break;
        
      case 'green':
        // Verde: do mais claro ao mais escuro
        const greenGradient = ['#E6FFE6', '#CCFFCC', '#B3FFB3', '#99FF99', '#80FF80', '#66FF66', '#4DFF4D', '#33FF33', '#1AFF1A', '#00FF00', '#00E600', '#00CC00', '#00B300', '#009900', '#008000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (greenGradient.length - 1));
          colors.push(greenGradient[colorIndex]);
        }
        break;
        
      case 'blue':
        // Azul: do mais claro ao mais escuro
        const blueGradient = ['#E6E6FF', '#CCCCFF', '#B3B3FF', '#9999FF', '#8080FF', '#6666FF', '#4D4DFF', '#3333FF', '#1A1AFF', '#0000FF', '#0000E6', '#0000CC', '#0000B3', '#000099', '#000080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (blueGradient.length - 1));
          colors.push(blueGradient[colorIndex]);
        }
        break;
        
      case 'yellow':
        // Amarelo: do mais claro ao mais escuro
        const yellowGradient = ['#FFFFE6', '#FFFFCC', '#FFFFB3', '#FFFF99', '#FFFF80', '#FFFF66', '#FFFF4D', '#FFFF33', '#FFFF1A', '#FFFF00', '#E6E600', '#CCCC00', '#B3B300', '#999900', '#808000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (yellowGradient.length - 1));
          colors.push(yellowGradient[colorIndex]);
        }
        break;
        
      case 'cyan':
        // Ciano: do mais claro ao mais escuro
        const cyanGradient = ['#E6FFFF', '#CCFFFF', '#B3FFFF', '#99FFFF', '#80FFFF', '#66FFFF', '#4DFFFF', '#33FFFF', '#1AFFFF', '#00FFFF', '#00E6E6', '#00CCCC', '#00B3B3', '#009999', '#008080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (cyanGradient.length - 1));
          colors.push(cyanGradient[colorIndex]);
        }
        break;
        
      case 'magenta':
        // Magenta: do mais claro ao mais escuro
        const magentaGradient = ['#FFE6FF', '#FFCCFF', '#FFB3FF', '#FF99FF', '#FF80FF', '#FF66FF', '#FF4DFF', '#FF33FF', '#FF1AFF', '#FF00FF', '#E600E6', '#CC00CC', '#B300B3', '#990099', '#800080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (magentaGradient.length - 1));
          colors.push(magentaGradient[colorIndex]);
        }
        break;
        
      case 'orange':
        // Laranja: do mais claro ao mais escuro
        const orangeGradient = ['#FFE6CC', '#FFCC99', '#FFB366', '#FF9933', '#FF8000', '#E67300', '#CC6600', '#B35900', '#994D00', '#804000', '#663300', '#4D2600', '#331900', '#1A0D00'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (orangeGradient.length - 1));
          colors.push(orangeGradient[colorIndex]);
        }
        break;
        
      case 'purple':
        // Roxo: do mais claro ao mais escuro
        const purpleGradient = ['#F0E6FF', '#E1CCFF', '#D2B3FF', '#C399FF', '#B480FF', '#A566FF', '#964DFF', '#8733FF', '#781AFF', '#6900FF', '#5E00E6', '#5200CC', '#4700B3', '#3B0099', '#300080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (purpleGradient.length - 1));
          colors.push(purpleGradient[colorIndex]);
        }
        break;
        
      case 'pink':
        // Rosa: do mais claro ao mais escuro
        const pinkGradient = ['#FFE6F0', '#FFCCE1', '#FFB3D2', '#FF99C3', '#FF80B4', '#FF66A5', '#FF4D96', '#FF3387', '#FF1A78', '#FF0069', '#E6005E', '#CC0052', '#B30047', '#99003B', '#800030'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (pinkGradient.length - 1));
          colors.push(pinkGradient[colorIndex]);
        }
        break;
        
      case 'brown':
        // Marrom: do mais claro ao mais escuro
        const brownGradient = ['#F5E6D3', '#EBD4B3', '#E1C293', '#D7B073', '#CD9E53', '#C38C33', '#B97A13', '#A66800', '#8C5600', '#734400', '#5A3200', '#412000', '#280E00', '#0F0000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (brownGradient.length - 1));
          colors.push(brownGradient[colorIndex]);
        }
        break;
        
      case 'teal':
        // Verde-azulado: do mais claro ao mais escuro
        const tealGradient = ['#E6FFFF', '#CCFFFF', '#B3FFFF', '#99FFFF', '#80FFFF', '#66FFFF', '#4DFFFF', '#33FFFF', '#1AFFFF', '#00FFFF', '#00E6E6', '#00CCCC', '#00B3B3', '#009999', '#008080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (tealGradient.length - 1));
          colors.push(tealGradient[colorIndex]);
        }
        break;
        
      case 'lime':
        // Lima: do mais claro ao mais escuro
        const limeGradient = ['#F0FFE6', '#E0FFCC', '#D0FFB3', '#C0FF99', '#B0FF80', '#A0FF66', '#90FF4D', '#80FF33', '#70FF1A', '#60FF00', '#56E600', '#4CCC00', '#42B300', '#389900', '#2E8000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (limeGradient.length - 1));
          colors.push(limeGradient[colorIndex]);
        }
        break;
        
      case 'indigo':
        // Índigo: do mais claro ao mais escuro
        const indigoGradient = ['#E6E6FF', '#CCCCFF', '#B3B3FF', '#9999FF', '#8080FF', '#6666FF', '#4D4DFF', '#3333FF', '#1A1AFF', '#0000FF', '#0000E6', '#0000CC', '#0000B3', '#000099', '#000080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (indigoGradient.length - 1));
          colors.push(indigoGradient[colorIndex]);
        }
        break;
        
      case 'violet':
        // Violeta: do mais claro ao mais escuro
        const violetGradient = ['#F0E6FF', '#E1CCFF', '#D2B3FF', '#C399FF', '#B480FF', '#A566FF', '#964DFF', '#8733FF', '#781AFF', '#6900FF', '#5E00E6', '#5200CC', '#4700B3', '#3B0099', '#300080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (violetGradient.length - 1));
          colors.push(violetGradient[colorIndex]);
        }
        break;
        
      case 'gold':
        // Dourado: do mais claro ao mais escuro
        const goldGradient = ['#FFF8E6', '#FFF0CC', '#FFE8B3', '#FFE099', '#FFD880', '#FFD066', '#FFC84D', '#FFC033', '#FFB81A', '#FFB000', '#E69E00', '#CC8C00', '#B37A00', '#996800', '#805600'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (goldGradient.length - 1));
          colors.push(goldGradient[colorIndex]);
        }
        break;
        
      case 'silver':
        // Prateado: do mais claro ao mais escuro
        const silverGradient = ['#FFFFFF', '#F2F2F2', '#E6E6E6', '#D9D9D9', '#CCCCCC', '#BFBFBF', '#B3B3B3', '#A6A6A6', '#999999', '#8C8C8C', '#808080', '#737373', '#666666', '#595959', '#4D4D4D'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (silverGradient.length - 1));
          colors.push(silverGradient[colorIndex]);
        }
        break;
        
      case 'copper':
        // Cobre: do mais claro ao mais escuro
        const copperGradient = ['#F5E6D3', '#EBD4B3', '#E1C293', '#D7B073', '#CD9E53', '#C38C33', '#B97A13', '#A66800', '#8C5600', '#734400', '#5A3200', '#412000', '#280E00', '#0F0000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (copperGradient.length - 1));
          colors.push(copperGradient[colorIndex]);
        }
        break;
        
      case 'emerald':
        // Esmeralda: do mais claro ao mais escuro
        const emeraldGradient = ['#E6FFE6', '#CCFFCC', '#B3FFB3', '#99FF99', '#80FF80', '#66FF66', '#4DFF4D', '#33FF33', '#1AFF1A', '#00FF00', '#00E600', '#00CC00', '#00B300', '#009900', '#008000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (emeraldGradient.length - 1));
          colors.push(emeraldGradient[colorIndex]);
        }
        break;
        
      case 'sapphire':
        // Safira: do mais claro ao mais escuro
        const sapphireGradient = ['#E6E6FF', '#CCCCFF', '#B3B3FF', '#9999FF', '#8080FF', '#6666FF', '#4D4DFF', '#3333FF', '#1A1AFF', '#0000FF', '#0000E6', '#0000CC', '#0000B3', '#000099', '#000080'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (sapphireGradient.length - 1));
          colors.push(sapphireGradient[colorIndex]);
        }
        break;
        
      case 'ruby':
        // Rubi: do mais claro ao mais escuro
        const rubyGradient = ['#FFE6E6', '#FFCCCC', '#FFB3B3', '#FF9999', '#FF8080', '#FF6666', '#FF4D4D', '#FF3333', '#FF1A1A', '#FF0000', '#E60000', '#CC0000', '#B30000', '#990000', '#800000'];
        for (let i = 0; i < count; i++) {
          const ratio = i / (count - 1);
          const colorIndex = Math.round(ratio * (rubyGradient.length - 1));
          colors.push(rubyGradient[colorIndex]);
        }
        break;
    }
    
    console.log('generateGradientColors returning:', colors);
    return colors;
  }
  
  // Função global para gerar cores aleatórias (disponível para todos os modais)
  function generateRandomColors(count) {
    console.log('generateRandomColors called with count:', count);
    
    const colors = [];
    for (let i = 0; i < count; i++) {
      const hue = Math.random() * 360;
      const saturation = 60 + Math.random() * 30;
      const lightness = 40 + Math.random() * 30;
      const color = hslToHex(hue, saturation, lightness);
      colors.push(color);
    }
    
    console.log('generateRandomColors returning:', colors);
    return colors;
  }

  // Função para interpolar cores (usada nas ferramentas rápidas)
  function interpolateColors(color1, color2, ratio) {
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);
    
    if (!rgb1 || !rgb2) return color1;
    
    const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * ratio);
    const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * ratio);
    const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * ratio);
    
    return rgbToHex(r, g, b);
  }

  // Função para salvar paleta atual
  function saveCurrentPalette() {
    const currentPalette = document.getElementById('palette-select').value;
    const currentColors = brewer(currentPalette, 8, document.getElementById('palette-invert').checked);
    
    // Verificar se já existe um modal
    let existingModal = document.querySelector('.save-palette-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Criar modal moderno
    const modal = document.createElement('div');
    modal.className = 'save-palette-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      backdrop-filter: blur(5px);
    `;
    
    modal.innerHTML = `
      <div class="save-palette-content" style="
        background: white;
        border-radius: 15px;
        padding: 0;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        border: 2px solid var(--bs-primary);
        overflow: hidden;
        animation: modalSlideIn 0.3s ease-out;
      ">
        <div class="save-palette-header" style="
          background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary-rgb, 0.8));
          color: white;
          padding: 20px;
          text-align: center;
          position: relative;
        ">
          <h4 style="margin: 0; font-weight: 600; font-size: 1.3rem;">
            <i class="fas fa-save"></i> Salvar Paleta Atual
          </h4>
          <button class="close-modal-btn" style="
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
          ">&times;</button>
        </div>
        
        <div class="save-palette-body" style="padding: 25px;">
          <div style="margin-bottom: 20px;">
            <label style="
              display: block;
              margin-bottom: 8px;
              font-weight: 600;
              color: #333;
              font-size: 0.95rem;
            ">Nome da Paleta:</label>
            <input type="text" id="palette-name-input" placeholder="Digite um nome para a paleta" style="
              width: 100%;
              padding: 12px 15px;
              border: 2px solid #e1e5e9;
              border-radius: 8px;
              font-size: 1rem;
              transition: border-color 0.2s;
              box-sizing: border-box;
            " value="${currentPalette}">
          </div>
          
          <div style="margin-bottom: 25px;">
            <label style="
              display: block;
              margin-bottom: 8px;
              font-weight: 600;
              color: #333;
              font-size: 0.95rem;
            ">Descrição:</label>
            <textarea id="palette-description-input" placeholder="Descreva a paleta" rows="3" style="
              width: 100%;
              padding: 12px 15px;
              border: 2px solid #e1e5e9;
              border-radius: 8px;
              font-size: 1rem;
              transition: border-color 0.2s;
              box-sizing: border-box;
              resize: vertical;
              font-family: inherit;
            ">Paleta baseada em ${currentPalette}</textarea>
          </div>
          
          <div style="margin-bottom: 25px;">
            <label style="
              display: block;
              margin-bottom: 8px;
              font-weight: 600;
              color: #333;
              font-size: 0.95rem;
            ">Preview da Paleta:</label>
            <div id="current-palette-preview" style="
              height: 40px;
              border-radius: 8px;
              border: 2px solid #e1e5e9;
              background: linear-gradient(to right, ${currentColors.join(', ')});
              display: flex;
              align-items: center;
              justify-content: center;
              color: white;
              font-weight: 600;
              text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
              font-size: 0.9rem;
            ">${currentColors.length} cores</div>
          </div>
          
          <div style="display: flex; gap: 15px; justify-content: flex-end;">
            <button id="cancel-save-palette" style="
              padding: 12px 25px;
              border: 2px solid #6c757d;
              background: white;
              color: #6c757d;
              border-radius: 8px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              font-size: 0.95rem;
            ">Cancelar</button>
            <button id="confirm-save-palette" style="
              padding: 12px 25px;
              border: none;
              background: var(--bs-primary);
              color: white;
              border-radius: 8px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              font-size: 0.95rem;
            ">Salvar Paleta</button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Focar no primeiro input
    const nameInput = modal.querySelector('#palette-name-input');
    nameInput.focus();
    nameInput.select();
    
    // Event listeners
    modal.querySelector('.close-modal-btn').addEventListener('click', () => modal.remove());
    modal.querySelector('#cancel-save-palette').addEventListener('click', () => modal.remove());
    
    modal.querySelector('#confirm-save-palette').addEventListener('click', () => {
      const name = nameInput.value.trim();
      const description = modal.querySelector('#palette-description-input').value.trim();
      
      if (!name) {
        nameInput.style.borderColor = '#dc3545';
        nameInput.focus();
        return;
      }
      
      saveCustomPalette(name, description, currentColors);
      showToast(`Paleta "${name}" salva com sucesso!`, 'success');
      modal.remove();
    });
    
    // Enter para salvar, Escape para cancelar
    nameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        modal.querySelector('#confirm-save-palette').click();
      }
    });
    
    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        modal.remove();
      }
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
  }

  // Função para gerenciar paletas
  function managePalettes() {
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    
    // Verificar se já existe um modal
    let existingModal = document.querySelector('.manage-palettes-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Criar modal moderno
    const modal = document.createElement('div');
    modal.className = 'manage-palettes-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      backdrop-filter: blur(5px);
    `;
    
    modal.innerHTML = `
      <div class="manage-palettes-content" style="
        background: white;
        border-radius: 15px;
        padding: 0;
        max-width: 700px;
        width: 90%;
        max-height: 80vh;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        border: 2px solid var(--bs-primary);
        overflow: hidden;
        animation: modalSlideIn 0.3s ease-out;
        display: flex;
        flex-direction: column;
      ">
        <div class="manage-palettes-header" style="
          background: linear-gradient(135deg, var(--bs-primary), var(--bs-primary-rgb, 0.8));
          color: white;
          padding: 20px;
          text-align: center;
          position: relative;
          flex-shrink: 0;
        ">
          <h4 style="margin: 0; font-weight: 600; font-size: 1.3rem;">
            <i class="fas fa-cogs"></i> Gerenciar Paletas Personalizadas
          </h4>
          <button class="close-modal-btn" style="
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
          ">&times;</button>
        </div>
        
        <div class="manage-palettes-body" style="
          padding: 25px;
          flex: 1;
          overflow-y: auto;
          display: flex;
          flex-direction: column;
        ">
          ${customPalettes.length === 0 ? `
            <div style="
              text-align: center;
              padding: 40px 20px;
              color: #6c757d;
              font-style: italic;
            ">
              <i class="fas fa-palette" style="font-size: 3rem; margin-bottom: 20px; opacity: 0.5;"></i>
              <h5 style="margin: 0 0 10px 0; color: #495057;">Nenhuma paleta personalizada encontrada</h5>
              <p style="margin: 0; font-size: 0.95rem;">Crie sua primeira paleta usando "Criar Nova Paleta"</p>
            </div>
          ` : `
            <div style="margin-bottom: 20px;">
              <h6 style="margin: 0 0 15px 0; color: #333; font-weight: 600; font-size: 1.1rem;">
                <i class="fas fa-list"></i> Paletas Disponíveis (${customPalettes.length})
              </h6>
            </div>
            
            <div class="palettes-list" style="
              display: flex;
              flex-direction: column;
              gap: 15px;
              flex: 1;
            ">
              ${customPalettes.map((palette, index) => `
                <div class="palette-item" data-palette-index="${index}" style="
                  border: 2px solid #e1e5e9;
                  border-radius: 12px;
                  padding: 20px;
                  background: #f8f9fa;
                  transition: all 0.2s;
                  position: relative;
                ">
                  <div style="
                    display: flex;
                    justify-content: space-between;
                    align-items: flex-start;
                    margin-bottom: 15px;
                  ">
                    <div style="flex: 1;">
                      <h6 style="
                        margin: 0 0 8px 0;
                        color: #333;
                        font-weight: 600;
                        font-size: 1.1rem;
                      ">${palette.name}</h6>
                      <p style="
                        margin: 0;
                        color: #6c757d;
                        font-size: 0.95rem;
                        line-height: 1.4;
                      ">${palette.description}</p>
                    </div>
                    
                    <div style="
                      display: flex;
                      gap: 10px;
                      flex-shrink: 0;
                    ">
                      <button class="edit-palette-btn" data-palette-index="${index}" style="
                        padding: 8px 16px;
                        border: 2px solid var(--bs-primary);
                        background: white;
                        color: var(--bs-primary);
                        border-radius: 6px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.2s;
                        font-size: 0.85rem;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                      ">
                        <i class="fas fa-edit"></i> Editar
                      </button>
                      <button class="delete-palette-btn" data-palette-index="${index}" style="
                        padding: 8px 16px;
                        border: 2px solid #dc3545;
                        background: white;
                        color: #dc3545;
                        border-radius: 6px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.2s;
                        font-size: 0.85rem;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                      ">
                        <i class="fas fa-trash"></i> Excluir
                      </button>
                    </div>
                  </div>
                  
                  <div style="
                    display: flex;
                    align-items: center;
                    gap: 15px;
                  ">
                    <div style="
                      height: 35px;
                      border-radius: 8px;
                      border: 2px solid #e1e5e9;
                      background: linear-gradient(to right, ${palette.colors.join(', ')});
                      flex: 1;
                      position: relative;
                    ">
                      <div style="
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 600;
                        text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
                        font-size: 0.85rem;
                      ">${palette.colors.length} cores</div>
                    </div>
                    
                    <div style="
                      color: #6c757d;
                      font-size: 0.9rem;
                      font-weight: 500;
                      min-width: 80px;
                      text-align: center;
                    ">
                      ${palette.colors.length} cores
                    </div>
                  </div>
                </div>
              `).join('')}
            </div>
          `}
          
          <div style="
            display: flex;
            justify-content: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #e1e5e9;
          ">
            <button id="close-manage-palettes" style="
              padding: 12px 30px;
              border: 2px solid var(--bs-primary);
              background: white;
              color: var(--bs-primary);
              border-radius: 8px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s;
              font-size: 1rem;
            ">Fechar</button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Event listeners
    modal.querySelector('.close-modal-btn').addEventListener('click', () => modal.remove());
    modal.querySelector('#close-manage-palettes').addEventListener('click', () => modal.remove());
    
    // Botões de editar
    modal.querySelectorAll('.edit-palette-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const index = parseInt(btn.dataset.paletteIndex);
        const palette = customPalettes[index];
        modal.remove();
        editCustomPalette(palette);
      });
    });
    
    // Botões de excluir
    modal.querySelectorAll('.delete-palette-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const index = parseInt(btn.dataset.paletteIndex);
        const palette = customPalettes[index];
        
        if (confirm(`Tem certeza que deseja excluir a paleta "${palette.name}"?\n\nEsta ação não pode ser desfeita.`)) {
          customPalettes.splice(index, 1);
          localStorage.setItem('custom_palettes', JSON.stringify(customPalettes));
          loadCustomPalettes();
          showToast(`Paleta "${palette.name}" excluída com sucesso!`, 'success');
          
          // Recarregar o modal para atualizar a lista
          modal.remove();
          managePalettes();
        }
      });
    });
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
    
    // Escape para fechar
    modal.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        modal.remove();
      }
    });
  }
  
  // Função para editar paleta personalizada - REUTILIZA O MODAL "CRIAR NOVA PALETA"
  function editCustomPalette(palette) {
    // Remove qualquer modal existente
    let existingModal = document.querySelector('.custom-palette-modal');
    if (existingModal) {
      existingModal.remove();
    }

    // Chama a função createNewPalette para reutilizar toda a interface
    createNewPalette();
    
    // Aguarda o modal ser criado e pré-preenche os dados
    setTimeout(() => {
      const modal = document.querySelector('.custom-palette-modal');
      if (modal) {
        // Alterar título para "Editar Paleta"
        const header = modal.querySelector('.custom-palette-modal-header h3');
        if (header) {
          header.innerHTML = '<i class="fas fa-edit"></i> Editar Paleta: ' + palette.name;
        }
        
        // Pré-preencher campos com dados existentes
        const nameInput = modal.querySelector('#palette-name');
        const descInput = modal.querySelector('#palette-description');
        const countDisplay = modal.querySelector('#color-count-display');
        const countInput = modal.querySelector('#color-count-input');
        
        if (nameInput) nameInput.value = palette.name;
        if (descInput) descInput.value = palette.description || '';
        if (countDisplay) countDisplay.textContent = palette.colors.length;
        if (countInput) countInput.value = palette.colors.length;
        
        // Pré-preencher cores existentes
        const colorsContainer = modal.querySelector('#palette-colors-container');
        if (colorsContainer) {
          // Limpar container
          colorsContainer.innerHTML = '';
          
          // Gerar inputs com cores existentes
          palette.colors.forEach((color, index) => {
            const rgb = hexToRgb(color);
            const colorItem = document.createElement('div');
            colorItem.className = 'palette-color-item';
            colorItem.innerHTML = `
              <div class="color-item-header">
                <span class="color-number">Cor ${index + 1}</span>
              </div>
              <div class="color-inputs">
                <div class="color-input-group">
                  <label>Seletor:</label>
                  <input type="color" class="color-picker" value="${color}" data-index="${index}">
                </div>
                <div class="color-input-group">
                  <label>HEX:</label>
                  <input type="text" class="color-hex" value="${color}" placeholder="#000000" maxlength="7" data-index="${index}">
                </div>
                <div class="color-input-group">
                  <label>RGB:</label>
                  <div class="rgb-inputs">
                    <input type="number" class="rgb-r" placeholder="R" min="0" max="255" value="${rgb ? rgb.r : 0}" data-index="${index}">
                    <input type="number" class="rgb-g" placeholder="G" min="0" max="255" value="${rgb ? rgb.g : 0}" data-index="${index}">
                    <input type="number" class="rgb-b" placeholder="B" min="0" max="255" value="${rgb ? rgb.b : 0}" data-index="${index}">
                  </div>
                </div>
              </div>
            `;
            colorsContainer.appendChild(colorItem);
          });
          
          // Reativar event listeners das cores
          addColorEventListeners();
        }
        
        // Atualizar preview com cores existentes
        const preview = modal.querySelector('#palette-preview');
        if (preview && palette.colors.length > 0) {
          preview.style.background = `linear-gradient(to right, ${palette.colors.join(', ')})`;
          preview.textContent = `${palette.colors.length} cores`;
        }
        
        // Alterar botão de salvar para "Atualizar Paleta"
        const saveBtn = modal.querySelector('#btn-save-palette');
        if (saveBtn) {
          saveBtn.innerHTML = '<i class="fas fa-save"></i> Atualizar Paleta';
          
          // Substituir event listener para atualização
          const newSaveBtn = saveBtn.cloneNode(true);
          saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
          
          newSaveBtn.addEventListener('click', () => {
            const updatedName = modal.querySelector('#palette-name').value.trim();
            const updatedDescription = modal.querySelector('#palette-description').value.trim();
            
            if (!updatedName) {
              alert('Por favor, digite um nome para a paleta.');
              return;
            }
            
            // Coletar cores atuais
            const updatedColors = [];
            modal.querySelectorAll('.color-picker').forEach(picker => {
              updatedColors.push(picker.value);
            });
            
            // Atualizar paleta no localStorage
            let customPalettes = JSON.parse(localStorage.getItem('customPalettes') || '[]');
            const paletteIndex = customPalettes.findIndex(p => p.name === palette.name);
            
            if (paletteIndex !== -1) {
              customPalettes[paletteIndex] = {
                name: updatedName,
                description: updatedDescription,
                colors: updatedColors,
                type: 'custom',
                createdAt: customPalettes[paletteIndex].createdAt,
                updatedAt: new Date().toISOString()
              };
              
              localStorage.setItem('customPalettes', JSON.stringify(customPalettes));
              
              // Mostrar sucesso
              alert('Paleta atualizada com sucesso!');
              
              // Fechar modal
              modal.remove();
              
              // Recarregar lista de paletas se estiver aberta
              loadCustomPalettes();
            }
          });
        }
      }
    }, 100);
  }
  
  // Função para gerar cores divergentes (sequência contínua sem repetições)
  function generateHarmonicColors(count) {
    console.log('generateHarmonicColors (divergente - edit) chamada com count:', count);
    
          // Escolher um esquema divergente aleatoriamente com grande variedade
      const schemes = [
        // PALETAS QUENTES (Vermelho/Laranja → Neutro → Frio)
        {
          name: 'Vermelho → Branco → Azul',
          startColor: '#67001f',    // Vermelho escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        },
        {
          name: 'Vermelho → Amarelo → Azul',
          startColor: '#a50026',    // Vermelho escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#313695'       // Azul escuro
        },
        {
          name: 'Vermelho → Amarelo → Verde',
          startColor: '#a50026',    // Vermelho escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#006837'       // Verde escuro
        },
        {
          name: 'Rosa → Amarelo → Azul',
          startColor: '#9e0142',    // Rosa escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#5e4fa2'       // Azul escuro
        },
        {
          name: 'Laranja → Branco → Roxo',
          startColor: '#7f3b08',    // Laranja escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#2d004b'       // Roxo escuro
        },
        {
          name: 'Vermelho → Branco → Cinza',
          startColor: '#67001f',    // Vermelho escuro
          middleColor: '#ffffff',   // Branco
          endColor: '#1a1a1a'       // Cinza escuro
        },
        
        // PALETAS NEUTRAS (Marrom/Terra → Neutro → Verde)
        {
          name: 'Marrom → Branco → Verde',
          startColor: '#543005',    // Marrom escuro
          middleColor: '#f5f5f5',   // Branco
          endColor: '#003c30'       // Verde escuro
        },
        {
          name: 'Rosa → Branco → Verde',
          startColor: '#8e0152',    // Rosa escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Roxo → Branco → Verde',
          startColor: '#40004b',    // Roxo escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        
        // PALETAS FRIAS (Azul/Ciano → Neutro → Verde)
        {
          name: 'Azul → Branco → Verde',
          startColor: '#053061',    // Azul escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Ciano → Branco → Verde',
          startColor: '#01665e',    // Ciano escuro
          middleColor: '#f5f5f5',   // Branco
          endColor: '#003c30'       // Verde escuro
        },
        {
          name: 'Azul → Amarelo → Verde',
          startColor: '#313695',    // Azul escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#006837'       // Verde escuro
        },
        
        // PALETAS ESPECIAIS (Divergentes únicas)
        {
          name: 'Dourado → Branco → Azul',
          startColor: '#b35806',    // Dourado escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        },
        {
          name: 'Violeta → Branco → Verde',
          startColor: '#762a83',    // Violeta escuro
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        {
          name: 'Coral → Amarelo → Azul',
          startColor: '#d53e4f',    // Coral escuro
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#5e4fa2'       // Azul escuro
        },
        {
          name: 'Oliva → Branco → Roxo',
          startColor: '#7fbc41',    // Oliva
          middleColor: '#f7f7f7',   // Branco
          endColor: '#2d004b'       // Roxo escuro
        },
        {
          name: 'Esmeralda → Branco → Rosa',
          startColor: '#1a9850',    // Esmeralda
          middleColor: '#f7f7f7',   // Branco
          endColor: '#8e0152'       // Rosa escuro
        },
        {
          name: 'Safira → Branco → Laranja',
          startColor: '#4575b4',    // Safira
          middleColor: '#f7f7f7',   // Branco
          endColor: '#b35806'       // Laranja escuro
        },
        {
          name: 'Rubi → Amarelo → Verde',
          startColor: '#d73027',    // Rubi
          middleColor: '#ffffbf',   // Amarelo
          endColor: '#276419'       // Verde escuro
        },
        {
          name: 'Turquesa → Branco → Vermelho',
          startColor: '#66c2a5',    // Turquesa
          middleColor: '#f7f7f7',   // Branco
          endColor: '#a50026'       // Vermelho escuro
        },
        {
          name: 'Lavanda → Branco → Verde',
          startColor: '#9970ab',    // Lavanda
          middleColor: '#f7f7f7',   // Branco
          endColor: '#00441b'       // Verde escuro
        },
        {
          name: 'Âmbar → Branco → Azul',
          startColor: '#fdae61',    // Âmbar
          middleColor: '#f7f7f7',   // Branco
          endColor: '#053061'       // Azul escuro
        }
      ];
    
    const selectedScheme = schemes[Math.floor(Math.random() * schemes.length)];
    console.log('Esquema divergente selecionado:', selectedScheme.name);
    
    const colors = [];
    
    // Gerar sequência contínua: início → meio → fim
    for (let i = 0; i < count; i++) {
      const ratio = i / (count - 1);
      let color;
      
      if (ratio <= 0.5) {
        // Primeira metade: início → meio
        const localRatio = ratio * 2; // 0 → 1
        color = interpolateColors(selectedScheme.startColor, selectedScheme.middleColor, localRatio);
      } else {
        // Segunda metade: meio → fim
        const localRatio = (ratio - 0.5) * 2; // 0 → 1
        color = interpolateColors(selectedScheme.middleColor, selectedScheme.endColor, localRatio);
      }
      
      colors.push(color);
    }
    
    console.log('Paleta divergente contínua gerada:', colors);
    return colors;
  }
  
  // Função para aplicar cores geradas ao modal de edição
  function applyGeneratedColorsToEdit(colors, modal) {
    if (!colors || colors.length === 0) {
      console.log('No colors provided to applyGeneratedColorsToEdit');
      return;
    }
    
    console.log('Applying colors:', colors);
    
    // Primeiro, ajustar a quantidade de cores se necessário
    const currentQuantity = modal.querySelectorAll('.edit-color-picker').length;
    console.log('Current quantity:', currentQuantity, 'New quantity:', colors.length);
    
    if (colors.length !== currentQuantity) {
      resizeColorList(modal, colors.length);
      modal.querySelector('#edit-palette-quantity').value = colors.length;
    }
    
    // Pequeno delay para garantir que os elementos foram criados
    setTimeout(() => {
      // Aplicar as cores
      const colorPickers = modal.querySelectorAll('.edit-color-picker');
      const hexInputs = modal.querySelectorAll('.edit-color-hex');
      
      console.log('Found color pickers:', colorPickers.length);
      
      colors.forEach((color, index) => {
        if (colorPickers[index]) {
          colorPickers[index].value = color;
        }
        if (hexInputs[index]) {
          hexInputs[index].value = color;
        }
        
        // Atualizar RGB inputs
        const rgbRInput = modal.querySelector(`.edit-rgb-r[data-index="${index}"]`);
        const rgbGInput = modal.querySelector(`.edit-rgb-g[data-index="${index}"]`);
        const rgbBInput = modal.querySelector(`.edit-rgb-b[data-index="${index}"]`);
        
        if (rgbRInput && rgbGInput && rgbBInput) {
          const rgb = hexToRgb(color);
          if (rgb) {
            rgbRInput.value = rgb.r;
            rgbGInput.value = rgb.g;
            rgbBInput.value = rgb.b;
          }
        }
      });
    }, 100);
  }
  
  // Função para redimensionar a lista de cores
  function resizeColorList(modal, newQuantity) {
    const container = modal.querySelector('#edit-colors-container');
    const currentColors = container.querySelectorAll('.edit-color-item');
    const currentQuantity = currentColors.length;
    
    if (newQuantity === currentQuantity) return;
    
    if (newQuantity > currentQuantity) {
      // Adicionar novas cores
      for (let i = currentQuantity; i < newQuantity; i++) {
        const colorItem = document.createElement('div');
        colorItem.className = 'edit-color-item';
        colorItem.style.cssText = `
          display: flex;
          align-items: center;
          gap: 15px;
          margin-bottom: 15px;
          padding: 15px;
          background: white;
          border-radius: 8px;
          border: 1px solid #e1e5e9;
        `;
        
        const randomColor = generateRandomColors(1)[0];
        const rgb = hexToRgb(randomColor);
        
        colorItem.innerHTML = `
          <div style="
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 200px;
          ">
            <span style="
              font-weight: 600;
              color: #333;
              min-width: 60px;
            ">Cor ${i + 1}:</span>
            <input type="color" class="edit-color-picker" data-index="${i}" value="${randomColor}" style="
              width: 50px;
              height: 40px;
              border: none;
              border-radius: 6px;
              cursor: pointer;
            ">
          </div>
          
          <input type="text" class="edit-color-hex" data-index="${i}" placeholder="#000000" value="${randomColor}" style="
            width: 100px;
            padding: 8px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 0.9rem;
            font-family: monospace;
            text-transform: uppercase;
          ">
          
          <div style="
            display: flex;
            align-items: center;
            gap: 5px;
          ">
            <input type="number" class="edit-rgb-r" data-index="${i}" placeholder="R" min="0" max="255" value="${rgb ? rgb.r : 0}" style="
              width: 60px;
              padding: 8px 12px;
              border: 2px solid #e1e5e9;
              border-radius: 6px;
              font-size: 0.9rem;
              text-align: center;
            ">
            <input type="number" class="edit-rgb-g" data-index="${i}" placeholder="G" min="0" max="255" value="${rgb ? rgb.g : 0}" style="
              width: 60px;
              padding: 8px 12px;
              border: 2px solid #e1e5e9;
              border-radius: 6px;
              font-size: 0.9rem;
              text-align: center;
            ">
            <input type="number" class="edit-rgb-b" data-index="${i}" placeholder="B" min="0" max="255" value="${rgb ? rgb.b : 0}" style="
              width: 60px;
              padding: 8px 12px;
              border: 2px solid #e1e5e9;
              border-radius: 6px;
              font-size: 0.9rem;
              text-align: center;
            ">
          </div>
        `;
        
        container.appendChild(colorItem);
        
        // Adicionar event listeners para a nova cor
        const picker = colorItem.querySelector('.edit-color-picker');
        const hexInput = colorItem.querySelector('.edit-color-hex');
        const rgbInputs = colorItem.querySelectorAll('.edit-rgb-r, .edit-rgb-g, .edit-rgb-b');
        
        picker.addEventListener('input', () => {
          const color = picker.value;
          hexInput.value = color;
          const rgb = hexToRgb(color);
          if (rgb) {
            rgbInputs[0].value = rgb.r;
            rgbInputs[1].value = rgb.g;
            rgbInputs[2].value = rgb.b;
          }
          updateEditPalettePreview(modal);
        });
        
        hexInput.addEventListener('input', () => {
          const color = hexInput.value;
          if (isValidHex(color)) {
            picker.value = color;
            const rgb = hexToRgb(color);
            if (rgb) {
              rgbInputs[0].value = rgb.r;
              rgbInputs[1].value = rgb.g;
              rgbInputs[2].value = rgb.b;
            }
            updateEditPalettePreview(modal);
          }
        });
        
        rgbInputs.forEach((rgbInput, rgbIndex) => {
          rgbInput.addEventListener('input', () => {
            const r = parseInt(rgbInputs[0].value) || 0;
            const g = parseInt(rgbInputs[1].value) || 0;
            const b = parseInt(rgbInputs[2].value) || 0;
            
            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
              const color = rgbToHex(r, g, b);
              picker.value = color;
              hexInput.value = color;
              updateEditPalettePreview(modal);
            }
          });
        });
      }
    } else {
      // Remover cores extras
      for (let i = currentQuantity - 1; i >= newQuantity; i--) {
        const colorItem = container.querySelector(`.edit-color-item:nth-child(${i + 1})`);
        if (colorItem) {
          colorItem.remove();
        }
      }
    }
    
    // Reindexar as cores restantes
    container.querySelectorAll('.edit-color-item').forEach((item, index) => {
      item.querySelector('.edit-color-picker').dataset.index = index;
      item.querySelector('.edit-color-hex').dataset.index = index;
      item.querySelectorAll('.edit-rgb-r, .edit-rgb-g, .edit-rgb-b').forEach(input => {
        input.dataset.index = index;
      });
      item.querySelector('span').textContent = `Cor ${index + 1}:`;
    });
  }
  
  // Função para atualizar preview da paleta no modal de edição
  function updateEditPalettePreview(modal) {
    const colors = [];
    modal.querySelectorAll('.edit-color-picker').forEach(picker => {
      colors.push(picker.value);
    });
    
    const preview = modal.querySelector('#edit-palette-preview');
    if (preview && colors.length > 0) {
      preview.style.background = `linear-gradient(to right, ${colors.join(', ')})`;
      preview.textContent = `${colors.length} cores`;
    }
  }
  
  // Função para salvar configurações do usuário
  function saveUserConfig() {
    const config = {
      field: document.getElementById('field-select').value,
      styleType: document.getElementById('style-type').value,
      geomType: document.getElementById('geom-type').value,
      palette: document.getElementById('palette-select').value,
      paletteOpacity: document.getElementById('palette-opacity').value,
      paletteInvert: document.getElementById('palette-invert').checked,
      classes: document.getElementById('classes').value,
      method: document.getElementById('method').value,
      manualBreaks: document.getElementById('manual-breaks').value,
      strokeColor: document.getElementById('stroke-color').value,
      fillColor: document.getElementById('fill-color').value,
      strokeWeight: document.getElementById('stroke-weight').value,
      fillOpacity: document.getElementById('fill-opacity').value,
      pointRadius: document.getElementById('point-radius').value,
      lineOpacity: document.getElementById('line-opacity').value,
      lineDash: document.getElementById('line-dash').value,
      lineWeightDefault: document.getElementById('line-weight-default')?.value || '2',
      lineOpacityDefault: document.getElementById('line-opacity-default')?.value || '1',
      lineStyleDefault: document.getElementById('line-style-default')?.value || '',
      lineSpacingDefault: document.getElementById('line-spacing-default')?.value || '10',
      customLinePattern: document.getElementById('custom-line-pattern')?.value || '',
      lineCapDefault: document.getElementById('line-cap-default')?.value || 'round',
      lineJoinDefault: document.getElementById('line-join-default')?.value || 'round',
      lineMiterLimit: document.getElementById('line-miter-limit')?.value || '4',
      // Configurações específicas para pontos
      pointRadiusDefault: document.getElementById('point-radius-default')?.value || '6',
      pointOpacityDefault: document.getElementById('point-opacity-default')?.value || '1',
      pointShapeDefault: document.getElementById('point-shape-default')?.value || 'circle',
      pointBorderWidthDefault: document.getElementById('point-border-width-default')?.value || '1',
      customPointShape: document.getElementById('custom-point-shape')?.value || '',
      pointBorderColorDefault: document.getElementById('point-border-color-default')?.value || '#000000',
      pointBorderStyleDefault: document.getElementById('point-border-style-default')?.value || 'solid',
      pointShadowDefault: document.getElementById('point-shadow-default')?.value || '0',
      polygonBorderColor: document.getElementById('polygon-border-color').value,
      polygonBorderWidth: document.getElementById('polygon-border-width').value,
      polygonBorderToggle: document.getElementById('polygon-border-toggle').checked,
      labelField: document.getElementById('label-field-select').value,
      labelFont: document.getElementById('label-font').value,
      labelSize: document.getElementById('label-size').value,
      labelColor: document.getElementById('label-color').value,
      labelBold: document.getElementById('label-bold').checked,
      labelItalic: document.getElementById('label-italic').checked,
      labelBufferColor: document.getElementById('label-buffer-color').value,
      labelBufferSize: document.getElementById('label-buffer-size').value,
      labelBufferOpacity: document.getElementById('label-buffer-opacity').value,
      labelOffsetX: document.getElementById('label-offset-x').value,
      labelOffsetY: document.getElementById('label-offset-y').value,
      labelsEnabled: document.getElementById('labels-enabled').checked,
      compositeLegend: document.getElementById('composite-legend-toggle')?.checked || false,
      hideIntervals: document.getElementById('toggle-intervals')?.classList.contains('btn-secondary') || false,
      // Configurações de tamanho proporcional
      proportionalSizeEnabled: document.getElementById('proportional-size-toggle')?.checked || false,
      minLineWeight: document.getElementById('min-line-weight')?.value || '2',
      maxLineWeight: document.getElementById('max-line-weight')?.value || '8',
      // Configurações de tamanho proporcional dos pontos
      proportionalPointSizeEnabled: document.getElementById('proportional-point-size-toggle')?.checked || false,
      minPointRadius: document.getElementById('min-point-radius')?.value || '4',
      maxPointRadius: document.getElementById('max-point-radius')?.value || '12',

      timestamp: Date.now() // Adicionar timestamp
    };
    
    // IMPORTANTE: Salvar também todas as configurações específicas da legenda
    saveLegendSpecificConfig();
    
    localStorage.setItem(`symbology_config_${layerId}`, JSON.stringify(config));
    console.log('Configurações do usuário salvas:', config);
  }
  
  // Função para salvar configurações específicas da legenda
  function saveLegendSpecificConfig() {
    const field = document.getElementById('field-select').value;
    const styleType = document.getElementById('style-type').value;
    
    if (!field) return;
    
    if (styleType === 'categorized') {
      // Salvar nomes personalizados das categorias
      const categoryItems = document.querySelectorAll('.categorized-class-item');
      categoryItems.forEach((item, index) => {
        const category = item.dataset.category;
        const nameInput = item.querySelector('.categorized-class-name');
        const colorInput = item.querySelector('.categorized-class-color');
        const styleSelect = item.querySelector('.line-style-select');
        const spacingSlider = item.querySelector('.line-spacing-slider');
        const weightInput = item.querySelector('.line-weight-input');
        const opacityInput = item.querySelector('.line-opacity-input');
        
        if (nameInput && nameInput.value !== category) {
          localStorage.setItem(`categorized_class_name_${layerId}_${category}_${index}`, nameInput.value);
        }
        
        if (colorInput && colorInput.value) {
          localStorage.setItem(`category_color_${layerId}_${category}`, colorInput.value);
        }
        
        // Salvar estilo da linha
        if (styleSelect && styleSelect.value !== undefined) {
          localStorage.setItem(`line_style_${layerId}_${category}`, styleSelect.value);
        }
        
        // Salvar espaçamento da linha
        if (spacingSlider && spacingSlider.value !== undefined) {
          localStorage.setItem(`line_spacing_${layerId}_${category}`, spacingSlider.value);
        }
        
        // Salvar espessura da linha
        if (weightInput && weightInput.value !== undefined) {
          localStorage.setItem(`line_weight_${layerId}_${category}`, weightInput.value);
        }
        
        // Salvar opacidade da linha
        if (opacityInput && opacityInput.value !== undefined) {
          localStorage.setItem(`line_opacity_${layerId}_${category}`, opacityInput.value);
        }
      });
      
      // Salvar ordem personalizada das categorias
      const currentOrder = Array.from(categoryItems).map(item => item.dataset.category);
      if (currentOrder.length > 0) {
        localStorage.setItem(`categorized_order_${layerId}_${field}`, JSON.stringify(currentOrder));
      }
      
      console.log('Configurações da legenda categorizada salvas');
      
    } else if (styleType === 'graduated') {
      // Salvar nomes personalizados das classes graduadas
      const graduatedItems = document.querySelectorAll('.graduated-class-name');
      graduatedItems.forEach((item, index) => {
        if (item.value && item.value !== `Classe ${index + 1}`) {
          localStorage.setItem(`graduated_class_${layerId}_${field}_${index}`, item.value);
        }
      });
      
      // Salvar cores personalizadas das classes graduadas
      const graduatedColors = document.querySelectorAll('.graduated-class-color');
      graduatedColors.forEach((item, index) => {
        if (item.value) {
          localStorage.setItem(`graduated_class_color_${layerId}_${field}_${index}`, item.value);
        }
              });
        
        // IMPORTANTE: Salvar configurações de linha das classes graduadas
        if (document.getElementById('geom-type').value === 'line') {
          const graduatedLineOpacities = document.querySelectorAll('.graduated-line-opacity');
          const graduatedLineStyles = document.querySelectorAll('.graduated-line-style');
          const graduatedLineSpacings = document.querySelectorAll('.graduated-line-spacing');
          
          graduatedLineOpacities.forEach((item, index) => {
            if (item.value !== undefined) {
              localStorage.setItem(`graduated_line_opacity_${layerId}_${field}_${index}`, item.value);
            }
          });
          
          graduatedLineStyles.forEach((item, index) => {
            if (item.value !== undefined) {
              localStorage.setItem(`graduated_line_style_${layerId}_${field}_${index}`, item.value);
            }
          });
          
          graduatedLineSpacings.forEach((item, index) => {
            if (item.value !== undefined) {
              localStorage.setItem(`graduated_line_spacing_${layerId}_${field}_${index}`, item.value);
            }
          });
          
          console.log('Configurações de linha das classes graduadas salvas');
        }
        
        console.log('Configurações da legenda graduada salvas');
    }
  }
  
  // Função para verificar se um campo é numérico
  function isNumericField(field) {
    if (!layerData || !layerData.features || layerData.features.length === 0) {
      return false;
    }
    
    // Verificar os primeiros valores do campo para determinar se é numérico
    const sampleValues = layerData.features.slice(0, 10).map(f => f.properties[field]);
    
    return sampleValues.every(value => {
      if (value === null || value === undefined || value === '') return false;
      // Aceitar tanto vírgula quanto ponto como separador decimal
      const normalizedValue = value.toString().replace(',', '.');
      const num = parseFloat(normalizedValue);
      return !isNaN(num) && isFinite(num);
    });
  }

  // Função para mostrar aviso sobre campo não numérico
  function showNumericFieldWarning(field) {
    // Verificar se já existe um modal
    let existingModal = document.querySelector('.numeric-validation-modal');
    if (existingModal) {
      existingModal.remove();
    }
    
    // Criar modal estilizado
    const modal = document.createElement('div');
    modal.className = 'numeric-validation-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(5px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease-out;
    `;
    
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      background: linear-gradient(135deg, #ffffff, #f8f9fa);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.15);
      max-width: 500px;
      width: 90%;
      position: relative;
      animation: slideInScale 0.3s ease-out;
      border: 1px solid #e9ecef;
    `;
    
    modalContent.innerHTML = `
      <div style="text-align: center; margin-bottom: 20px;">
        <div style="
          width: 60px;
          height: 60px;
          background: linear-gradient(135deg, #ffc107, #fd7e14);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          margin: 0 auto 15px;
          box-shadow: 0 8px 16px rgba(255, 193, 7, 0.3);
        ">
          <i class="fas fa-exclamation-triangle" style="font-size: 24px; color: white;"></i>
        </div>
        <h4 style="color: #212529; margin: 0; font-weight: 600;">Campo Não Numérico Detectado</h4>
      </div>
      
      <div style="margin-bottom: 25px;">
        <p style="color: #6c757d; margin-bottom: 15px; font-size: 16px; line-height: 1.5;">
          O campo <strong style="color: #dc3545;">"${field}"</strong> não contém valores numéricos válidos.
        </p>
        
        <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; border-left: 4px solid #28a745;">
          <p style="margin: 0 0 15px 0; color: #495057; font-weight: 500;">
            <i class="fas fa-info-circle" style="color: #17a2b8; margin-right: 8px;"></i>
            Para simbologia graduada, selecione um campo com:
          </p>
          <ul style="margin: 0; padding-left: 20px; color: #6c757d;">
            <li style="margin-bottom: 8px;">
              <strong>Números inteiros:</strong> 1, 2, 100, 500
            </li>
            <li style="margin-bottom: 8px;">
              <strong>Números decimais:</strong> 1,5 • 23,7 • 99,99
            </li>
          </ul>
        </div>
        
        <div style="background: #e7f3ff; padding: 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #007bff;">
          <p style="margin: 0; color: #495057; font-size: 14px;">
            <i class="fas fa-lightbulb" style="color: #ffc107; margin-right: 8px;"></i>
            <strong>Dica:</strong> A simbologia graduada representa variação numérica através de cores, 
            criando uma representação visual da intensidade dos dados.
          </p>
        </div>
      </div>
      
      <div style="text-align: center;">
        <button id="close-numeric-modal" style="
          background: linear-gradient(135deg, #007bff, #0056b3);
          color: white;
          border: none;
          padding: 12px 30px;
          border-radius: 8px;
          font-size: 16px;
          font-weight: 500;
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0, 123, 255, 0.4)';" 
           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0, 123, 255, 0.3)';">
          <i class="fas fa-check" style="margin-right: 8px;"></i>
          Entendi
        </button>
      </div>
    `;
    
    // Adicionar CSS de animações se não existir
    if (!document.querySelector('#numeric-modal-animations')) {
      const style = document.createElement('style');
      style.id = 'numeric-modal-animations';
      style.textContent = `
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        @keyframes slideInScale {
          from { 
            opacity: 0;
            transform: scale(0.8) translateY(-20px);
          }
          to { 
            opacity: 1;
            transform: scale(1) translateY(0);
          }
        }
        @keyframes fadeOut {
          from { opacity: 1; }
          to { opacity: 0; }
        }
        @keyframes slideOutScale {
          from { 
            opacity: 1;
            transform: scale(1) translateY(0);
          }
          to { 
            opacity: 0;
            transform: scale(0.8) translateY(-20px);
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Event listener para fechar modal
    const closeBtn = modal.querySelector('#close-numeric-modal');
    const closeModal = () => {
      modal.style.animation = 'fadeOut 0.3s ease-out';
      modalContent.style.animation = 'slideOutScale 0.3s ease-out';
      setTimeout(() => {
        if (modal.parentNode) {
          modal.remove();
        }
      }, 300);
    };
    
    closeBtn.addEventListener('click', closeModal);
    
    // Fechar ao clicar no fundo
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeModal();
      }
    });
    
    // Fechar com ESC
    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        closeModal();
        document.removeEventListener('keydown', handleEsc);
      }
    };
    document.addEventListener('keydown', handleEsc);
  }

  // Função para mostrar mensagem de sucesso da simbologia com timeout
  function showSymbologySuccessMessage() {
    // Verificar se já existe uma mensagem ativa
    let existingMessage = document.querySelector('.symbology-success-message');
    if (existingMessage) {
      existingMessage.remove();
    }
    
    // Criar nova mensagem
    const message = document.createElement('div');
    message.className = 'alert alert-success symbology-success-message';
    message.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border: none;
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      font-weight: 500;
      max-width: 400px;
      animation: slideInRight 0.3s ease-out;
    `;
    
    message.innerHTML = `
      <div style="display: flex; align-items: center; gap: 10px;">
        <i class="fas fa-check-circle" style="font-size: 18px;"></i>
        <div>
          <strong>Simbologia aplicada com sucesso!</strong><br>
          <small>A camada será exibida com o novo estilo no portal.</small><br>
          <small style="opacity: 0.8;">Esta mensagem se fechará em <span id="countdown">5</span>s</small>
        </div>
        <button type="button" class="btn-close btn-close-white ms-auto" style="font-size: 12px;"></button>
      </div>
    `;
    
    // Adicionar CSS de animação se não existir
    if (!document.querySelector('#symbology-animations')) {
      const style = document.createElement('style');
      style.id = 'symbology-animations';
      style.textContent = `
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
          from { transform: translateX(0); opacity: 1; }
          to { transform: translateX(100%); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Event listener para o botão de fechar
    const closeBtn = message.querySelector('.btn-close');
    closeBtn.addEventListener('click', () => {
      message.style.animation = 'slideOutRight 0.3s ease-out';
      setTimeout(() => message.remove(), 300);
    });
    
    // Adicionar ao documento
    document.body.appendChild(message);
    
    // Implementar contador regressivo
    let countdown = 5;
    const countdownElement = message.querySelector('#countdown');
    
    const countdownInterval = setInterval(() => {
      countdown--;
      if (countdownElement) {
        countdownElement.textContent = countdown;
      }
      
      if (countdown <= 0) {
        clearInterval(countdownInterval);
        if (message.parentNode) {
          message.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => {
            if (message.parentNode) {
              message.remove();
            }
          }, 300);
        }
      }
    }, 1000);
    
    // Limpar interval se a mensagem for fechada manualmente
    const originalCloseHandler = closeBtn.onclick;
    closeBtn.addEventListener('click', () => {
      clearInterval(countdownInterval);
    });
  }

  // Função para salvar simbologia no banco de dados
  async function saveSymbologyToDatabase(config) {
    try {
      const style = computeStyle();
      
      // Adicionar nomes personalizados das classes
      if (style.classes) {
        style.custom_class_names = [];
        for (let i = 0; i < style.classes; i++) {
          const className = localStorage.getItem(`graduated_class_${layerId}_${style.field}_${i}`) || `Classe ${i + 1}`;
          style.custom_class_names.push(className);
        }
      }
      
      // Adicionar configuração da legenda composta
      style.composite_legend = document.getElementById('composite-legend-toggle')?.checked || false;
      
      // Adicionar informações de faixas de valores para a legenda
      if (style.field && layerData) {
        const values = layerData.features
          .map(f => parseFloat(f.properties[style.field]))
          .filter(v => !isNaN(v))
          .sort((a, b) => a - b);
        
        if (values.length > 0) {
          const min = values[0];
          const max = values[values.length - 1];
          const classes = style.classes || 5;
          
          // Gerar breaks baseado no método
          let breaks = [];
          if (style.method === 'equal') {
            const step = (max - min) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(min + (i * step));
            }
          } else if (style.method === 'quantile') {
            const step = values.length / classes;
            for (let i = 0; i <= classes; i++) {
              const index = Math.floor(i * step);
              breaks.push(values[Math.min(index, values.length - 1)]);
            }
          } else if (style.method === 'jenks') {
            const step = values.length / classes;
            for (let i = 0; i <= classes; i++) {
              const index = Math.floor(i * step);
              breaks.push(values[Math.min(index, values.length - 1)]);
            }
          } else if (style.method === 'log') {
            const logMin = Math.log(Math.max(min, 0.1));
            const logMax = Math.log(max);
            const step = (logMax - logMin) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(Math.exp(logMin + (i * step)));
            }
          } else if (style.method === 'stddev') {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            const stddev = Math.sqrt(variance);
            const stddevStep = (2 * stddev) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(mean - stddev + (i * stddevStep));
            }
          } else if (style.method === 'arithmetic') {
            const step = (max - min) / classes;
            for (let i = 0; i <= classes; i++) {
              breaks.push(min + (i * step));
            }
          } else if (style.method === 'geometric') {
            const ratio = Math.pow(max / min, 1 / classes);
            for (let i = 0; i <= classes; i++) {
              breaks.push(min * Math.pow(ratio, i));
            }
          } else if (style.method === 'manual' && style.breaks) {
            breaks = style.breaks;
          }
          
          style.class_breaks = breaks;
        }
      }
      
      console.log('Enviando simbologia para o banco:', style);
      
      const response = await fetch(`/admin/layer/${layerId}/symbology/save`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(style)
      });
      
      if (response.ok) {
        console.log('Simbologia salva no banco de dados com sucesso');
        showSymbologySuccessMessage();
        return true;
      } else {
        const errorData = await response.json();
        console.error('Erro ao salvar simbologia no banco de dados:', errorData);
        showToast(`Erro ao salvar simbologia: ${errorData.message || 'Erro desconhecido'}`, 'error');
      }
    } catch (error) {
      console.error('Erro ao salvar simbologia:', error);
      showToast('Erro ao salvar simbologia no portal', 'error');
    }
  }

  // Função para carregar configurações salvas do usuário
  function loadUserConfig() {
    try {
      const savedConfig = localStorage.getItem(`symbology_config_${layerId}`);
      if (savedConfig) {
        const config = JSON.parse(savedConfig);
        
        // Restaurar configurações básicas
        if (config.field) {
          document.getElementById('field-select').value = config.field;
        }
        if (config.styleType) {
          document.getElementById('style-type').value = config.styleType;
        }
        if (config.geomType) {
          document.getElementById('geom-type').value = config.geomType;
        }
        if (config.palette) {
          document.getElementById('palette-select').value = config.palette;
        }
        if (config.paletteOpacity) {
          document.getElementById('palette-opacity').value = config.paletteOpacity || 1;
          document.getElementById('opacity-value').textContent = config.paletteOpacity;
        }
        if (config.paletteInvert !== undefined) {
          document.getElementById('palette-invert').checked = config.paletteInvert;
        }
        
        // Restaurar configurações de classes e método
        if (config.classes) {
          document.getElementById('classes').value = config.classes;
        }
        if (config.method) {
          document.getElementById('method').value = config.method;
        }
        if (config.manualBreaks) {
          document.getElementById('manual-breaks').value = config.manualBreaks;
        }
        
        // Restaurar configurações de cor personalizada
        if (config.strokeColor) {
          document.getElementById('stroke-color').value = config.strokeColor;
        }
        if (config.fillColor) {
          document.getElementById('fill-color').value = config.fillColor;
        }
        if (config.strokeWeight) {
          document.getElementById('stroke-weight').value = config.strokeWeight;
        }
        if (config.fillOpacity) {
          document.getElementById('fill-opacity').value = config.fillOpacity;
        }
        if (config.pointRadius) {
          document.getElementById('point-radius').value = config.pointRadius;
        }
        if (config.lineOpacity) {
          document.getElementById('line-opacity').value = config.lineOpacity;
        }
        if (config.lineDash) {
          document.getElementById('line-dash').value = config.lineDash;
        }
        
        // Restaurar configurações específicas de linha
        if (config.lineWeightDefault) {
          document.getElementById('line-weight-default').value = config.lineWeightDefault;
        }
        if (config.lineOpacityDefault) {
          document.getElementById('line-opacity-default').value = config.lineOpacityDefault;
          document.getElementById('line-opacity-value').textContent = config.lineOpacityDefault;
        }
        if (config.lineStyleDefault) {
          document.getElementById('line-style-default').value = config.lineStyleDefault;
          // Mostrar controles de padrão personalizado se necessário
          if (config.lineStyleDefault === 'custom') {
            document.getElementById('custom-line-style-controls').classList.remove('d-none');
          }
        }
        if (config.lineSpacingDefault) {
          document.getElementById('line-spacing-default').value = config.lineSpacingDefault;
          document.getElementById('line-spacing-value').textContent = config.lineSpacingDefault + 'px';
          
          // IMPORTANTE: Atualizar também o espaçamento de todas as categorias existentes
          setTimeout(() => {
            updateAllLineSpacings(config.lineSpacingDefault);
            // IMPORTANTE: Verificar se os controles de espaçamento devem ser mostrados
            syncLineSpacingAfterReorder();
          }, 100);
        }
        if (config.customLinePattern) {
          document.getElementById('custom-line-pattern').value = config.customLinePattern;
        }
        if (config.lineCapDefault) {
          document.getElementById('line-cap-default').value = config.lineCapDefault;
        }
        if (config.lineJoinDefault) {
          document.getElementById('line-join-default').value = config.lineJoinDefault;
        }
        if (config.lineMiterLimit) {
          document.getElementById('line-miter-limit').value = config.lineMiterLimit;
        }
        
        // Restaurar configurações específicas de ponto
        if (config.pointRadiusDefault) {
          document.getElementById('point-radius-default').value = config.pointRadiusDefault;
        }
        if (config.pointOpacityDefault) {
          document.getElementById('point-opacity-default').value = config.pointOpacityDefault;
          document.getElementById('point-opacity-value').textContent = config.pointOpacityDefault;
        }
        if (config.pointShapeDefault) {
          document.getElementById('point-shape-default').value = config.pointShapeDefault;
          // Mostrar controles de forma personalizada se necessário
          if (config.pointShapeDefault === 'custom') {
            document.getElementById('custom-point-shape-controls').classList.remove('d-none');
          }
        }
        if (config.pointBorderWidthDefault) {
          document.getElementById('point-border-width-default').value = config.pointBorderWidthDefault;
          document.getElementById('point-border-width-value').textContent = config.pointBorderWidthDefault + 'px';
        }
        if (config.customPointShape) {
          document.getElementById('custom-point-shape').value = config.customPointShape;
        }
        if (config.pointBorderColorDefault) {
          document.getElementById('point-border-color-default').value = config.pointBorderColorDefault;
        }
        if (config.pointBorderStyleDefault) {
          document.getElementById('point-border-style-default').value = config.pointBorderStyleDefault;
        }
        if (config.pointShadowDefault) {
          document.getElementById('point-shadow-default').value = config.pointShadowDefault;
          document.getElementById('point-shadow-value').textContent = config.pointShadowDefault + 'px';
        }
        
        // Restaurar configurações de polígono
        if (config.polygonBorderColor) {
          document.getElementById('polygon-border-color').value = config.polygonBorderColor;
        }
        if (config.polygonBorderWidth) {
          document.getElementById('polygon-border-width').value = config.polygonBorderWidth;
        }
        if (config.polygonBorderToggle !== undefined) {
          document.getElementById('polygon-border-toggle').checked = config.polygonBorderToggle;
        }
        
        // Restaurar configurações de rótulos
        if (config.labelField) {
          document.getElementById('label-field-select').value = config.labelField;
        }
        if (config.labelFont) {
          document.getElementById('label-font').value = config.labelFont;
        }
        if (config.labelSize) {
          document.getElementById('label-size').value = config.labelSize;
        }
        if (config.labelColor) {
          document.getElementById('label-color').value = config.labelColor;
        }
        if (config.labelBold !== undefined) {
          document.getElementById('label-bold').checked = config.labelBold;
        }
        if (config.labelItalic !== undefined) {
          document.getElementById('label-italic').checked = config.labelItalic;
        }
        if (config.labelBufferColor) {
          document.getElementById('label-buffer-color').value = config.labelBufferColor;
        }
        if (config.labelBufferSize) {
          document.getElementById('label-buffer-size').value = config.labelBufferSize;
        }
        if (config.labelBufferOpacity) {
          document.getElementById('label-buffer-opacity').value = config.labelBufferOpacity;
          document.getElementById('buffer-opacity-value').textContent = config.labelBufferOpacity;
        }
        if (config.labelOffsetX) {
          document.getElementById('label-offset-x').value = config.labelOffsetX;
        }
        if (config.labelOffsetY) {
          document.getElementById('label-offset-y').value = config.labelOffsetY;
        }
        if (config.labelsEnabled !== undefined) {
          document.getElementById('labels-enabled').checked = config.labelsEnabled;
        }
        
        // Restaurar configuração da legenda composta
        if (config.compositeLegend !== undefined) {
          const compositeToggle = document.getElementById('composite-legend-toggle');
          if (compositeToggle) {
            compositeToggle.checked = config.compositeLegend;
          }
        }
        
        // Restaurar configuração para ocultar valores de intervalo
        if (config.hideIntervals !== undefined) {
          const toggleIntervalsBtn = document.getElementById('toggle-intervals');
          if (toggleIntervalsBtn) {
            if (config.hideIntervals) {
              toggleIntervalsBtn.classList.add('btn-secondary');
              toggleIntervalsBtn.classList.remove('btn-outline-secondary');
              toggleIntervalsBtn.innerHTML = '<i class="fas fa-eye"></i> Mostrar Valores de Intervalo';
            } else {
              toggleIntervalsBtn.classList.remove('btn-secondary');
              toggleIntervalsBtn.classList.add('btn-outline-secondary');
              toggleIntervalsBtn.innerHTML = '<i class="fas fa-eye-slash"></i> Ocultar Valores de Intervalo';
            }
          }
        }
        
        // Restaurar configurações de tamanho proporcional
        if (config.proportionalSizeEnabled !== undefined) {
          document.getElementById('proportional-size-toggle').checked = config.proportionalSizeEnabled;
        }
        if (config.minLineWeight) {
          document.getElementById('min-line-weight').value = config.minLineWeight;
        }
        if (config.maxLineWeight) {
          document.getElementById('max-line-weight').value = config.maxLineWeight;
        }
        
        // Restaurar configurações de tamanho proporcional dos pontos
        if (config.proportionalPointSizeEnabled !== undefined) {
          const proportionalPointSizeToggle = document.getElementById('proportional-point-size-toggle');
          if (proportionalPointSizeToggle) {
            proportionalPointSizeToggle.checked = config.proportionalPointSizeEnabled;
            if (config.proportionalPointSizeEnabled) {
              toggleProportionalPointSizeContent();
            }
          }
        }
        if (config.minPointRadius) {
          document.getElementById('min-point-radius').value = config.minPointRadius;
          document.getElementById('min-point-radius-value').textContent = config.minPointRadius + 'px';
        }
        if (config.maxPointRadius) {
          document.getElementById('max-point-radius').value = config.maxPointRadius;
          document.getElementById('max-point-radius-value').textContent = config.maxPointRadius + 'px';
        }
        
        return true;
      }
    } catch (error) {
      console.error('Erro ao carregar configurações salvas:', error);
    }
    return false;
  }

  // Função para limpar configurações antigas (mais de 30 dias)
  function clearOldConfigs() {
    const now = Date.now();
    const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);
    
    Object.keys(localStorage).forEach(key => {
      if (key.startsWith('symbology_config_')) {
        try {
          const config = JSON.parse(localStorage.getItem(key));
          if (config.timestamp && config.timestamp < thirtyDaysAgo) {
            localStorage.removeItem(key);
          }
        } catch (e) {
          // Se não conseguir parsear, remove o item corrompido
          localStorage.removeItem(key);
        }
      }
    });
  }

  // Função para adicionar timestamp às configurações
  function addTimestampToConfig(config) {
    config.timestamp = Date.now();
    return config;
  }

  // Função para mostrar toast de feedback
  function showToast(message, type = 'info') {
    // Criar toast
    const toastDiv = document.createElement('div');
    toastDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
    toastDiv.style.cssText = `
      top: 20px;
      right: 20px;
      z-index: 9999;
      min-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    `;
    
    const iconClass = type === 'success' ? 'fa-check-circle' : 
                     type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle';
    
    toastDiv.innerHTML = `
      <i class="fas ${iconClass}"></i>
      <strong>${type === 'success' ? 'Sucesso!' : type === 'error' ? 'Erro!' : 'Info!'}</strong> ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(toastDiv);
    
    // Auto-remover após 3 segundos
    setTimeout(() => {
      if (toastDiv.parentNode) {
        toastDiv.remove();
      }
    }, 3000);
  }

  // Função para mostrar feedback visual de configurações carregadas
  function showConfigLoadedFeedback() {
    const feedbackDiv = document.createElement('div');
    feedbackDiv.className = 'alert alert-info alert-dismissible fade show';
    feedbackDiv.innerHTML = `
      <i class="fas fa-info-circle"></i>
      <strong>Configurações restauradas!</strong> Suas últimas configurações foram carregadas automaticamente.
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    const container = document.querySelector('.container-fluid');
    container.insertBefore(feedbackDiv, container.firstChild);
    
    // Auto-remover após 5 segundos
    setTimeout(() => {
      if (feedbackDiv.parentNode) {
        feedbackDiv.remove();
      }
    }, 5000);
  }

  // Função para limpar configurações da camada atual
  function clearCurrentConfig() {
    if (confirm('Tem certeza que deseja limpar todas as configurações salvas para esta camada?')) {
      localStorage.removeItem(`symbology_config_${layerId}`);
      alert('Configurações salvas limpas com sucesso!');
      location.reload(); // Recarrega a página para mostrar que as configurações foram removidas
    }
  }

  // Função para inicializar o mapa
  function initMap() {
    console.log('Inicializando mapa...');
    
    // Verificar se o container existe
    const mapContainer = document.getElementById('symbology-map');
    if (!mapContainer) {
      console.error('Container do mapa não encontrado!');
      return;
    }
    
    console.log('🔍 Container do mapa encontrado:', mapContainer);
    
    // Inicializar mapa Leaflet com coordenadas do Brasil
    map = L.map('symbology-map').setView([-15.7801, -47.9292], 4); // Centro do Brasil
    
    console.log('Mapa criado:', map);
    console.log('🔍 Debug mapa:', {
      hasMap: !!map,
      map: map,
      container: mapContainer
    });
    
    // Adicionar basemap padrão (OpenStreetMap)
    currentBasemap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);
    
    console.log('Basemap padrão adicionado:', currentBasemap);
    
    // Event listener para mudança de basemap
    document.getElementById('basemap-select').addEventListener('change', function() {
      const basemapType = this.value;
      console.log('Mudando basemap para:', basemapType);
      
      // Remover basemap atual
      if (currentBasemap) {
        map.removeLayer(currentBasemap);
      }
      
      // Adicionar novo basemap
      switch (basemapType) {
        case 'osm':
          currentBasemap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
          }).addTo(map);
          break;
        case 'google-streets':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
        case 'google-satellite':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
        case 'google-hybrid':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
        case 'google-terrain':
          currentBasemap = L.tileLayer('https://mt1.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
            attribution: '© Google Maps',
            maxZoom: 20
          }).addTo(map);
          break;
      }
      
      console.log('Novo basemap aplicado:', currentBasemap);
    });
    
    // Forçar atualização do mapa
    setTimeout(() => {
      if (map) {
        map.invalidateSize();
        console.log('Mapa atualizado com sucesso');
      }
    }, 100);
  }

  // Função para inicializar a página
  async function initializePage() {
    console.log('Inicializando página...');
    
    // Limpar configurações antigas
    clearOldConfigs();
    
    // Aguardar um pouco para garantir que o DOM esteja pronto
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Inicializar mapa
    console.log('🗺️ Inicializando mapa...');
    initMap();
    
    // Aguardar um pouco para o mapa ser inicializado
    await new Promise(resolve => setTimeout(resolve, 200));
    
    // Carregar campos da camada
    console.log('📋 Carregando campos da camada...');
    await loadLayerFields();
    
    // Carregar dados da camada (que também restaura configurações)
    console.log('📊 Carregando dados da camada...');
    await loadLayerData();
    
    // Inicializar visualização da paleta
    updatePalettePreview();
    
    // Forçar atualização do mapa novamente
    if (map) {
      setTimeout(() => {
        map.invalidateSize();
        console.log('Mapa finalizado com sucesso');
      }, 300);
    }
    
    // Mostrar feedback se configurações foram carregadas
    if (localStorage.getItem(`symbology_config_${layerId}`)) {
      showConfigLoadedFeedback();
    }
    
    console.log('Página inicializada com sucesso');
  }

  // Função para aplicar visibilidade dos blocos
  function applyVisibility() {
    const styleType = document.getElementById('style-type').value;
    const geomType = document.getElementById('geom-type').value;
    
    // Blocos condicionais
    document.getElementById('block-classes').classList.toggle('d-none', !['graduated', 'raster'].includes(styleType));
    document.getElementById('block-method').classList.toggle('d-none', !['graduated'].includes(styleType));
    document.getElementById('block-manual').classList.toggle('d-none', !(styleType === 'graduated' && document.getElementById('method').value === 'manual'));
    document.getElementById('block-category-editor').classList.toggle('d-none', styleType !== 'categorized');
    document.getElementById('block-custom-color').classList.toggle('d-none', styleType !== 'single');
    document.getElementById('block-polygon-border').classList.toggle('d-none', geomType !== 'polygon');
    document.getElementById('block-point-only').classList.toggle('d-none', geomType !== 'point');
    document.getElementById('block-line-only').classList.toggle('d-none', geomType !== 'line');
    
    // Controles específicos para linhas na simbologia categorizada
    const lineSpecificControls = document.getElementById('block-line-specific-controls');
    if (lineSpecificControls) {
      lineSpecificControls.classList.toggle('d-none', !(styleType === 'categorized' && geomType === 'line'));
    }
    
    // Controles específicos para pontos na simbologia categorizada
    const pointSpecificControls = document.getElementById('block-point-specific-controls');
    if (pointSpecificControls) {
      pointSpecificControls.classList.toggle('d-none', !(styleType === 'categorized' && geomType === 'point'));
    }
    
    // Mostrar paleta de cores para simbologia categorizada e graduada, ocultar para símbolo único
    document.getElementById('block-palette').classList.toggle('d-none', styleType === 'single');
    
    // Mostrar editor de classes para simbologia graduada
    document.getElementById('block-graduated-classes').classList.toggle('d-none', styleType !== 'graduated');
    
    // Mostrar opção de inversão de classes para simbologia graduada
    const blockClassInvert = document.getElementById('block-class-invert');
    if (blockClassInvert) {
      blockClassInvert.classList.toggle('d-none', styleType !== 'graduated');
    }
    
    // Controlar visibilidade do botão para ocultar valores de intervalo
    const blockHideIntervals = document.getElementById('block-hide-intervals');
    if (blockHideIntervals) {
      const compositeLegendToggle = document.getElementById('composite-legend-toggle');
      if (compositeLegendToggle) {
        // Mostrar o botão apenas quando legenda composta estiver ativa
        blockHideIntervals.classList.toggle('d-none', !compositeLegendToggle.checked);
      }
    }
    
    // Controlar visibilidade do modal method-info - APENAS para simbologia graduada
    const methodInfoContainer = document.getElementById('method-info');
    if (methodInfoContainer) {
      if (styleType === 'graduated') {
        // Mostrar modal method-info APENAS para simbologia graduada
        methodInfoContainer.classList.remove('d-none');
        showMethodInfo();
      } else {
        // Ocultar para TODOS os outros tipos de simbologia (categorized, single, etc.)
        methodInfoContainer.classList.add('d-none');
      }
    }
    

    
    // IMPORTANTE: Verificar se deve mostrar o menu de tamanho proporcional após aplicar visibilidade
    // Usar debounce para evitar múltiplas execuções
    if (window.applyVisibilityTimeout) {
      clearTimeout(window.applyVisibilityTimeout);
    }
    
    window.applyVisibilityTimeout = setTimeout(() => {
      checkAndShowProportionalSizeModal();
      checkAndShowProportionalPointSizeModal();
    }, 200);
  }
  
  // Função para mostrar informações padrão quando nenhum método está selecionado
  function showDefaultMethodInfo() {
    const infoContainer = document.getElementById('method-info');
    if (!infoContainer) return;
    
    infoContainer.innerHTML = `
      <div class="method-header">
        <div class="method-icon">
          <i class="fas fa-info-circle"></i>
        </div>
        <div class="method-title-section">
          <div class="method-title">Métodos de Classificação</div>
          <div class="method-description">Escolha um método para ver informações detalhadas</div>
        </div>
      </div>
      <div class="method-content-grid">
        <div class="method-detail-card">
          <div class="detail-header">
            <span class="detail-icon">🔵</span>
            <span class="detail-label">Como funciona</span>
          </div>
          <div class="detail-text">Selecione um método de classificação para visualizar informações detalhadas sobre como ele funciona, quando usá-lo e exemplos práticos.</div>
        </div>
        <div class="method-detail-card">
          <div class="detail-header">
            <span class="detail-icon">🟢</span>
            <span class="detail-label">Ideal para</span>
          </div>
          <div class="detail-text">Cada método tem suas características específicas. Escolha baseado no tipo de dados e objetivo da análise.</div>
        </div>
        <div class="method-detail-card">
          <div class="detail-header">
            <span class="detail-icon">🟡</span>
            <span class="detail-label">Exemplo</span>
          </div>
          <div class="detail-text">Após selecionar um método, você verá exemplos práticos de como ele classifica os dados.</div>
        </div>
      </div>
    `;
  }
  
  // Função para mostrar informações do método de classificação
  function showMethodInfo() {
    const methodSelect = document.getElementById('method');
    const infoContainer = document.getElementById('method-info');
    
    if (!methodSelect || !infoContainer) return;
    
    const selectedMethod = methodSelect.value;
    
    if (!selectedMethod) {
      // Se não há método selecionado, mostra informações padrão
      showDefaultMethodInfo();
      return;
    }
    
    const methodInfos = {
      'equal': {
        icon: 'fa-equals',
        title: 'Intervalos Iguais',
        description: 'Divide o range em classes de mesmo tamanho',
        howItWorks: 'O valor máximo menos o mínimo é dividido pelo número de classes',
        idealFor: 'Dados uniformemente distribuídos',
        example: 'Se os dados vão de 0 a 100 com 5 classes: 0-20, 20-40, 40-60, 60-80, 80-100'
      },
      'quantiles': {
        icon: 'fa-chart-pie',
        title: 'Quantis (Equal Count)',
        description: 'Cada classe tem o mesmo número de elementos',
        howItWorks: 'Os dados são ordenados e divididos em grupos com igual quantidade de registros',
        idealFor: 'Comparações percentuais e dados com distribuição desigual',
        example: 'Com 100 registros e 4 classes: 25 registros por classe (0-25%, 25-50%, 50-75%, 75-100%)'
      },
      'jenks': {
        icon: 'fa-chart-line',
        title: 'Quebras Naturais (Jenks)',
        description: 'Otimiza a separação natural dos dados',
        howItWorks: 'Algoritmo que minimiza variância dentro das classes e maximiza entre classes',
        idealFor: 'Dados com padrões naturais de agrupamento',
        example: 'Identifica automaticamente onde os dados "quebram" naturalmente, como mudanças bruscas de tendência'
      },
      'log': {
        icon: 'fa-chart-area',
        title: 'Classificação Logarítmica',
        description: 'Aplica escala logarítmica antes da classificação',
        howItWorks: 'Transforma os dados usando logaritmo (ln ou log10) antes de aplicar a classificação',
        idealFor: 'Dados com crescimento exponencial ou distribuição log-normal',
        example: 'Para dados de 1 a 1000: log(1)=0, log(10)=1, log(100)=2, log(1000)=3'
      },
      'stddev': {
        icon: 'fa-chart-bar',
        title: 'Desvio Padrão',
        description: 'Cria classes baseadas na média ± múltiplos do desvio padrão',
        howItWorks: 'Calcula a média e desvio padrão, criando classes como: média±1σ, média±2σ, etc.',
        idealFor: 'Destacar valores extremos, anomalias e distribuições normais',
        example: 'Se média=50 e σ=10: 40-60 (1σ), 30-40 e 60-70 (2σ), <30 e >70 (3σ)'
      },
      'arithmetic': {
        icon: 'fa-plus',
        title: 'Progressão Aritmética',
        description: 'Cada classe aumenta por uma diferença constante',
        howItWorks: 'Define uma razão constante (ex: +10) para cada classe subsequente',
        idealFor: 'Dados com crescimento linear constante',
        example: 'Com razão +15: 0-15, 15-30, 30-45, 45-60, 60-75'
      },
      'geometric': {
        icon: 'fa-times',
        title: 'Progressão Geométrica',
        description: 'Cada classe multiplica por uma razão constante',
        howItWorks: 'Define uma razão multiplicativa constante (ex: ×2) para cada classe',
        idealFor: 'Dados com crescimento exponencial ou multiplicativo',
        example: 'Com razão ×2: 1-2, 2-4, 4-8, 8-16, 16-32'
      },
      'manual': {
        icon: 'fa-edit',
        title: 'Classificação Manual',
        description: 'Defina exatamente onde cada classe começa e termina',
        howItWorks: 'Você especifica manualmente os valores de corte para cada classe',
        idealFor: 'Controle total sobre os intervalos e conhecimento específico do domínio',
        example: 'Defina classes como: 0-5, 5-10, 10-20, 20-50, >50'
      }
    };
    
    const info = methodInfos[selectedMethod];
    if (info) {
      infoContainer.innerHTML = `
        <div class="method-header">
          <div class="method-icon">
            <i class="fas ${info.icon}"></i>
          </div>
          <div class="method-title-section">
            <div class="method-title">${info.title}</div>
            <div class="method-description">${info.description}</div>
          </div>
        </div>
        <div class="method-content-grid">
          <div class="method-detail-card">
            <div class="detail-header">
              <span class="detail-icon">🔵</span>
              <span class="detail-label">Como funciona</span>
            </div>
            <div class="detail-text">${info.howItWorks}</div>
          </div>
          <div class="method-detail-card">
            <div class="detail-header">
              <span class="detail-icon">🟢</span>
              <span class="detail-label">Ideal para</span>
            </div>
            <div class="detail-text">${info.idealFor}</div>
          </div>
          <div class="method-detail-card">
            <div class="detail-header">
              <span class="detail-icon">🟡</span>
              <span class="detail-label">Exemplo</span>
            </div>
            <div class="detail-text">${info.example}</div>
          </div>
        </div>
      `;
      infoContainer.classList.remove('d-none');
    } else {
      infoContainer.classList.add('d-none');
    }
  }

  // Função para detectar tipo de geometria da camada
  function detectGeometryType(layerData) {
    if (!layerData || !layerData.features || layerData.features.length === 0) {
      return 'polygon'; // padrão
    }
    
    const firstFeature = layerData.features[0];
    if (!firstFeature.geometry) {
      return 'polygon'; // padrão
    }
    
    const geomType = firstFeature.geometry.type;
    
    switch (geomType.toLowerCase()) {
      case 'point':
      case 'multipoint':
        return 'point';
      case 'linestring':
      case 'multilinestring':
        return 'line';
      case 'polygon':
      case 'multipolygon':
        return 'polygon';
      default:
        return 'polygon'; // padrão
    }
  }

  // Função para carregar campos da camada
  async function loadLayerFields() {
    try {
      const response = await fetch(`/admin/layer/${layerId}/fields`);
      const data = await response.json();
      
      const fieldSelect = document.getElementById('field-select');
      const labelFieldSelect = document.getElementById('label-field-select');
      
      fieldSelect.innerHTML = '<option value="">Selecione uma coluna...</option>';
      labelFieldSelect.innerHTML = '<option value="">Selecione uma coluna...</option>';
      
      data.fields.forEach(field => {
        const option = document.createElement('option');
        option.value = field.name;
        option.textContent = `${field.name} (${field.dtype})`;
        fieldSelect.appendChild(option);
        
        const labelOption = document.createElement('option');
        labelOption.value = field.name;
        labelOption.textContent = `${field.name} (${field.dtype})`;
        labelFieldSelect.appendChild(labelOption);
      });
    } catch (error) {
      console.error('Erro ao carregar campos:', error);
    }
  }

  // Função para carregar categorias para um campo
  async function loadCategoriesForField(field) {
    try {
      console.log(`loadCategoriesForField: Carregando categorias para campo ${field}`);
      
      const response = await fetch(`/admin/layer/${layerId}/classify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ field, mode: 'categorized' })
      });
      
      const data = await response.json();
      console.log(`loadCategoriesForField: Resposta do backend:`, data);
      
      if (data.categories) {
        // Filtrar valores nulos/undefined e tratar campos numéricos de forma robusta
        const cleanCategories = data.categories
          .filter(cat => cat !== null && cat !== undefined && cat !== '')
          .map(cat => {
            // Para campos numéricos, preservar o valor original se possível
            if (typeof cat === 'number' || !isNaN(parseFloat(cat))) {
              // Se for número ou string numérica, converter para número para preservar precisão
              const num = parseFloat(cat);
              return isFinite(num) ? num : cat;
            }
            // Para outros tipos, converter para string para consistência
            return String(cat);
          });
        
        console.log(`loadCategoriesForField: Categorias limpas:`, cleanCategories);
        return cleanCategories;
      } else if (data.error) {
        console.error(`loadCategoriesForField: Erro do backend:`, data.error);
      }
    } catch (error) {
      console.error('loadCategoriesForField: Erro ao carregar categorias:', error);
    }
    return [];
  }



  // Função para distribuir cores de forma inteligente (primeira, última e intermediárias)
  function distributeColorsIntelligently(paletteColors, numClasses) {
    console.log(`distributeColorsIntelligently chamada: ${paletteColors.length} cores da paleta para ${numClasses} classes`);
    
    if (numClasses <= 0) return [];
    if (paletteColors.length === 0) return [];
    
    // Se há apenas uma classe, usar a primeira cor
    if (numClasses === 1) {
      return [paletteColors[0]];
    }
    
    // Se há apenas duas classes, usar primeira e última
    if (numClasses === 2) {
      return [paletteColors[0], paletteColors[paletteColors.length - 1]];
    }
    
    // Para mais de duas classes, distribuir de forma inteligente
    const distributedColors = [];
    
    // Primeira classe: primeira cor da paleta
    distributedColors.push(paletteColors[0]);
    
    // Classes intermediárias: cores distribuídas uniformemente
    if (numClasses > 2) {
      for (let i = 1; i < numClasses - 1; i++) {
        // Calcular índice para distribuição uniforme
        const paletteIndex = Math.floor((i / (numClasses - 1)) * (paletteColors.length - 1));
        const color = paletteColors[paletteIndex];
        distributedColors.push(color);
        console.log(`Classe intermediária ${i}: usando cor da paleta no índice ${paletteIndex} = ${color}`);
      }
    }
    
    // Última classe: última cor da paleta
    distributedColors.push(paletteColors[paletteColors.length - 1]);
    
    console.log(`Cores distribuídas: ${distributedColors.join(' -> ')}`);
    return distributedColors;
  }
  
  // Função para criar interface de classes categorizadas com edição manual
  function createCategorizedClassesInterface(categories) {
    console.log('createCategorizedClassesInterface: Iniciando criação da interface');
    console.log('createCategorizedClassesInterface: Categorias recebidas:', categories);
    
    const container = document.getElementById('category-list');
    if (!container) {
      console.error('createCategorizedClassesInterface: Container category-list não encontrado');
      return;
    }
    
    container.innerHTML = '';
    
    if (!categories || categories.length === 0) {
      console.warn('createCategorizedClassesInterface: Nenhuma categoria fornecida');
      container.innerHTML = '<div class="text-muted">Selecione um campo para editar as categorias.</div>';
      return;
    }
    
    console.log(`createCategorizedClassesInterface: Criando interface para ${categories.length} categorias`);
    
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    
    // Gerar cores da paleta
    let paletteColors;
    if (palette === 'custom') {
      const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
      const selectedPalette = customPalettes.find(p => p.name === palette);
      if (selectedPalette && selectedPalette.colors) {
        paletteColors = selectedPalette.colors;
      } else {
        paletteColors = brewer('Set3', Math.max(categories.length, 12), invert);
      }
    } else {
      paletteColors = brewer(palette, Math.max(categories.length, 12), invert);
    }
    
    // IMPORTANTE: Distribuir cores de forma inteligente (primeira, última e intermediárias)
    const distributedColors = distributeColorsIntelligently(paletteColors, categories.length);
    
    // Carregar cores personalizadas salvas ou usar cores distribuídas da paleta
    const customColors = [];
    const customNames = {};
    
    for (let i = 0; i < categories.length; i++) {
      const category = categories[i];
      const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
      
      // IMPORTANTE: Buscar por todos os índices possíveis para encontrar o nome salvo
      let savedName = null;
      for (let j = 0; j < categories.length; j++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${j}`);
        if (testName) {
          savedName = testName;
          break;
        }
      }
      
      // IMPORTANTE: Preservar cores personalizadas e usar cores distribuídas da paleta apenas se não houver cor salva
      if (savedColor) {
        customColors.push(savedColor);
        console.log(`createCategorizedClassesInterface - Usando cor personalizada para ${category}: ${savedColor}`);
      } else {
        // IMPORTANTE: Para campos numéricos, usar cor baseada no valor original, não na posição
        // Buscar cor salva por valor original da categoria
        let color = null;
        
        // Tentar encontrar cor salva por valor original (não por posição)
        if (typeof category === 'number' || !isNaN(parseFloat(category))) {
          // Para campos numéricos, buscar cor salva por valor
          const savedColorByValue = localStorage.getItem(`category_color_${layerId}_${category}`);
          if (savedColorByValue) {
            color = savedColorByValue;
            console.log(`createCategorizedClassesInterface - Usando cor salva por valor para ${category}: ${color}`);
          }
        }
        
        // Se não encontrou cor salva, usar cor distribuída da paleta baseada na posição original
        if (!color) {
          color = distributedColors[i];
          console.log(`createCategorizedClassesInterface - Gerando cor distribuída da paleta para ${category} na posição ${i}: ${color}`);
        }
        
        customColors.push(color);
      }
      
      if (savedName) {
        customNames[category] = savedName;
      }
    }
    
    // Criar interface para cada categoria
    customColors.forEach((color, index) => {
      const category = categories[index];
      
      // IMPORTANTE: Carregar configurações de linha salvas para esta categoria
      const savedLineStyle = localStorage.getItem(`line_style_${layerId}_${category}`);
      const savedLineSpacing = localStorage.getItem(`line_spacing_${layerId}_${category}`);
      const savedLineWeight = localStorage.getItem(`line_weight_${layerId}_${category}`);
      const savedLineOpacity = localStorage.getItem(`line_opacity_${layerId}_${category}`);
      
      console.log(`Categoria ${category}: estilo=${savedLineStyle}, espaçamento=${savedLineSpacing}, espessura=${savedLineWeight}, opacidade=${savedLineOpacity}`);
      
      const div = document.createElement('div');
      div.className = 'categorized-class-item p-3 border rounded mb-2 bg-light';
      div.setAttribute('draggable', 'true');
      div.setAttribute('data-index', index);
      div.setAttribute('data-category', category);
      
      div.innerHTML = `
        <!-- Header: Nome da categoria, preview e drag handle -->
        <div class="category-header d-flex align-items-center justify-content-between mb-2">
          <div class="d-flex align-items-center gap-2 flex-grow-1">
            <div class="drag-handle" style="cursor: move; color: #6c757d;">
              <i class="fas fa-grip-vertical"></i>
            </div>
            <div class="color-preview" style="width: 30px; height: 30px; background-color: ${color}; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;" data-index="${index}" data-category="${category}"></div>
            <input type="text" class="form-control form-control-sm categorized-class-name"
                   value="${customNames[category] || category}" data-index="${index}" data-category="${category}"
                   style="min-width: 150px;" placeholder="Nome da categoria">
            <span class="text-muted small ms-2">
              <span class="category-value" data-index="${index}">${category}</span>
            </span>
          </div>
          <button type="button" class="btn btn-outline-danger btn-sm remove-category-btn"
                  data-index="${index}" data-category="${category}" title="Remover categoria">
            <i class="fas fa-trash"></i>
          </button>
        </div>
        
        <!-- Corpo: Controles organizados em seções -->
        <div class="category-body">
          <!-- Seção de Cor -->
          <div class="control-section color-section mb-2">
            <div class="section-header d-flex align-items-center gap-2 mb-1">
              <i class="fas fa-palette text-primary"></i>
              <span class="small fw-bold">Cor</span>
            </div>
            <div class="d-flex align-items-center gap-2">
              <input type="color" class="form-control form-control-color categorized-class-color"
                     value="${color}" data-index="${index}" data-category="${category}" style="width: 40px; height: 30px;" title="Seletor de cor">
              <input type="text" class="form-control form-control-sm categorized-class-hex"
                     value="${color}" data-index="${index}" data-category="${category}" style="width: 80px;" placeholder="HEX" title="Código HEX">
              <button type="button" class="btn btn-outline-secondary btn-sm categorized-class-rgb-btn"
                      data-index="${index}" data-category="${category}" title="Mostrar/ocultar campos RGB">
                <i class="fas fa-sliders-h"></i> RGB
              </button>
            </div>
            
            <!-- Campos RGB (inicialmente ocultos) -->
            <div class="categorized-class-rgb-inputs d-none mt-2" data-index="${index}" data-category="${category}">
              <div class="d-flex align-items-center gap-2">
                <label class="form-label small mb-0 me-1">R:</label>
                <input type="number" class="form-control form-control-sm" min="0" max="255"
                       placeholder="R" style="width: 50px;" title="Valor Vermelho (0-255)">
                <label class="form-label small mb-0 me-1">G:</label>
                <input type="number" class="form-control form-control-sm" min="0" max="255"
                       placeholder="G" style="width: 50px;" title="Valor Verde (0-255)">
                <label class="form-label small mb-0 me-1">B:</label>
                <input type="number" class="form-control form-control-sm" min="0" max="255"
                       placeholder="B" style="width: 50px;" title="Valor Azul (0-255)">
              </div>
            </div>
          </div>
          
          <!-- Seção de Controles de Linha (apenas quando geom-type = line) -->
          ${document.getElementById('geom-type').value === 'line' ? `
          <div class="control-section line-section">
            <div class="section-header d-flex align-items-center gap-2 mb-1">
              <i class="fas fa-minus text-success"></i>
              <span class="small fw-bold">Propriedades da Linha</span>
            </div>
            <div class="line-controls-grid">
              <div class="control-group">
                <label class="form-label small mb-1">Espessura</label>
                <input type="number" class="form-control form-control-sm line-weight-input line-control-individual" 
                       value="${savedLineWeight || '2'}" min="1" max="10" step="0.5" style="width: 60px;" 
                       title="Espessura da linha para esta categoria">
              </div>
              
              <div class="control-group">
                <label class="form-label small mb-1">Opacidade</label>
                <input type="range" class="form-range form-range-sm line-opacity-input line-control-individual" 
                       min="0" max="1" step="0.05" value="${savedLineOpacity || '1'}" style="width: 60px;" 
                       title="Opacidade da linha para esta categoria">
              </div>
              
              <div class="control-group">
                <label class="form-label small mb-1">Estilo</label>
                <select class="form-select form-select-sm line-style-select line-control-individual" 
                        style="width: 80px;" title="Estilo da linha para esta categoria">
                  <option value="" ${savedLineStyle === '' ? 'selected' : ''}>Contínua</option>
                  <option value="5,5" ${savedLineStyle === '5,5' ? 'selected' : ''}>Tracejada</option>
                  <option value="10,5" ${savedLineStyle === '10,5' ? 'selected' : ''}>Tracejada Longa</option>
                  <option value="2,2" ${savedLineStyle === '2,2' ? 'selected' : ''}>Pontilhada</option>
                  <option value="1,1" ${savedLineStyle === '1,1' ? 'selected' : ''}>Pontilhada Fina</option>
                  <option value="5,2,1,2" ${savedLineStyle === '5,2,1,2' ? 'selected' : ''}>Traço-Ponto</option>
                  <option value="10,2,1,2" ${savedLineStyle === '10,2,1,2' ? 'selected' : ''}>Traço-Ponto Longo</option>
                  <option value="15,3,3,3" ${savedLineStyle === '15,3,3,3' ? 'selected' : ''}>Traço-Ponto-Ponto</option>
                  <option value="20,5,5,5" ${savedLineStyle === '20,5,5,5' ? 'selected' : ''}>Traço-Ponto-Ponto Longo</option>
                  <option value="custom" ${savedLineStyle === 'custom' ? 'selected' : ''}>Personalizado...</option>
                </select>
              </div>
              
              <!-- Controle de Espaçamento (inicialmente oculto) -->
              <div class="control-group line-spacing-controls ${savedLineStyle && savedLineStyle !== '' ? '' : 'd-none'}" data-category="${category}">
                <label class="form-label small mb-1">Espaçamento</label>
                <div class="d-flex align-items-center gap-1">
                  <input type="range" class="form-range form-range-sm line-spacing-slider line-control-individual" 
                         value="${savedLineSpacing || '10'}" min="1" max="30" step="0.5" style="width: 80px;" 
                         title="Ajustar espaçamento entre traços/pontos">
                  <span class="line-spacing-value small text-muted" style="min-width: 35px;">${savedLineSpacing || '10'}px</span>
                </div>
              </div>
            </div>
          </div>
          ` : ''}
        </div>
      `;
      
      container.appendChild(div);
      
      // Adicionar event listeners
      addCategorizedClassEventListeners(div, index, category, color);
    });
    
    // Adicionar funcionalidade de drag & drop
    setupDragAndDrop();
    
    // Configurar event listeners para controles específicos de linha
    if (document.getElementById('geom-type').value === 'line') {
      setupLineSpecificControls();
      
      // Configurar controles específicos para pontos
      setupPointSpecificControls();
    }
    
              // IMPORTANTE: Forçar sincronização da interface após criação completa
          setTimeout(() => {
            console.log('Forçando sincronização da interface após criação completa');
            forceCategorizedInterfaceSyncWithRetry(10, 200);
            
            // Verificar se ainda precisa de sincronização após um tempo
            setTimeout(() => {
              forceInterfaceSyncIfNeeded();
            }, 500);
            
                      // IMPORTANTE: Forçar aplicação da ordem personalizada
          setTimeout(() => {
            forceApplySavedOrder();
            
            // IMPORTANTE: Sincronizar espaçamento após forçar aplicação da ordem
            setTimeout(() => {
              syncLineSpacingAfterReorder();
            }, 200);
          }, 400);
            
            // Configurar monitor de sincronização da interface
            setupInterfaceSyncMonitor();
          }, 300);
    
    console.log('Interface de classes categorizadas criada com', categories.length, 'categorias');
  }
  
  // Função para adicionar event listeners para uma classe categorizada
  function addCategorizedClassEventListeners(div, index, category, initialColor) {
    const colorPreview = div.querySelector('.color-preview');
    const colorInput = div.querySelector('.categorized-class-color');
    const hexInput = div.querySelector('.categorized-class-hex');
    const rgbBtn = div.querySelector('.categorized-class-rgb-btn');
    const rgbInputs = div.querySelector('.categorized-class-rgb-inputs');
    const nameInput = div.querySelector('.categorized-class-name');
    const removeBtn = div.querySelector('.remove-category-btn');
    
    // Converter cor inicial para RGB
    const rgb = hexToRgb(initialColor);
    if (rgb && rgbInputs) {
      const rInput = rgbInputs.querySelector('input[placeholder="R"]');
      const gInput = rgbInputs.querySelector('input[placeholder="G"]');
      const bInput = rgbInputs.querySelector('input[placeholder="B"]');
      if (rInput && gInput && bInput) {
        rInput.value = rgb.r;
        gInput.value = rgb.g;
        bInput.value = rgb.b;
      }
    }
    
    // Event listener para seletor de cor
    colorInput.addEventListener('input', function() {
      const newColor = this.value;
      
      // IMPORTANTE: Atualizar preview instantaneamente
      if (colorPreview) {
        colorPreview.style.backgroundColor = newColor;
      }
      
      updateCategorizedClassColor(index, category, newColor);
    });
    
    // Event listener para mudança de cor (quando usuário seleciona cor do seletor)
    colorInput.addEventListener('change', function() {
      const newColor = this.value;
      
      // IMPORTANTE: Atualizar preview instantaneamente
      if (colorPreview) {
        colorPreview.style.backgroundColor = newColor;
      }
      
      console.log(`Cor alterada para categoria ${category}: ${newColor}`);
    });
    
    // Event listener para campo HEX
    hexInput.addEventListener('input', function() {
      const newColor = this.value;
      if (isValidHex(newColor)) {
        // IMPORTANTE: Atualizar preview instantaneamente
        if (colorPreview) {
          colorPreview.style.backgroundColor = newColor;
        }
        
        updateCategorizedClassColor(index, category, newColor);
      }
    });
    
    // Event listener para botão RGB
    rgbBtn.addEventListener('click', function() {
      rgbInputs.classList.toggle('d-none');
      this.classList.toggle('btn-secondary');
      this.classList.toggle('btn-outline-secondary');
    });
    
    // Event listeners para campos RGB
    const rInput = rgbInputs.querySelector('input[placeholder="R"]');
    const gInput = rgbInputs.querySelector('input[placeholder="G"]');
    const bInput = rgbInputs.querySelector('input[placeholder="B"]');
    
    [rInput, gInput, bInput].forEach(input => {
      input.addEventListener('input', function() {
        const r = parseInt(rInput.value) || 0;
        const g = parseInt(gInput.value) || 0;
        const b = parseInt(bInput.value) || 0;
        const newColor = rgbToHex(r, g, b);
        
        // IMPORTANTE: Atualizar preview instantaneamente
        if (colorPreview) {
          colorPreview.style.backgroundColor = newColor;
        }
        
        updateCategorizedClassColor(index, category, newColor);
      });
    });
    
    // Event listener para edição do nome da categoria
    nameInput.addEventListener('input', function() {
      const newName = this.value;
      updateCategorizedClassName(index, category, newName);
    });
    
    // Event listener para salvar nome quando o usuário terminar de editar
    nameInput.addEventListener('blur', function() {
      const newName = this.value.trim();
      if (newName && newName !== category) {
        // IMPORTANTE: Salvar configurações da legenda após alterar nome
        saveUserConfig();
      }
    });
    
    // Event listener para remover categoria
    removeBtn.addEventListener('click', function() {
      removeCategorizedClass(index, category);
    });
    
    // Limitar a 50 caracteres
    nameInput.setAttribute('maxlength', '50');
    
    // Event listeners para controles específicos de linha (se existirem)
    const lineWeightInput = div.querySelector('.line-weight-input');
    const lineOpacityInput = div.querySelector('.line-opacity-input');
    const lineStyleSelect = div.querySelector('.line-style-select');
    
    if (lineWeightInput) {
      lineWeightInput.addEventListener('change', function() {
        console.log(`Espessura da linha alterada para categoria ${category}:`, this.value);
        updatePreviewAndMapSynchronized();
      });
    }
    
    if (lineOpacityInput) {
      lineOpacityInput.addEventListener('input', function() {
        console.log(`Opacidade da linha alterada para categoria ${category}:`, this.value);
        updatePreviewAndMapSynchronized();
      });
    }
    
    if (lineStyleSelect) {
      lineStyleSelect.addEventListener('change', function() {
        console.log(`Estilo da linha alterado para categoria ${category}:`, this.value);
        
        // Mostrar/ocultar controles de espaçamento baseado na seleção
        const spacingControls = div.querySelector(`.line-spacing-controls[data-category="${category}"]`);
        
        console.log(`Mudança de estilo para categoria ${category}: novo valor=${this.value}, controles encontrados=${!!spacingControls}`);
        
        if (spacingControls) {
          if (this.value === '') {
            // Estilo "Contínua" - ocultar completamente os controles
            spacingControls.classList.add('d-none');
            console.log(`Ocultando controles de espaçamento para categoria ${category}`);
          } else {
            // Outros estilos - mostrar controles
            spacingControls.classList.remove('d-none');
            console.log(`Mostrando controles de espaçamento para categoria ${category}`);
          }
        } else {
          console.warn(`Controles de espaçamento não encontrados para categoria ${category}`);
        }
        
        // Forçar atualização imediata do mapa
        setTimeout(() => {
          updatePreviewAndMapSynchronized();
        }, 100);
      });
    }
    
    // Event listener para o slider de espaçamento
    const spacingSlider = div.querySelector('.line-spacing-slider');
    if (spacingSlider) {
      spacingSlider.addEventListener('input', function() {
        // Atualizar valor exibido
        const valueDisplay = div.querySelector('.line-spacing-value');
        if (valueDisplay) {
          valueDisplay.textContent = this.value + 'px';
        }
        
        console.log(`Espaçamento da linha alterado para categoria ${category}:`, this.value);
        
        // Salvar valor no localStorage
        localStorage.setItem(`line_spacing_${layerId}_${category}`, this.value);
        
        // IMPORTANTE: Salvar configurações da legenda
        saveUserConfig();
        
        // Forçar atualização imediata do mapa
        setTimeout(() => {
          updatePreviewAndMapSynchronized();
        }, 100);
      });
      
      // Carregar valor salvo se existir
      const savedSpacing = localStorage.getItem(`line_spacing_${layerId}_${category}`);
      if (savedSpacing) {
        spacingSlider.value = savedSpacing;
        const valueDisplay = div.querySelector('.line-spacing-value');
        if (valueDisplay) {
          valueDisplay.textContent = savedSpacing + 'px';
        }
      } else {
        // Se não houver valor salvo, usar padrão de 10px
        spacingSlider.value = 10;
        const valueDisplay = div.querySelector('.line-spacing-value');
        if (valueDisplay) {
          valueDisplay.textContent = '10px';
        }
      }
      
      // Definir estado inicial dos controles baseado no estilo selecionado
      const styleSelect = div.querySelector('.line-style-select');
      const spacingControls = div.querySelector(`.line-spacing-controls[data-category="${category}"]`);
      
      if (styleSelect && spacingControls) {
        console.log(`Estado inicial para categoria ${category}: estilo=${styleSelect.value}, controles=${spacingControls ? 'encontrados' : 'não encontrados'}`);
        
        if (styleSelect.value === '') {
          // Estilo "Contínua" - ocultar controles
          spacingControls.classList.add('d-none');
          console.log(`Ocultando controles de espaçamento para categoria ${category} (estilo Contínua)`);
        } else {
          // Outros estilos - mostrar controles
          spacingControls.classList.remove('d-none');
          console.log(`Mostrando controles de espaçamento para categoria ${category}`);
        }
      } else {
        console.warn(`Elementos não encontrados para categoria ${category}: styleSelect=${!!styleSelect}, spacingControls=${!!spacingControls}`);
      }
    }
  }
  
  // Função para atualizar cor de uma classe categorizada
  function updateCategorizedClassColor(index, category, newColor) {
    // IMPORTANTE: Buscar o elemento da categoria de forma mais robusta
    // Primeiro tentar pelo data-index e data-category, depois apenas pelo data-category
    let colorPreview = document.querySelector(`.color-preview[data-index="${index}"][data-category="${category}"]`);
    let hexInput = document.querySelector(`.categorized-class-hex[data-index="${index}"][data-category="${category}"]`);
    let rgbInputs = document.querySelector(`.categorized-class-rgb-inputs[data-index="${index}"][data-category="${category}"]`);
    
    // Se não encontrou pelo índice, buscar apenas pela categoria (mais robusto)
    if (!colorPreview) {
      colorPreview = document.querySelector(`.color-preview[data-category="${category}"]`);
    }
    if (!hexInput) {
      hexInput = document.querySelector(`.categorized-class-hex[data-category="${category}"]`);
    }
    if (!rgbInputs) {
      rgbInputs = document.querySelector(`.categorized-class-rgb-inputs[data-category="${category}"]`);
    }
    
    // Atualizar preview visual
    if (colorPreview) {
      colorPreview.style.backgroundColor = newColor;
      console.log(`Preview de cor atualizado para ${category}: ${newColor}`);
    } else {
      console.warn(`Preview de cor não encontrado para categoria ${category}`);
    }
    
    // Atualizar campo HEX
    if (hexInput) {
      hexInput.value = newColor;
      console.log(`Campo HEX atualizado para ${category}: ${newColor}`);
    } else {
      console.warn(`Campo HEX não encontrado para categoria ${category}`);
    }
    
    // Atualizar campos RGB se estiverem visíveis
    if (rgbInputs && !rgbInputs.classList.contains('d-none')) {
      const rgb = hexToRgb(newColor);
      if (rgb) {
        const rInput = rgbInputs.querySelector('input[placeholder="R"]');
        const gInput = rgbInputs.querySelector('input[placeholder="G"]');
        const bInput = rgbInputs.querySelector('input[placeholder="B"]');
        if (rInput && gInput && bInput) {
          rInput.value = rgb.r;
          gInput.value = rgb.g;
          bInput.value = rgb.b;
          console.log(`Campos RGB atualizados para ${category}: R=${rgb.r}, G=${rgb.g}, B=${rgb.b}`);
        }
      }
    }
    
    // Salvar cor personalizada
    localStorage.setItem(`category_color_${layerId}_${category}`, newColor);
    
    // IMPORTANTE: Salvar configurações da legenda após alterar cor
    saveUserConfig();
    
    // Atualizar preview e mapa INSTANTANEAMENTE
    updatePreviewAndMapSynchronized();
    
    // Salvar configuração
    saveUserConfig();
  }
  
  // Função para atualizar nome de uma classe categorizada
  function updateCategorizedClassName(index, category, newName) {
    console.log(`updateCategorizedClassName chamada: index=${index}, category=${category}, newName=${newName}`);
    
    // Verificar se o nome realmente mudou
    if (newName === category) {
      console.log('Nome não mudou, removendo entrada do localStorage');
      localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${index}`);
    } else {
      // Salvar nome personalizado
      const key = `categorized_class_name_${layerId}_${category}_${index}`;
      localStorage.setItem(key, newName);
      console.log(`Nome salvo no localStorage com chave: ${key} = ${newName}`);
      
      // Verificar se foi salvo corretamente
      const savedName = localStorage.getItem(key);
      console.log(`Nome verificado no localStorage: ${savedName}`);
    }
    
    // Limpar nomes duplicados e atualizar preview e mapa
    cleanupDuplicateNames();
    
    // IMPORTANTE: Forçar sincronização da legenda com a interface após edição (com retry)
    setTimeout(() => {
      forceCategorizedLegendSyncWithRetry();
    }, 100);
    
    updatePreviewAndMapSynchronized();
    
    // Salvar configuração
    saveUserConfig();
  }
  
  // Função para remover uma classe categorizada
  function removeCategorizedClass(index, category) {
    if (confirm(`Tem certeza que deseja remover a categoria "${category}"?`)) {
      // Remover do localStorage
      localStorage.removeItem(`category_color_${layerId}_${category}`);
      
      // Remover TODOS os nomes personalizados para esta categoria (todos os índices possíveis)
      for (let i = 0; i < 1000; i++) { // Limite alto para garantir que todos sejam removidos
        localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${i}`);
      }
      
      // Remover elemento do DOM
      const element = document.querySelector(`.categorized-class-item[data-index="${index}"][data-category="${category}"]`);
      if (element) {
        element.remove();
      }
      
      // Limpar nomes duplicados e atualizar preview e mapa
      cleanupDuplicateNames();
      
      // IMPORTANTE: Forçar sincronização da legenda com a interface após remoção (com retry)
      setTimeout(() => {
        forceCategorizedLegendSyncWithRetry();
      }, 100);
      
      updatePreviewAndMapSynchronized();
      
      // Salvar configuração
      saveUserConfig();
    }
  }
  
  // Função para configurar drag & drop
  function setupDragAndDrop() {
    const container = document.getElementById('category-list');
    if (!container) return;
    
    let draggedElement = null;
    let draggedIndex = null;
    
    // Event listeners para drag & drop
    container.addEventListener('dragstart', function(e) {
      if (e.target.closest('.categorized-class-item')) {
        draggedElement = e.target.closest('.categorized-class-item');
        draggedIndex = parseInt(draggedElement.dataset.index);
        draggedElement.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        
        // Adicionar classe de feedback visual
        container.classList.add('drag-over');
      }
    });
    
    container.addEventListener('dragend', function(e) {
      if (draggedElement) {
        draggedElement.classList.remove('dragging');
        draggedElement = null;
        draggedIndex = null;
        
        // Remover classe de feedback visual
        container.classList.remove('drag-over');
      }
    });
    
    container.addEventListener('dragover', function(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      
      // Adicionar feedback visual durante o drag
      if (!container.classList.contains('drag-over')) {
        container.classList.add('drag-over');
      }
    });
    
    container.addEventListener('dragleave', function(e) {
      // Só remover a classe se não estiver arrastando sobre um item filho
      if (!e.target.closest('.categorized-class-item')) {
        container.classList.remove('drag-over');
      }
    });
    
    container.addEventListener('drop', function(e) {
      e.preventDefault();
      
      if (!draggedElement) return;
      
      const targetElement = e.target.closest('.categorized-class-item');
      if (!targetElement || targetElement === draggedElement) return;
      
      const targetIndex = parseInt(targetElement.dataset.index);
      
      // Reordenar elementos
      reorderCategorizedClasses(draggedIndex, targetIndex);
      
      // Atualizar preview e mapa INSTANTANEAMENTE
      updatePreviewAndMapSynchronized();
      
      // IMPORTANTE: Sincronizar espaçamento após reordenação
      setTimeout(() => {
        syncLineSpacingAfterReorder();
      }, 100);
      
      // Salvar configuração
      saveUserConfig();
      
      // Remover classe de feedback visual
      container.classList.remove('drag-over');
    });
  }
  
  // Função para reordenar classes categorizadas
  function reorderCategorizedClasses(fromIndex, toIndex) {
    const container = document.getElementById('category-list');
    if (!container) return;
    
    const items = Array.from(container.querySelectorAll('.categorized-class-item'));
    if (fromIndex < 0 || fromIndex >= items.length || toIndex < 0 || toIndex >= items.length) return;
    
    console.log(`Reordenando categoria do índice ${fromIndex} para ${toIndex}`);
    
    // Mover elemento
    const item = items[fromIndex];
    if (fromIndex < toIndex) {
      container.insertBefore(item, items[toIndex + 1]);
    } else {
      container.insertBefore(item, items[toIndex]);
    }
    
    // Atualizar índices e preservar nomes personalizados
    const updatedItems = Array.from(container.querySelectorAll('.categorized-class-item'));
    const field = document.getElementById('field-select').value;
    
    // Coletar todos os nomes personalizados e cores personalizadas antes de atualizar índices
    const savedNames = {};
    const savedColors = {};
    updatedItems.forEach((item, index) => {
      const category = item.dataset.category;
      const nameInput = item.querySelector('.categorized-class-name');
      const colorInput = item.querySelector('.categorized-class-color');
      
      if (nameInput && nameInput.value !== category) {
        savedNames[category] = nameInput.value;
      }
      
      if (colorInput) {
        savedColors[category] = colorInput.value;
      }
    });
    
    // Atualizar índices
    updatedItems.forEach((item, index) => {
      item.dataset.index = index;
      item.querySelectorAll('[data-index]').forEach(el => {
        el.dataset.index = index;
      });
    });
    
    // Salvar nova ordem no localStorage
    if (field) {
      const newOrder = updatedItems.map(item => item.dataset.category);
      localStorage.setItem(`categorized_order_${layerId}_${field}`, JSON.stringify(newOrder));
      console.log('Nova ordem salva:', newOrder);
    }
    
    // Reaplicar nomes personalizados e cores personalizadas com novos índices
    if (Object.keys(savedNames).length > 0 || Object.keys(savedColors).length > 0) {
      updatedItems.forEach((item, index) => {
        const category = item.dataset.category;
        
        // Reaplicar nome personalizado
        if (savedNames[category]) {
          // Salvar nome com novo índice
          localStorage.setItem(`categorized_class_name_${layerId}_${category}_${index}`, savedNames[category]);
          // Atualizar input
          const nameInput = item.querySelector('.categorized-class-name');
          if (nameInput) {
            nameInput.value = savedNames[category];
          }
        }
        
        // Reaplicar cor personalizada
        if (savedColors[category]) {
          // Salvar cor (não precisa de índice, é única por categoria)
          localStorage.setItem(`category_color_${layerId}_${category}`, savedColors[category]);
          // Atualizar inputs de cor
          const colorInput = item.querySelector('.categorized-class-color');
          const hexInput = item.querySelector('.categorized-class-hex');
          const colorPreview = item.querySelector('.color-preview');
          
          if (colorInput) colorInput.value = savedColors[category];
          if (hexInput) hexInput.value = savedColors[category];
          if (colorPreview) colorPreview.style.backgroundColor = savedColors[category];
        }
      });
      console.log('Nomes e cores personalizados reaplicados com novos índices');
    }
    
    console.log(`Categoria movida do índice ${fromIndex} para ${toIndex}`);
    
    // Limpar nomes duplicados e atualizar preview e mapa
    cleanupDuplicateNames();
    
    // IMPORTANTE: Forçar sincronização da legenda com a interface após reordenação (com retry)
    setTimeout(() => {
      forceCategorizedLegendSyncWithRetry();
    }, 100);
    
    updatePreviewAndMapSynchronized();
  }
  
  // Função para atualizar cores das classes categorizadas quando a paleta muda
  function updateCategorizedClassColors() {
    console.log('updateCategorizedClassColors: Iniciando atualização de cores');
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') {
      console.log('updateCategorizedClassColors: Não é simbologia categorizada, saindo');
      return;
    }
    
    const field = document.getElementById('field-select').value;
    if (!field) {
      console.log('updateCategorizedClassColors: Nenhum campo selecionado, saindo');
      return;
    }
    
    console.log(`updateCategorizedClassColors: Recarregando categorias para campo ${field}`);
    
    // Recarregar categorias e aplicar nova paleta, preservando informações do usuário
    loadCategoriesForField(field).then(categories => {
      console.log(`updateCategorizedClassColors: Categorias recarregadas:`, categories);
      
      try {
        // Preservar ordem personalizada
        const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
        let orderArray = [];
        
        if (savedOrder) {
          try {
            orderArray = JSON.parse(savedOrder);
            console.log(`updateCategorizedClassColors: Ordem personalizada carregada:`, orderArray);
          } catch (e) {
            console.warn('updateCategorizedClassColors: Erro ao carregar ordem personalizada:', e);
          }
        }
        
        // Preservar nomes personalizados e cores personalizadas
        const savedNames = {};
        const savedColors = {};
        categories.forEach((category, index) => {
          console.log(`updateCategorizedClassColors: Processando categoria ${index}: ${category}`);
          
          // IMPORTANTE: Buscar por todos os índices possíveis para encontrar o nome salvo
          let savedName = null;
          for (let j = 0; j < categories.length; j++) {
            const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${j}`);
            if (testName) {
              savedName = testName;
              break;
            }
          }
          
          // IMPORTANTE: Preservar cor personalizada por valor original da categoria
          const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
          
          if (savedName) {
            savedNames[category] = savedName;
            console.log(`updateCategorizedClassColors: Nome personalizado encontrado para ${category}: ${savedName}`);
          }
          
          if (savedColor) {
            savedColors[category] = savedColor;
            console.log(`updateCategorizedClassColors: Cor personalizada encontrada para ${category}: ${savedColor}`);
          }
        });
        
        console.log(`updateCategorizedClassColors: Nomes salvos:`, savedNames);
        console.log(`updateCategorizedClassColors: Cores salvas:`, savedColors);
        
        // IMPORTANTE: Criar interface preservando informações do usuário
        // Mas primeiro, garantir que as cores sejam preservadas por valor, não por posição
        console.log('updateCategorizedClassColors: Criando interface de categorias...');
        
        // IMPORTANTE: Preservar cores personalizadas por valor original da categoria
        const preservedColors = {};
        categories.forEach(category => {
          const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
          if (savedColor) {
            preservedColors[category] = savedColor;
            console.log(`updateCategorizedClassColors: Preservando cor para ${category}: ${savedColor}`);
          }
        });
        
        // Criar interface com cores preservadas
        createCategorizedClassesInterface(categories);
        
        // IMPORTANTE: Aplicar cores preservadas após criar a interface
        if (Object.keys(preservedColors).length > 0) {
          setTimeout(() => {
            const categoryItems = Array.from(document.querySelectorAll('.categorized-class-item'));
            categoryItems.forEach(item => {
              const category = item.dataset.category;
              const savedColor = preservedColors[category];
              if (savedColor) {
                // Atualizar inputs de cor
                const colorInput = item.querySelector('.categorized-class-color');
                const hexInput = item.querySelector('.categorized-class-hex');
                const colorPreview = item.querySelector('.color-preview');
                
                if (colorInput) colorInput.value = savedColor;
                if (hexInput) hexInput.value = savedColor;
                if (colorPreview) colorPreview.style.backgroundColor = savedColor;
                
                console.log(`updateCategorizedClassColors: Cor preservada aplicada para ${category}: ${savedColor}`);
              }
            });
          }, 100);
        }
        
        // Aplicar ordem personalizada se existir
        if (orderArray.length > 0) {
          console.log('updateCategorizedClassColors: Aplicando ordem personalizada...');
          applySavedOrder(orderArray, savedNames, savedColors);
        }
        
        // Limpar nomes duplicados e atualizar preview e mapa
        console.log('updateCategorizedClassColors: Limpando nomes duplicados...');
        cleanupDuplicateNames();
        
        // IMPORTANTE: Forçar sincronização da legenda com a interface após mudança de paleta (com retry)
        setTimeout(() => {
          console.log('updateCategorizedClassColors: Forçando sincronização da legenda...');
          forceCategorizedLegendSyncWithRetry();
        }, 200);
        
        console.log('updateCategorizedClassColors: Atualizando preview e mapa...');
        updatePreviewAndMapSynchronized();
        
      } catch (error) {
        console.error('updateCategorizedClassColors: Erro durante processamento:', error);
        console.error('updateCategorizedClassColors: Stack trace:', error.stack);
      }
    }).catch(error => {
      console.error('updateCategorizedClassColors: Erro ao carregar categorias:', error);
      console.error('updateCategorizedClassColors: Stack trace:', error.stack);
    });
  }
  
  // Função para aplicar ordem salva
  function applySavedOrder(orderArray, savedNames, savedColors = {}) {
    const container = document.getElementById('category-list');
    if (!container) return;
    
    const items = Array.from(container.querySelectorAll('.categorized-class-item'));
    
    console.log(`Aplicando ordem personalizada para ${items.length} itens:`, orderArray);
    
    // IMPORTANTE: Reordenar baseado na ordem salva de forma mais robusta
    const reorderedItems = [];
    
    // Primeiro, adicionar itens na ordem salva
    orderArray.forEach((originalValue, newIndex) => {
      const item = items.find(item => {
        const category = item.dataset.category;
        if (category === originalValue) return true;
        // Para campos numéricos, comparar também como números
        if (typeof category === 'number' && typeof originalValue === 'number') {
          return Math.abs(category - originalValue) < 1e-10; // Tolerância para precisão numérica
        }
        // Para strings numéricas, converter e comparar
        if (!isNaN(parseFloat(category)) && !isNaN(parseFloat(originalValue))) {
          return Math.abs(parseFloat(category) - parseFloat(originalValue)) < 1e-10;
        }
        return false;
      });
      if (item) {
        reorderedItems.push(item);
        console.log(`Item ${originalValue} movido para posição ${reorderedItems.length - 1}`);
      }
    });
    
    // Depois, adicionar itens que não estão na ordem salva (novas categorias)
    items.forEach(item => {
      const category = item.dataset.category;
      const isInOrder = orderArray.some(originalValue => {
        if (category === originalValue) return true;
        // Para campos numéricos, comparar também como números
        if (typeof category === 'number' && typeof originalValue === 'number') {
          return Math.abs(category - originalValue) < 1e-10; // Tolerância para precisão numérica
        }
        // Para strings numéricas, converter e comparar
        if (!isNaN(parseFloat(category)) && !isNaN(parseFloat(originalValue))) {
          return Math.abs(parseFloat(category) - parseFloat(originalValue)) < 1e-10;
        }
        return false;
      });
      
      if (!isInOrder) {
        reorderedItems.push(item);
        console.log(`Item ${category} (novo) adicionado na posição ${reorderedItems.length - 1}`);
      }
    });
    
    // Aplicar nova ordem na interface
    reorderedItems.forEach((item, newIndex) => {
      // Atualizar atributo data-index
      item.setAttribute('data-index', newIndex);
      
      // Mover elemento para a nova posição
      container.appendChild(item);
    });
    
    console.log(`Reordenação concluída: ${reorderedItems.length} itens na nova ordem`);
    
    // Atualizar índices em todos os elementos filhos
    const updatedItems = Array.from(container.querySelectorAll('.categorized-class-item'));
    updatedItems.forEach((item, index) => {
      item.dataset.index = index;
      item.querySelectorAll('[data-index]').forEach(el => {
        el.dataset.index = index;
      });
    });
    
    // Aplicar nomes personalizados e cores personalizadas se disponíveis
    if (savedNames && Object.keys(savedNames).length > 0) {
      updatedItems.forEach((item, index) => {
        const category = item.dataset.category;
        const nameInput = item.querySelector('.categorized-class-name');
        // Para campos numéricos, buscar por todos os tipos de comparação
        const savedName = findSavedNameForCategory(category, savedNames);
        if (nameInput && savedName) {
          nameInput.value = savedName;
          // Salvar o nome com o novo índice
          localStorage.setItem(`categorized_class_name_${layerId}_${category}_${index}`, savedName);
          console.log(`Nome personalizado aplicado para ${category} na posição ${index}: ${savedName}`);
        }
      });
    }
    
    // Aplicar cores personalizadas se disponíveis
    if (savedColors && Object.keys(savedColors).length > 0) {
      updatedItems.forEach((item, index) => {
        const category = item.dataset.category;
        // Para campos numéricos, buscar por todos os tipos de comparação
        const savedColor = findSavedColorForCategory(category, savedColors);
        if (savedColor) {
          // Atualizar inputs de cor
          const colorInput = item.querySelector('.categorized-class-color');
          const hexInput = item.querySelector('.categorized-class-hex');
          const colorPreview = item.querySelector('.color-preview');
          
          if (colorInput) colorInput.value = savedColor;
          if (hexInput) hexInput.value = savedColor;
          if (colorPreview) colorPreview.style.backgroundColor = savedColor;
          
          console.log(`Cor personalizada aplicada para ${category} na posição ${index}: ${savedColor}`);
        }
      });
    }
    
    // IMPORTANTE: Aplicar configurações de linha personalizadas (estilo, espaçamento, espessura, opacidade)
    updatedItems.forEach((item, index) => {
      const category = item.dataset.category;
      
      // Aplicar estilo da linha salvo
      const savedLineStyle = localStorage.getItem(`line_style_${layerId}_${category}`);
      if (savedLineStyle !== null) {
        const styleSelect = item.querySelector('.line-style-select');
        if (styleSelect) {
          styleSelect.value = savedLineStyle;
          console.log(`Estilo da linha aplicado para ${category}: ${savedLineStyle}`);
          
          // Mostrar/ocultar controles de espaçamento baseado no estilo
          const spacingControls = item.querySelector(`.line-spacing-controls[data-category="${category}"]`);
          if (spacingControls) {
            if (savedLineStyle === '') {
              spacingControls.classList.add('d-none');
            } else {
              spacingControls.classList.remove('d-none');
            }
          }
        }
      }
      
      // Aplicar espaçamento da linha salvo
      const savedLineSpacing = localStorage.getItem(`line_spacing_${layerId}_${category}`);
      if (savedLineSpacing !== null) {
        const spacingSlider = item.querySelector('.line-spacing-slider');
        const spacingValue = item.querySelector('.line-spacing-value');
        if (spacingSlider) {
          spacingSlider.value = savedLineSpacing;
          if (spacingValue) {
            spacingValue.textContent = savedLineSpacing + 'px';
          }
          console.log(`Espaçamento da linha aplicado para ${category}: ${savedLineSpacing}`);
        }
      }
      
      // Aplicar espessura da linha salva
      const savedLineWeight = localStorage.getItem(`line_weight_${layerId}_${category}`);
      if (savedLineWeight !== null) {
        const weightInput = item.querySelector('.line-weight-input');
        if (weightInput) {
          weightInput.value = savedLineWeight;
          console.log(`Espessura da linha aplicada para ${category}: ${savedLineWeight}`);
        }
      }
      
      // Aplicar opacidade da linha salva
      const savedLineOpacity = localStorage.getItem(`line_opacity_${layerId}_${category}`);
      if (savedLineOpacity !== null) {
        const opacityInput = item.querySelector('.line-opacity-input');
        if (opacityInput) {
          opacityInput.value = savedLineOpacity;
          console.log(`Opacidade da linha aplicada para ${category}: ${savedLineOpacity}`);
        }
      }
    });
    
    // IMPORTANTE: Reconfigurar drag & drop após reordenação
    setTimeout(() => {
      console.log('Reconfigurando drag & drop após aplicar ordem personalizada');
      setupDragAndDrop();
      
      // IMPORTANTE: Sincronizar espaçamento após aplicar ordem personalizada
      syncLineSpacingAfterReorder();
    }, 100);
    
    console.log('Ordem personalizada aplicada com sucesso:', orderArray);
  }
  
  // Função auxiliar para encontrar nome salvo para uma categoria (tratando campos numéricos)
  function findSavedNameForCategory(category, savedNames) {
    // Busca direta
    if (savedNames[category]) return savedNames[category];
    
    // Para campos numéricos, buscar por todos os tipos de comparação
    for (const [savedCategory, savedName] of Object.entries(savedNames)) {
      if (savedCategory === category) return savedName;
      // Para campos numéricos, comparar também como números
      if (typeof savedCategory === 'number' && typeof category === 'number') {
        if (Math.abs(savedCategory - category) < 1e-10) return savedName; // Tolerância para precisão numérica
      }
      // Para strings numéricas, converter e comparar
      if (!isNaN(parseFloat(savedCategory)) && !isNaN(parseFloat(category))) {
        if (Math.abs(parseFloat(savedCategory) - parseFloat(category)) < 1e-10) return savedName;
      }
    }
    return null;
  }
  
  // Função auxiliar para encontrar cor salva para uma categoria (tratando campos numéricos)
  function findSavedColorForCategory(category, savedColors) {
    // Busca direta
    if (savedColors[category]) return savedColors[category];
    
    // Para campos numéricos, buscar por todos os tipos de comparação
    for (const [savedCategory, savedColor] of Object.entries(savedColors)) {
      if (savedCategory === category) return savedColor;
      // Para campos numéricos, comparar também como números
      if (typeof savedCategory === 'number' && typeof category === 'number') {
        if (Math.abs(savedCategory - category) < 1e-10) return savedColor; // Tolerância para precisão numérica
      }
      // Para strings numéricas, converter e comparar
      if (!isNaN(parseFloat(savedCategory)) && !isNaN(parseFloat(category))) {
        if (Math.abs(parseFloat(savedCategory) - parseFloat(category)) < 1e-10) return savedColor;
      }
    }
    return null;
  }

  // Função para atualizar preview e mapa de forma sincronizada
  function updatePreviewAndMapSynchronized() {
    console.log('updatePreviewAndMapSynchronized chamada');
    
          // IMPORTANTE: Para simbologia categorizada, sempre sincronizar com a interface
      const currentStyleType = document.getElementById('style-type').value;
      if (currentStyleType === 'categorized') {
        console.log('Simbologia categorizada detectada - sincronizando com interface');
        
        // Forçar atualização da interface primeiro
        const field = document.getElementById('field-select').value;
        if (field) {
          // Verificar se a interface existe e está atualizada
          const categoryList = document.getElementById('category-list');
          if (categoryList && categoryList.children.length > 0) {
            console.log('Interface de categorias encontrada - sincronizando');
            
            // Atualizar preview diretamente da interface
            const legendDiv = document.getElementById('preview-legend');
            if (legendDiv) {
              const style = computeStyle();
              console.log('Style computado para simbologia categorizada:', style);
              console.log('Categorias do style:', style.categories);
              renderCategorizedPreviewFromInterface(legendDiv, style);
            }
            
            // Atualizar mapa
            setTimeout(() => {
              try {
                console.log('Chamando renderMapPreview para simbologia categorizada...');
                renderMapPreview();
              } catch (error) {
                console.error('Erro ao renderizar mapa:', error);
              }
            }, 10);
            
            return; // Sair da função para simbologia categorizada
          }
        }
      }
    
    // Para outros tipos de simbologia, usar o método padrão
    setTimeout(() => {
      console.log('Executando refreshPreview e renderMapPreview (método padrão)');
      
      try {
        // Atualizar preview primeiro
        refreshPreview();
        
        // Atualizar mapa em seguida
        setTimeout(() => {
          try {
            renderMapPreview();
          } catch (error) {
            console.error('Erro ao renderizar mapa:', error);
          }
        }, 10);
      } catch (error) {
        console.error('Erro ao atualizar preview:', error);
      }
    }, 10);
  }
  
  // Função para renderizar preview categorizado diretamente da interface
  function renderCategorizedPreviewFromInterface(legendDiv, style) {
    console.log('renderCategorizedPreviewFromInterface chamada');
    
    // IMPORTANTE: Buscar informações diretamente da interface "Cores e Nomes das Classes"
    const categoryList = document.getElementById('category-list');
    if (!categoryList) {
      console.log('Interface de categorias não encontrada, usando fallback');
      renderCategorizedPreviewFallback(legendDiv, style);
      return;
    }
    
    // Obter todas as categorias da interface
    const categoryItems = Array.from(categoryList.querySelectorAll('.categorized-class-item'));
    if (categoryItems.length === 0) {
      console.log('Nenhuma categoria encontrada na interface, usando fallback');
      renderCategorizedPreviewFallback(legendDiv, style);
      return;
    }
    
    console.log(`Encontradas ${categoryItems.length} categorias na interface`);
    
    // Verificar se as categorias têm dados válidos
    let validCategories = 0;
    const categories = categoryItems.map((item, index) => {
      const category = item.dataset.category;
      const colorInput = item.querySelector('.categorized-class-color');
      const nameInput = item.querySelector('.categorized-class-name');
      
      if (!colorInput || !nameInput) {
        console.log(`Categoria ${index}: inputs não encontrados`);
        return null;
      }
      
      const color = colorInput.value;
      const name = nameInput.value;
      
      // Verificar se os dados são válidos
      if (!color || color === '#cccccc' || !name) {
        console.log(`Categoria ${index}: dados inválidos - cor: ${color}, nome: ${name}`);
        return null;
      }
      
      validCategories++;
      console.log(`Categoria ${index}: ${category} -> ${name}, cor: ${color}`);
      
      return {
        category: name,
        color: color,
        original_value: category,
        index: index
      };
    }).filter(Boolean); // Remover categorias inválidas
    
    if (validCategories === 0) {
      console.log('Nenhuma categoria válida encontrada na interface, usando fallback');
      renderCategorizedPreviewFallback(legendDiv, style);
      return;
    }
    
    console.log(`Categorias válidas encontradas: ${validCategories}/${categoryItems.length}`);
    
    // Aplicar ordem personalizada se existir
    const field = style.field;
    let orderedCategories = [...categories];
    
    if (field) {
      const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
      if (savedOrder) {
        try {
          const orderArray = JSON.parse(savedOrder);
          console.log('Aplicando ordem personalizada:', orderArray);
          
          // Reordenar baseado na ordem salva
          orderedCategories = orderArray.map(originalValue => {
            return categories.find(cat => {
              if (cat.original_value === originalValue) return true;
              // Para campos numéricos, comparar também como números
              if (typeof cat.original_value === 'number' && typeof originalValue === 'number') {
                return Math.abs(cat.original_value - originalValue) < 1e-10; // Tolerância para precisão numérica
              }
              // Para strings numéricas, converter e comparar
              if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(originalValue))) {
                return Math.abs(parseFloat(cat.original_value) - parseFloat(originalValue)) < 1e-10;
              }
              return false;
            });
          }).filter(Boolean);
          
          // Adicionar categorias que não estão na ordem salva
          categories.forEach(cat => {
            const isInOrder = orderArray.some(originalValue => {
              if (cat.original_value === originalValue) return true;
              // Para campos numéricos, comparar também como números
              if (typeof cat.original_value === 'number' && typeof originalValue === 'number') {
                return Math.abs(cat.original_value - originalValue) < 1e-10; // Tolerância para precisão numérica
              }
              // Para strings numéricas, converter e comparar
              if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(originalValue))) {
                return Math.abs(parseFloat(cat.original_value) - parseFloat(originalValue)) < 1e-10;
              }
              return false;
            });
            
            if (!isInOrder) {
              orderedCategories.push(cat);
            }
          });
        } catch (e) {
          console.warn('Erro ao aplicar ordem personalizada:', e);
        }
      }
    }
    
    // Renderizar legenda
    const legendTitle = style.palette ? `Legenda Categorizada - Paleta: ${style.palette}` : 'Legenda Categorizada';
    
    legendDiv.innerHTML = `
      <div class="mb-2">
        <h6 class="text-primary mb-2">${legendTitle}</h6>
        <small class="text-muted">${orderedCategories.length} categorias encontradas</small>
      </div>
      ${orderedCategories.map((cat, index) => `
        <div class="d-flex align-items-center gap-3 p-2 border rounded mb-2 bg-light">
          <div class="d-flex align-items-center gap-2">
            <div style="width: 24px; height: 24px; background-color: ${cat.color}; border: 2px solid #333; border-radius: 4px;"></div>
            <span class="fw-bold">${index + 1}.</span>
          </div>
          <div class="flex-grow-1">
            <div class="fw-semibold">${cat.category}</div>
            <small class="text-muted">Cor: ${cat.color}</small>
          </div>
        </div>
      `).join('')}
    `;
    
    console.log('Legenda categorizada renderizada da interface:', orderedCategories);
  }
  
  // Função de fallback para quando a interface não estiver disponível
  function renderCategorizedPreviewFallback(legendDiv, style) {
    console.log('renderCategorizedPreviewFallback chamada');
    
    const legendTitle = style.palette ? `Legenda Categorizada - Paleta: ${style.palette}` : 'Legenda Categorizada';
    
    // Garantir que as categorias tenham cores válidas
    const validCategories = style.categories.filter(cat => cat && cat.color && cat.category);
    
    if (validCategories.length === 0) {
      legendDiv.innerHTML = `
        <div class="mb-2">
          <h6 class="text-primary mb-2">${legendTitle}</h6>
          <small class="text-muted text-warning">Nenhuma categoria encontrada. Selecione um campo válido.</small>
        </div>
      `;
      return;
    }
    
    // Carregar ordem personalizada das categorias se existir
    const field = style.field;
    let orderedCategories = [...validCategories];
    
    if (field) {
      const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
      if (savedOrder) {
        try {
          const orderArray = JSON.parse(savedOrder);
          // Reordenar baseado na ordem salva
          orderedCategories = orderArray.map(originalValue => {
            return validCategories.find(cat => {
              if (cat.original_value === originalValue) return true;
              // Para campos numéricos, comparar também como números
              if (typeof cat.original_value === 'number' && typeof originalValue === 'number') {
                return Math.abs(cat.original_value - originalValue) < 1e-10; // Tolerância para precisão numérica
              }
              // Para strings numéricas, converter e comparar
              if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(originalValue))) {
                return Math.abs(parseFloat(cat.original_value) - parseFloat(originalValue)) < 1e-10;
              }
              return false;
            });
          }).filter(Boolean);
          
          // Adicionar categorias que não estão na ordem salva
          validCategories.forEach(cat => {
            const isInOrder = orderArray.some(originalValue => {
              if (cat.original_value === originalValue) return true;
              // Para campos numéricos, comparar também como números
              if (typeof cat.original_value === 'number' && typeof originalValue === 'number') {
                return Math.abs(cat.original_value - originalValue) < 1e-10; // Tolerância para precisão numérica
              }
              // Para strings numéricas, converter e comparar
              if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(originalValue))) {
                return Math.abs(parseFloat(cat.original_value) - parseFloat(originalValue)) < 1e-10;
              }
              return false;
            });
            
            if (!isInOrder) {
              orderedCategories.push(cat);
            }
          });
        } catch (e) {
          console.warn('Erro ao carregar ordem personalizada:', e);
        }
      }
    }
    
    // Aplicar cores e nomes personalizados se disponíveis
    orderedCategories = orderedCategories.map((cat, index) => {
      const savedColor = localStorage.getItem(`category_color_${layerId}_${cat.original_value}`);
      
      // Buscar por todos os índices possíveis para encontrar o nome salvo
      let savedName = null;
      for (let i = 0; i < orderedCategories.length; i++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${cat.original_value}_${i}`);
        if (testName) {
          savedName = testName;
          break;
        }
      }
      
      let updatedCat = { ...cat };
      
      // Preservar cores personalizadas - não sobrescrever se já existe
      if (savedColor && !cat.color) {
        updatedCat.color = savedColor;
      }
      
      if (savedName) {
        updatedCat.category = savedName;
      }
      
      return updatedCat;
    });
    
    legendDiv.innerHTML = `
      <div class="mb-2">
        <h6 class="text-primary mb-2">${legendTitle}</h6>
        <small class="text-muted">${orderedCategories.length} categorias encontradas</small>
      </div>
      ${orderedCategories.map((cat, index) => `
        <div class="d-flex align-items-center gap-3 p-2 border rounded mb-2 bg-light">
          <div class="d-flex align-items-center gap-2">
            <div style="width: 24px; height: 24px; background-color: ${cat.color}; border: 2px solid #333; border-radius: 4px;"></div>
            <span class="fw-bold">${index + 1}.</span>
          </div>
          <div class="flex-grow-1">
            <div class="fw-semibold">${cat.category}</div>
            <small class="text-muted">Cor: ${cat.color}</small>
          </div>
        </div>
      `).join('')}
    `;
    
    console.log('Legenda categorizada renderizada do fallback:', orderedCategories);
  }
  
  // Função para forçar sincronização da legenda categorizada com a interface
  function forceCategorizedLegendSync() {
    console.log('forceCategorizedLegendSync chamada');
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') return;
    
    const field = document.getElementById('field-select').value;
    if (!field) return;
    
    const categoryList = document.getElementById('category-list');
    if (!categoryList || categoryList.children.length === 0) return;
    
    const legendDiv = document.getElementById('preview-legend');
    if (!legendDiv) return;
    
    console.log('Forçando sincronização da legenda categorizada com a interface');
    
    // Sincronizar diretamente com a interface
    const style = computeStyle();
    renderCategorizedPreviewFromInterface(legendDiv, style);
    
    // Atualizar mapa também
    setTimeout(() => {
      try {
        renderMapPreview();
      } catch (error) {
        console.error('Erro ao renderizar mapa na sincronização forçada:', error);
      }
    }, 50);
  }
  
  // Função para forçar sincronização com retry e verificação de interface
  function forceCategorizedLegendSyncWithRetry(maxRetries = 10, delay = 200) {
    console.log(`forceCategorizedLegendSyncWithRetry chamada - maxRetries: ${maxRetries}, delay: ${delay}ms`);
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') {
      console.log('Não é simbologia categorizada, abortando');
      return;
    }
    
    const field = document.getElementById('field-select').value;
    if (!field) {
      console.log('Campo não selecionado, abortando');
      return;
    }
    
    // Verificar se a interface está pronta
    const categoryList = document.getElementById('category-list');
    const legendDiv = document.getElementById('preview-legend');
    
    if (!categoryList) {
      console.log('Interface category-list não encontrada');
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: aguardando interface...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    if (!legendDiv) {
      console.log('Interface preview-legend não encontrada');
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: aguardando interface...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    // Verificar se há categorias na interface
    const categoryItems = categoryList.querySelectorAll('.categorized-class-item');
    if (categoryItems.length === 0) {
      console.log(`Interface encontrada mas sem categorias (${categoryItems.length})`);
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: aguardando categorias...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    console.log(`Interface pronta! Encontradas ${categoryItems.length} categorias`);
    
    // Verificar se as categorias têm dados válidos
    let hasValidData = false;
    categoryItems.forEach((item, index) => {
      const colorInput = item.querySelector('.categorized-class-color');
      const nameInput = item.querySelector('.categorized-class-name');
      
      if (colorInput && nameInput) {
        const color = colorInput.value;
        const name = nameInput.value;
        if (color && color !== '#cccccc' && name) {
          hasValidData = true;
          console.log(`Categoria ${index}: ${name} - ${color}`);
        }
      }
    });
    
    if (!hasValidData) {
      console.log('Interface encontrada mas sem dados válidos');
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: aguardando dados válidos...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    console.log('Interface completamente pronta, executando sincronização');
    
    // Executar sincronização
    try {
      const style = computeStyle();
      renderCategorizedPreviewFromInterface(legendDiv, style);
      
      // Atualizar mapa também
      setTimeout(() => {
        try {
          renderMapPreview();
          console.log('Sincronização completa com sucesso!');
        } catch (error) {
          console.error('Erro ao renderizar mapa na sincronização:', error);
        }
      }, 100);
      
    } catch (error) {
      console.error('Erro durante a sincronização:', error);
      if (maxRetries > 0) {
        console.log(`Tentativa ${11 - maxRetries}: retry após erro...`);
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
    }
  }
  
  // Função para forçar sincronização após carregamento completo da página
  function forceSyncAfterPageLoad() {
    console.log('forceSyncAfterPageLoad chamada');
    
    // Aguardar um pouco mais para garantir que tudo esteja carregado
    setTimeout(() => {
      const styleType = document.getElementById('style-type').value;
      if (styleType === 'categorized') {
        console.log('Simbologia categorizada detectada - forçando sincronização após carregamento');
        
        // IMPORTANTE: Sincronizar tanto a interface quanto a legenda
        forceCategorizedInterfaceSyncWithRetry(15, 300); // Interface primeiro
        forceCategorizedLegendSyncWithRetry(15, 300);   // Legenda depois
      }
    }, 500);
  }
  
  // Função para forçar sincronização da interface "Cores e Nomes das Classes"
  function forceCategorizedInterfaceSyncWithRetry(maxRetries = 15, delay = 300) {
    console.log(`forceCategorizedInterfaceSyncWithRetry chamada - maxRetries: ${maxRetries}, delay: ${delay}ms`);
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') {
      console.log('Não é simbologia categorizada, abortando sincronização da interface');
      return;
    }
    
    const field = document.getElementById('field-select').value;
    if (!field) {
      console.log('Campo não selecionado, abortando sincronização da interface');
      return;
    }
    
    // Verificar se a interface está pronta
    const categoryList = document.getElementById('category-list');
    if (!categoryList) {
      console.log('Interface category-list não encontrada');
      if (maxRetries > 0) {
        console.log(`Tentativa ${16 - maxRetries}: aguardando interface...`);
        setTimeout(() => {
          forceCategorizedInterfaceSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    // Verificar se há categorias na interface
    const categoryItems = categoryList.querySelectorAll('.categorized-class-item');
    if (categoryItems.length === 0) {
      console.log(`Interface encontrada mas sem categorias (${categoryItems.length})`);
      if (maxRetries > 0) {
        console.log(`Tentativa ${16 - maxRetries}: aguardando categorias...`);
        setTimeout(() => {
          forceCategorizedInterfaceSyncWithRetry(maxRetries - 1, delay);
        }, delay);
      }
      return;
    }
    
    console.log(`Interface encontrada com ${categoryItems.length} categorias - verificando dados e ordem...`);
    
    // IMPORTANTE: Primeiro, aplicar ordem personalizada se existir E for válida
    const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
    if (savedOrder && savedOrder !== '[]') {
      try {
        const orderArray = JSON.parse(savedOrder);
        console.log('Verificando ordem personalizada salva:', orderArray);
        
        // IMPORTANTE: Só reordenar se a ordem salva for diferente da ordem atual
        const currentOrder = Array.from(categoryItems).map(item => item.dataset.category);
        const orderChanged = JSON.stringify(currentOrder) !== JSON.stringify(orderArray);
        
        if (orderChanged) {
          console.log('Ordem personalizada diferente da atual - aplicando reordenação');
          console.log('Ordem atual:', currentOrder);
          console.log('Ordem salva:', orderArray);
          
          // Reordenar os elementos da interface baseado na ordem salva
          const reorderedItems = [];
          
          // Primeiro, adicionar itens na ordem salva
          orderArray.forEach(originalValue => {
            const item = Array.from(categoryItems).find(item => item.dataset.category === originalValue);
            if (item) {
              reorderedItems.push(item);
            }
          });
          
          // Depois, adicionar itens que não estão na ordem salva (novas categorias)
          categoryItems.forEach(item => {
            const category = item.dataset.category;
            if (!orderArray.includes(category)) {
              reorderedItems.push(item);
            }
          });
          
          // Aplicar nova ordem na interface
          reorderedItems.forEach((item, newIndex) => {
            // Atualizar atributo data-index
            item.setAttribute('data-index', newIndex);
            
            // Mover elemento para a nova posição
            categoryList.appendChild(item);
          });
          
          console.log(`Interface reordenada: ${reorderedItems.length} categorias na nova ordem`);
        } else {
          console.log('Ordem atual já está correta - não é necessário reordenar');
        }
        
      } catch (e) {
        console.warn('Erro ao aplicar ordem personalizada na interface:', e);
      }
    } else {
      console.log('Nenhuma ordem personalizada encontrada - mantendo ordem original das categorias');
    }
    
    // Agora verificar se as categorias têm dados válidos e sincronizar com localStorage
    let syncNeeded = false;
    let syncCompleted = 0;
    
    // Obter categorias atualizadas após reordenação
    const updatedCategoryItems = categoryList.querySelectorAll('.categorized-class-item');
    
    updatedCategoryItems.forEach((item, index) => {
      const category = item.dataset.category;
      const colorInput = item.querySelector('.categorized-class-color');
      const nameInput = item.querySelector('.categorized-class-name');
      const hexInput = item.querySelector('.categorized-class-hex');
      const colorPreview = item.querySelector('.color-preview');
      
      if (!colorInput || !nameInput) {
        console.log(`Categoria ${index}: inputs não encontrados`);
        return;
      }
      
      // Buscar dados salvos no localStorage
      const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
      let savedName = null;
      
      // Buscar nome salvo por todos os índices possíveis
      for (let i = 0; i < 1000; i++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
        if (testName && testName !== category) {
          savedName = testName;
          break;
        }
      }
      
      // IMPORTANTE: Buscar configurações de linha salvas
      const savedLineStyle = localStorage.getItem(`line_style_${layerId}_${category}`);
      const savedLineSpacing = localStorage.getItem(`line_spacing_${layerId}_${category}`);
      const savedLineWeight = localStorage.getItem(`line_weight_${layerId}_${category}`);
      const savedLineOpacity = localStorage.getItem(`line_opacity_${layerId}_${category}`);
      
      // Verificar se precisa sincronizar
      let needsSync = false;
      
      if (savedColor && colorInput.value !== savedColor) {
        console.log(`Categoria ${index}: cor desincronizada - interface: ${colorInput.value}, localStorage: ${savedColor}`);
        needsSync = true;
      }
      
      if (savedName && nameInput.value !== savedName) {
        console.log(`Categoria ${index}: nome desincronizado - interface: ${nameInput.value}, localStorage: ${savedName}`);
        needsSync = true;
      }
      
      // Verificar se configurações de linha precisam ser sincronizadas
      if (savedLineStyle !== null || savedLineSpacing !== null || savedLineWeight !== null || savedLineOpacity !== null) {
        needsSync = true;
        console.log(`Categoria ${index}: configurações de linha encontradas - estilo: ${savedLineStyle}, espaçamento: ${savedLineSpacing}, espessura: ${savedLineWeight}, opacidade: ${savedLineOpacity}`);
      }
      
      if (needsSync) {
        syncNeeded = true;
        
        // Sincronizar cor
        if (savedColor) {
          colorInput.value = savedColor;
          if (hexInput) hexInput.value = savedColor;
          if (colorPreview) colorPreview.style.backgroundColor = savedColor;
          console.log(`Categoria ${index}: cor sincronizada para ${savedColor}`);
        }
        
        // Sincronizar nome
        if (savedName) {
          nameInput.value = savedName;
          console.log(`Categoria ${index}: nome sincronizado para ${savedName}`);
        }
        
        // IMPORTANTE: Sincronizar configurações de linha
        if (savedLineStyle !== null) {
          const styleSelect = item.querySelector('.line-style-select');
          if (styleSelect) {
            styleSelect.value = savedLineStyle;
            console.log(`Categoria ${index}: estilo da linha sincronizado para ${savedLineStyle}`);
            
            // Mostrar/ocultar controles de espaçamento baseado no estilo
            const spacingControls = item.querySelector(`.line-spacing-controls[data-category="${category}"]`);
            if (spacingControls) {
              if (savedLineStyle === '') {
                spacingControls.classList.add('d-none');
              } else {
                spacingControls.classList.remove('d-none');
              }
            }
          }
        }
        
        if (savedLineSpacing !== null) {
          const spacingSlider = item.querySelector('.line-spacing-slider');
          const spacingValue = item.querySelector('.line-spacing-value');
          if (spacingSlider && spacingValue) {
            spacingSlider.value = savedLineSpacing;
            spacingValue.textContent = savedLineSpacing + 'px';
            console.log(`Categoria ${index}: espaçamento da linha sincronizado para ${savedLineSpacing}`);
          }
        }
        
        if (savedLineWeight !== null) {
          const weightInput = item.querySelector('.line-weight-input');
          if (weightInput) {
            weightInput.value = savedLineWeight;
            console.log(`Categoria ${index}: espessura da linha sincronizada para ${savedLineWeight}`);
          }
        }
        
        if (savedLineOpacity !== null) {
          const opacityInput = item.querySelector('.line-opacity-input');
          if (opacityInput) {
            opacityInput.value = savedLineOpacity;
            console.log(`Categoria ${index}: opacidade da linha sincronizada para ${savedLineOpacity}`);
          }
        }
        
        syncCompleted++;
      }
    });
    
    if (syncNeeded) {
      console.log(`Sincronização da interface concluída: ${syncCompleted} categorias atualizadas`);
      
      // Disparar eventos para garantir que as mudanças sejam aplicadas
      updatedCategoryItems.forEach((item) => {
        const colorInput = item.querySelector('.categorized-class-color');
        const nameInput = item.querySelector('.categorized-class-name');
        const styleSelect = item.querySelector('.line-style-select');
        const spacingSlider = item.querySelector('.line-spacing-slider');
        const weightInput = item.querySelector('.line-weight-input');
        const opacityInput = item.querySelector('.line-opacity-input');
        
        if (colorInput) {
          colorInput.dispatchEvent(new Event('input', { bubbles: true }));
          colorInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        if (nameInput) {
          nameInput.dispatchEvent(new Event('input', { bubbles: true }));
          nameInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        // IMPORTANTE: Disparar eventos para controles de linha
        if (styleSelect) {
          styleSelect.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        if (spacingSlider) {
          spacingSlider.dispatchEvent(new Event('input', { bubbles: true }));
          spacingSlider.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        if (weightInput) {
          weightInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        if (opacityInput) {
          opacityInput.dispatchEvent(new Event('input', { bubbles: true }));
          opacityInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });
      
      // Aguardar um pouco e forçar atualização da legenda
      setTimeout(() => {
        console.log('Forçando atualização da legenda após sincronização da interface');
        forceCategorizedLegendSyncWithRetry(5, 100);
      }, 200);
      
    } else {
      console.log('Interface já está sincronizada com localStorage');
    }
    
    // IMPORTANTE: Reconfigurar drag & drop após reordenação
    if (savedOrder) {
      setTimeout(() => {
        console.log('Reconfigurando drag & drop após reordenação');
        setupDragAndDrop();
        
        // IMPORTANTE: Forçar aplicação da ordem personalizada novamente para garantir
        setTimeout(() => {
          console.log('Forçando aplicação da ordem personalizada novamente para garantir');
          forceApplySavedOrder();
        }, 200);
      }, 100);
    }
  }
  
  // Função para forçar sincronização da interface quando necessário
  function forceInterfaceSyncIfNeeded() {
    console.log('forceInterfaceSyncIfNeeded chamada');
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') return;
    
    const field = document.getElementById('field-select').value;
    if (!field) return;
    
    // Verificar se há dados salvos que precisam ser sincronizados
    const categoryList = document.getElementById('category-list');
    if (!categoryList) return;
    
    const categoryItems = categoryList.querySelectorAll('.categorized-class-item');
    if (categoryItems.length === 0) return;
    
    let needsSync = false;
    
    categoryItems.forEach((item) => {
      const category = item.dataset.category;
      const colorInput = item.querySelector('.categorized-class-color');
      const nameInput = item.querySelector('.categorized-class-name');
      
      if (!colorInput || !nameInput) return;
      
      const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
      let savedName = null;
      
      for (let i = 0; i < 1000; i++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
        if (testName && testName !== category) {
          savedName = testName;
          break;
        }
      }
      
      if ((savedColor && colorInput.value !== savedColor) || 
          (savedName && nameInput.value !== savedName)) {
        needsSync = true;
      }
    });
    
    if (needsSync) {
      console.log('Interface precisa de sincronização - forçando...');
      forceCategorizedInterfaceSyncWithRetry(5, 100);
    }
  }
  
  // Função para forçar aplicação da ordem personalizada
  function forceApplySavedOrder() {
    console.log('forceApplySavedOrder chamada');
    
    const styleType = document.getElementById('style-type').value;
    if (styleType !== 'categorized') return;
    
    const field = document.getElementById('field-select').value;
    if (!field) return;
    
    const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
    if (!savedOrder) {
      console.log('Nenhuma ordem personalizada encontrada para aplicar');
      return;
    }
    
    try {
      const orderArray = JSON.parse(savedOrder);
      console.log('Forçando aplicação da ordem personalizada:', orderArray);
      
      // Buscar dados salvos
      const savedNames = {};
      const savedColors = {};
      
      orderArray.forEach(category => {
        // Buscar nome personalizado
        for (let i = 0; i < 1000; i++) {
          const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
          if (testName && testName !== category) {
            savedNames[category] = testName;
            break;
          }
        }
        
        // Buscar cor personalizada
        const savedColor = localStorage.getItem(`category_color_${layerId}_${category}`);
        if (savedColor) {
          savedColors[category] = savedColor;
        }
      });
      
      // Aplicar ordem personalizada
      applySavedOrder(orderArray, savedNames, savedColors);
      
    } catch (e) {
      console.error('Erro ao forçar aplicação da ordem personalizada:', e);
    }
  }
  
  // Função para monitorar mudanças na interface e forçar sincronização
  function setupInterfaceSyncMonitor() {
    console.log('setupInterfaceSyncMonitor chamada');
    
    // Monitorar mudanças na interface usando MutationObserver
    const categoryList = document.getElementById('category-list');
    if (!categoryList) {
      console.log('Interface category-list não encontrada para monitoramento');
      return;
    }
    
    const observer = new MutationObserver((mutations) => {
      let needsSync = false;
      
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList' || mutation.type === 'attributes') {
          // Verificar se há mudanças que afetam a sincronização
          const target = mutation.target;
          if (target.classList && target.classList.contains('categorized-class-item')) {
            needsSync = true;
          }
        }
      });
      
      if (needsSync) {
        console.log('Mudanças detectadas na interface - verificando sincronização...');
        setTimeout(() => {
          forceInterfaceSyncIfNeeded();
        }, 100);
      }
    });
    
    // Configurar observador
    observer.observe(categoryList, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['value', 'style']
    });
    
    console.log('Monitor de sincronização da interface configurado');
  }
  
  // Função para verificar e corrigir consistência dos dados
  function validateAndFixDataConsistency() {
    const field = document.getElementById('field-select').value;
    if (!field || !layerData || !layerData.features) return;
    
    console.log('Verificando consistência dos dados...');
    
    // Obter todas as categorias do campo e tratar campos numéricos de forma robusta
    const uniqueValues = [...new Set(layerData.features.map(f => {
      const value = f.properties[field];
      // Para campos numéricos, preservar o valor original se possível
      if (typeof value === 'number' || !isNaN(parseFloat(value))) {
        const num = parseFloat(value);
        return isFinite(num) ? num : value;
      }
      return value;
    }))];
    
    // Verificar se há ordem personalizada válida
    const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
    if (savedOrder) {
      try {
        const orderArray = JSON.parse(savedOrder);
        // Verificar se a ordem salva ainda é válida
        const validOrder = orderArray.filter(value => {
          if (uniqueValues.includes(value)) return true;
          // Para campos numéricos, comparar também como números
          return uniqueValues.some(uniqueValue => {
            if (uniqueValue === value) return true;
            // Para campos numéricos, comparar também como números
            if (typeof uniqueValue === 'number' && typeof value === 'number') {
              return Math.abs(uniqueValue - value) < 1e-10; // Tolerância para precisão numérica
            }
            // Para strings numéricas, converter e comparar
            if (!isNaN(parseFloat(uniqueValue)) && !isNaN(parseFloat(value))) {
              return Math.abs(parseFloat(uniqueValue) - parseFloat(value)) < 1e-10;
            }
            return false;
          });
        });
        if (validOrder.length !== orderArray.length) {
          console.log('Ordem personalizada corrigida - removidas categorias inválidas');
          localStorage.setItem(`categorized_order_${layerId}_${field}`, JSON.stringify(validOrder));
        }
      } catch (e) {
        console.warn('Ordem personalizada inválida removida:', e);
        localStorage.removeItem(`categorized_order_${layerId}_${field}`);
      }
    }
    
    // Verificar se há nomes personalizados válidos
    uniqueValues.forEach(category => {
      let hasValidName = false;
      for (let i = 0; i < 1000; i++) {
        const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
        if (testName && testName !== category) {
          hasValidName = true;
          break;
        }
      }
      
      if (!hasValidName) {
        // Limpar nomes inválidos
        for (let i = 0; i < 1000; i++) {
          localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${i}`);
        }
      }
    });
    
    console.log('Consistência dos dados verificada e corrigida');
  }
  
  // Função para limpar nomes personalizados duplicados
  function cleanupDuplicateNames() {
    const field = document.getElementById('field-select').value;
    if (!field) return;
    
    // Obter todas as categorias do campo e tratar campos numéricos de forma robusta
    if (layerData && layerData.features) {
      const uniqueValues = [...new Set(layerData.features.map(f => {
        const value = f.properties[field];
        // Para campos numéricos, preservar o valor original se possível
        if (typeof value === 'number' || !isNaN(parseFloat(value))) {
          const num = parseFloat(value);
          return isFinite(num) ? num : value;
        }
        return value;
      }))];
      
      uniqueValues.forEach(category => {
        let foundName = null;
        let foundIndex = null;
        
        // Encontrar o primeiro nome personalizado válido
        for (let i = 0; i < 1000; i++) {
          const testName = localStorage.getItem(`categorized_class_name_${layerId}_${category}_${i}`);
          if (testName) {
            foundName = testName;
            foundIndex = i;
            break;
          }
        }
        
        // Se encontrou um nome, limpar todos os outros e manter apenas o primeiro
        if (foundName !== null) {
          for (let i = 0; i < 1000; i++) {
            if (i !== foundIndex) {
              localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${i}`);
            }
          }
          console.log(`Nome personalizado limpo para ${category}: mantido índice ${foundIndex}`);
        }
      });
    }
    
    // IMPORTANTE: Não limpar cores personalizadas - elas devem ser preservadas
    console.log('Limpeza de nomes duplicados concluída - cores personalizadas preservadas');
  }
  
  // Função para resetar a legenda categorizada
  function resetCategorizedLegend() {
    const field = document.getElementById('field-select').value;
    if (!field) {
      alert('Selecione um campo primeiro.');
      return;
    }
    
    if (confirm('Tem certeza que deseja resetar a legenda categorizada?\n\nIsso irá remover:\n• Cores personalizadas\n• Nomes personalizados\n• Ordem personalizada\n\nA legenda voltará ao estado inicial.')) {
      // Limpar todas as informações personalizadas
      const categories = Array.from(document.querySelectorAll('.categorized-class-item'));
      categories.forEach(item => {
        const category = item.dataset.category;
        const index = item.dataset.index;
        
        // Remover do localStorage
        localStorage.removeItem(`category_color_${layerId}_${category}`);
        
        // Remover TODOS os nomes personalizados para esta categoria (todos os índices possíveis)
        for (let i = 0; i < 1000; i++) { // Limite alto para garantir que todos sejam removidos
          localStorage.removeItem(`categorized_class_name_${layerId}_${category}_${i}`);
        }
      });
      
      // Remover ordem personalizada
      localStorage.removeItem(`categorized_order_${layerId}_${field}`);
      
      // Recarregar interface com configurações padrão
      loadCategoriesForField(field).then(categories => {
        createCategorizedClassesInterface(categories);
        // Limpar nomes duplicados e atualizar preview e mapa
        cleanupDuplicateNames();
        
        // IMPORTANTE: Forçar sincronização da legenda com a interface após reset (com retry)
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry();
        }, 200);
        
        updatePreviewAndMapSynchronized();
        saveUserConfig();
      });
      
      console.log('Legenda categorizada resetada para o estado inicial');
    }
  }

  // Função para atualizar visualização da paleta selecionada
  function updatePalettePreview() {
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    const colorsContainer = document.getElementById('palette-colors');
    const paletteNameSpan = document.getElementById('palette-name');
    
    console.log('updatePalettePreview chamada com:', { palette, invert });
    
    // Atualizar nome da paleta
    if (paletteNameSpan) {
      paletteNameSpan.textContent = palette;
    }
    
    // Limpar container
    colorsContainer.innerHTML = '';
    
    let colors = [];
    
    // Verificar se é uma paleta personalizada
    const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
    const customPalette = customPalettes.find(p => p.name === palette);
    
    if (customPalette && customPalette.colors) {
      // É uma paleta personalizada
      colors = [...customPalette.colors];
      console.log('Paleta personalizada encontrada:', colors);
      
      // Aplicar inversão se necessário
      if (invert) {
        colors.reverse();
      }
    } else {
      // É uma paleta padrão - usar função brewer
      colors = brewer(palette, 8, invert); // Mostrar 8 cores para preview
      console.log('Paleta padrão gerada:', colors);
    }
    
    console.log('Cores finais para preview:', colors);
    
    // Criar elementos de cor
    colors.forEach(color => {
      const colorDiv = document.createElement('div');
      colorDiv.style.cssText = `
        width: 35px; 
        height: 35px; 
        background-color: ${color}; 
        border: 2px solid #fff; 
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      `;
      
      // Tooltip com valor HEX
      colorDiv.title = `Clique para copiar: ${color}`;
      
      // Efeito hover
      colorDiv.addEventListener('mouseenter', () => {
        colorDiv.style.transform = 'scale(1.15)';
        colorDiv.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
      });
      
      colorDiv.addEventListener('mouseleave', () => {
        colorDiv.style.transform = 'scale(1)';
        colorDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
      });
      
      // Clique para copiar cor
      colorDiv.addEventListener('click', () => {
        navigator.clipboard.writeText(color).then(() => {
          // Feedback visual
          const originalBorder = colorDiv.style.border;
          colorDiv.style.border = '2px solid #28a745';
          colorDiv.style.transform = 'scale(1.2)';
          
          setTimeout(() => {
            colorDiv.style.border = originalBorder;
            colorDiv.style.transform = 'scale(1)';
          }, 500);
          
          // Mostrar toast ou alert
          showToast(`Cor ${color} copiada para a área de transferência!`, 'success');
        }).catch(err => {
          console.error('Erro ao copiar cor:', err);
          showToast('Erro ao copiar cor', 'error');
        });
      });
      
      colorsContainer.appendChild(colorDiv);
    });
  }

  // Função para atualizar cores da paleta visual (mantida para compatibilidade)
  function updatePaletteVisualColors() {
    const palette = document.getElementById('palette-select').value;
    const invert = document.getElementById('palette-invert').checked;
    
    // Atualizar cores na visualização da paleta
    document.querySelectorAll('.palette-item').forEach(paletteItem => {
      const paletteName = paletteItem.dataset.palette;
      if (paletteName === palette) {
        const colors = brewer(paletteName, 5, invert);
        const colorDivs = paletteItem.querySelectorAll('div[style*="background-color"]');
        colors.forEach((color, index) => {
          if (colorDivs[index]) {
            colorDivs[index].style.backgroundColor = color;
          }
        });
      }
    });
  }
  
  // Função para criar interface de classes da simbologia graduada
  function createGraduatedClassesInterface(style) {
    const container = document.getElementById('graduated-classes-list');
    container.innerHTML = '';
    
    if (!style || !style.field || !style.classes) {
      container.innerHTML = '<div class="text-muted">Selecione um campo e número de classes para editar as classes.</div>';
      return;
    }
    
    const palette = style.palette || 'Blues';
    const colors = brewer(palette, style.classes, style.palette_invert);
    
    // Gerar nomes padrão para as classes
    const classNames = [];
    for (let i = 0; i < style.classes; i++) {
      const className = localStorage.getItem(`graduated_class_${layerId}_${style.field}_${i}`) || `Classe ${i + 1}`;
      classNames.push(className);
    }
    
    // Carregar cores personalizadas salvas ou usar cores da paleta
    const customColors = [];
    for (let i = 0; i < style.classes; i++) {
      const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
      customColors.push(savedColor || colors[i]);
    }
    
    customColors.forEach((color, index) => {
      const div = document.createElement('div');
      div.className = 'd-flex align-items-center gap-2 p-2 border rounded';
      div.innerHTML = `
        <div class="d-flex align-items-center gap-2">
          <div class="color-preview" style="width: 30px; height: 30px; background-color: ${color}; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;" data-index="${index}"></div>
          <input type="text" class="form-control form-control-sm graduated-class-name" 
                 value="${classNames[index]}" data-index="${index}" data-field="${style.field}"
                 style="min-width: 120px;" placeholder="Nome da classe">
        </div>
        <div class="d-flex align-items-center gap-2">
          <input type="color" class="form-control form-control-color graduated-class-color" 
                 value="${color}" data-index="${index}" style="width: 40px; height: 30px;" title="Seletor de cor">
          <input type="text" class="form-control form-control-sm graduated-class-hex" 
                 value="${color}" data-index="${index}" style="width: 70px;" placeholder="HEX" title="Código HEX">
          <button type="button" class="btn btn-outline-secondary btn-sm graduated-class-rgb-btn" 
                  data-index="${index}" title="Mostrar/ocultar campos RGB">
            <i class="fas fa-palette"></i> RGB
          </button>
        </div>
        
        <div class="d-flex align-items-center gap-2">
          <div class="text-muted small">
            <span class="class-range" data-index="${index}">Calculando...</span>
          </div>
          <div class="graduated-class-rgb-inputs d-none" data-index="${index}">
            <input type="number" class="form-control form-control-sm" min="0" max="255" 
                   placeholder="R" style="width: 50px;" title="Valor Vermelho (0-255)">
            <input type="number" class="form-control form-control-sm" min="0" max="255" 
                   placeholder="G" style="width: 50px;" title="Valor Verde (0-255)">
            <input type="number" class="form-control form-control-sm" min="0" max="255" 
                   placeholder="B" style="width: 50px;" title="Valor Azul (0-255)">
          </div>
        </div>
        
        <!-- Botão para abrir modal de Propriedades da Linha (apenas quando geom-type = line) -->
        ${document.getElementById('geom-type').value === 'line' ? `
        <div class="d-flex align-items-center gap-2 mt-2">
          <button type="button" class="btn btn-outline-success btn-sm graduated-line-properties-btn" 
                  data-index="${index}" data-field="${style.field}" data-bs-toggle="modal" 
                  data-bs-target="#graduatedLinePropertiesModal" 
                  title="Configurar propriedades da linha para esta classe">
            <i class="fas fa-cog"></i> Propriedades da Linha
          </button>
        </div>
        ` : ''}
        

      `;
      
      container.appendChild(div);
      
      // Event listeners para edição de cores
      const colorPreview = div.querySelector('.color-preview');
      const colorInput = div.querySelector('.graduated-class-color');
      const hexInput = div.querySelector('.graduated-class-hex');
      const rgbBtn = div.querySelector('.graduated-class-rgb-btn');
      const rgbInputs = div.querySelector('.graduated-class-rgb-inputs');
      const rInput = rgbInputs.querySelector('input[placeholder="R"]');
      const gInput = rgbInputs.querySelector('input[placeholder="G"]');
      const bInput = rgbInputs.querySelector('input[placeholder="B"]');
      
      // Event listeners para propriedades de linha (apenas quando geom-type = line)
      if (document.getElementById('geom-type').value === 'line') {
        const opacityInput = div.querySelector('.graduated-line-opacity');
        const styleSelect = div.querySelector('.graduated-line-style');
        const spacingInput = div.querySelector('.graduated-line-spacing');
        const spacingControls = div.querySelector('.graduated-line-spacing-controls');
        
        // Event listener para opacidade
        if (opacityInput) {
          opacityInput.addEventListener('input', function() {
            saveUserConfig();
            renderMapPreview();
          });
        }
        
        // Event listener para estilo da linha
        if (styleSelect) {
          styleSelect.addEventListener('change', function() {
            const selectedStyle = this.value;
            
            // Mostrar/ocultar controles de espaçamento baseado no estilo
            if (spacingControls) {
              if (selectedStyle && selectedStyle !== '') {
                spacingControls.classList.remove('d-none');
              } else {
                spacingControls.classList.add('d-none');
              }
            }
            
            saveUserConfig();
            renderMapPreview();
          });
        }
        
        // Event listener para espaçamento
        if (spacingInput) {
          spacingInput.addEventListener('input', function() {
            const spacingValue = div.querySelector('.graduated-line-spacing-value');
            if (spacingValue) {
              spacingValue.textContent = this.value + 'px';
            }
            saveUserConfig();
            renderMapPreview();
          });
        }
      }
      
      // Converter cor inicial para RGB
      const rgb = hexToRgb(color);
      if (rgb) {
        rInput.value = rgb.r;
        gInput.value = rgb.g;
        bInput.value = rgb.b;
      }
      
      // Event listener para seletor de cor
      colorInput.addEventListener('input', function() {
        const newColor = this.value;
        updateClassColor(index, newColor);
      });
      
      // Event listener para campo HEX
      hexInput.addEventListener('input', function() {
        const newColor = this.value;
        if (isValidHex(newColor)) {
          updateClassColor(index, newColor);
        }
      });
      
      // Event listener para botão RGB
      rgbBtn.addEventListener('click', function() {
        rgbInputs.classList.toggle('d-none');
        this.classList.toggle('btn-secondary');
        this.classList.toggle('btn-outline-secondary');
      });
      
      // Event listeners para campos RGB
      [rInput, gInput, bInput].forEach(input => {
        input.addEventListener('input', function() {
          const r = parseInt(rInput.value) || 0;
          const g = parseInt(gInput.value) || 0;
          const b = parseInt(bInput.value) || 0;
          const newColor = rgbToHex(r, g, b);
          updateClassColor(index, newColor);
        });
      });
      
      // Event listener para edição do nome da classe
      const nameInput = div.querySelector('.graduated-class-name');
      nameInput.addEventListener('input', function() {
        const newName = this.value;
        const index = this.dataset.index;
        const field = this.dataset.field;
        
        // Salvar no localStorage
        localStorage.setItem(`graduated_class_${layerId}_${field}_${index}`, newName);
        
        // Atualizar preview (sem recriar a interface para evitar travamento)
        updateGraduatedClassRanges(style);
        renderMapPreview();
        
        // Forçar atualização da legenda
        setTimeout(() => {
          renderPreview();
        }, 100);
        
        // Salvar configuração e enviar para o banco
        saveUserConfig();
      });
      
      // Limitar a 50 caracteres
      nameInput.setAttribute('maxlength', '50');
      
      // IMPORTANTE: Event listeners para controles de linha (se existirem)
      if (document.getElementById('geom-type').value === 'line') {
        const lineWeightInput = div.querySelector('.graduated-line-weight');
        const lineOpacityInput = div.querySelector('.graduated-line-opacity');
        const lineStyleSelect = div.querySelector('.graduated-line-style');
        const lineSpacingSlider = div.querySelector('.graduated-line-spacing');
        
        if (lineWeightInput) {
          lineWeightInput.addEventListener('change', function() {
            const weight = this.value;
            const field = this.dataset.field;
            const index = this.dataset.index;
            
            // Salvar no localStorage
            localStorage.setItem(`graduated_line_weight_${layerId}_${field}_${index}`, weight);
            
            console.log(`Espessura da linha alterada para classe ${index}:`, weight);
            
            // Atualizar mapa
            renderMapPreview();
            
            // Salvar configuração
            saveUserConfig();
          });
        }
        
        if (lineOpacityInput) {
          lineOpacityInput.addEventListener('input', function() {
            const opacity = this.value;
            const field = this.dataset.field;
            const index = this.dataset.index;
            
            // Salvar no localStorage
            localStorage.setItem(`graduated_line_opacity_${layerId}_${field}_${index}`, opacity);
            
            console.log(`Opacidade da linha alterada para classe ${index}:`, opacity);
            
            // Atualizar mapa
            renderMapPreview();
            
            // Salvar configuração
            saveUserConfig();
          });
        }
        
        if (lineStyleSelect) {
          lineStyleSelect.addEventListener('change', function() {
            const style = this.value;
            const field = this.dataset.field;
            const index = this.dataset.index;
            
            // Salvar no localStorage
            localStorage.setItem(`graduated_line_style_${layerId}_${field}_${index}`, style);
            
            console.log(`Estilo da linha alterado para classe ${index}:`, style);
            
            // Mostrar/ocultar controles de espaçamento baseado na seleção
            const spacingControls = div.querySelector('.graduated-line-spacing-controls');
            if (spacingControls) {
              if (style === '') {
                // Estilo "Contínua" - ocultar controles
                spacingControls.classList.add('d-none');
              } else {
                // Outros estilos - mostrar controles
                spacingControls.classList.remove('d-none');
              }
            }
            
            // Atualizar mapa
            renderMapPreview();
            
            // Salvar configuração
            saveUserConfig();
          });
        }
        
        if (lineSpacingSlider) {
          lineSpacingSlider.addEventListener('input', function() {
            const spacing = this.value;
            const field = this.dataset.field;
            const index = this.dataset.index;
            
            // Atualizar valor exibido
            const valueDisplay = div.querySelector('.graduated-line-spacing-value');
            if (valueDisplay) {
              valueDisplay.textContent = spacing + 'px';
            }
            
            // Salvar no localStorage
            localStorage.setItem(`graduated_line_spacing_${layerId}_${field}_${index}`, spacing);
            
            console.log(`Espaçamento da linha alterado para classe ${index}:`, spacing);
            
            // Atualizar mapa
            renderMapPreview();
            
            // Salvar configuração
            saveUserConfig();
          });
        }
      }
    });
    
    // Atualizar faixas de valores quando possível
    updateGraduatedClassRanges(style);
    
    // Calcular e exibir os breaks das classes após criar a interface
    setTimeout(() => {
      calculateAndDisplayClassBreaks(style);
    }, 100);
  }
  
  // Função para calcular e exibir os breaks das classes graduadas
  function calculateAndDisplayClassBreaks(style) {
    if (!layerData || !style.field) return;
    
    const values = layerData.features
      .map(f => parseFloat(f.properties[style.field]))
      .filter(v => !isNaN(v))
      .sort((a, b) => a - b);
    
    if (values.length === 0) return;
    
    const min = values[0];
    const max = values[values.length - 1];
    const classes = style.classes || 5;
    
    // Gerar breaks baseado no método
    let breaks = [];
    if (style.method === 'equal') {
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    } else if (style.method === 'quantile') {
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'jenks') {
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
    } else if (style.method === 'log') {
      const logMin = Math.log(Math.max(min, 0.1));
      const logMax = Math.log(max);
      const step = (logMax - logMin) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(Math.exp(logMin + (i * step)));
      }
    } else if (style.method === 'manual' && style.breaks) {
      breaks = style.breaks;
    } else {
      // Padrão: equal interval
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
    }
    
    // Salvar breaks no localStorage para preservar entre mudanças de paleta
    localStorage.setItem(`graduated_breaks_${layerId}_${style.field}`, JSON.stringify(breaks));
    
    console.log(`📊 DEBUG calculateAndDisplayClassBreaks:`);
    console.log(`  Método: ${style.method}`);
    console.log(`  Min: ${min}, Max: ${max}`);
    console.log(`  Classes: ${classes}`);
    console.log(`  Breaks calculados:`, breaks);
    
    // Atualizar as faixas de valores na interface
    document.querySelectorAll('.class-range').forEach((rangeSpan, index) => {
      if (index < breaks.length - 1) {
        const start = breaks[index].toFixed(2);
        const end = breaks[index + 1].toFixed(2);
        
        // Formatar números: usar "." como separador de milhar e "," como decimal
        const formatNumber = (num) => {
          const parts = num.split('.');
          if (parts.length === 2) {
            const integerPart = parts[0];
            const decimalPart = parts[1];
            // Adicionar separador de milhar se necessário
            const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
            return `${formattedInteger},${decimalPart}`;
          }
          return num.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
        };
        
        const formattedStart = formatNumber(start);
        const formattedEnd = formatNumber(end);
        rangeSpan.textContent = `${formattedStart} a ${formattedEnd}`;
        
        console.log(`  Classe ${index}: [${formattedStart}, ${formattedEnd})`);
      }
    });
  }

  // Função para atualizar as faixas de valores das classes graduadas
  function updateGraduatedClassRanges(style) {
    if (!layerData || !style.field) return;
    
    // Tentar usar breaks salvos primeiro
    const savedBreaks = localStorage.getItem(`graduated_breaks_${layerId}_${style.field}`);
    if (savedBreaks) {
      try {
        const breaks = JSON.parse(savedBreaks);
        if (breaks && breaks.length > 0) {
          // Atualizar as faixas de valores na interface usando breaks salvos
          document.querySelectorAll('.class-range').forEach((rangeSpan, index) => {
            if (index < breaks.length - 1) {
              const start = breaks[index].toFixed(2);
              const end = breaks[index + 1].toFixed(2);
              
              // Formatar números: usar "." como separador de milhar e "," como decimal
              const formatNumber = (num) => {
                const parts = num.split('.');
                if (parts.length === 2) {
                  const integerPart = parts[0];
                  const decimalPart = parts[1];
                  // Adicionar separador de milhar se necessário
                                   const formattedInteger = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
                 return `${formattedInteger},${decimalPart}`;
                }
                return num.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
              };
              
              const formattedStart = formatNumber(start);
              const formattedEnd = formatNumber(end);
              rangeSpan.textContent = `${formattedStart} a ${formattedEnd}`;
            }
          });
          return; // Usar breaks salvos, não recalcular
        }
      } catch (e) {
        console.log('Erro ao carregar breaks salvos:', e);
      }
    }
    
    // Se não há breaks salvos, calcular novos
    calculateAndDisplayClassBreaks(style);
  }

  // Função para computar o estilo baseado nas seleções
  function computeStyle() {
    const styleType = document.getElementById('style-type').value;
    const geomType = document.getElementById('geom-type').value;
    const field = document.getElementById('field-select').value;
    const palette = document.getElementById('palette-select').value;
    const paletteOpacity = parseFloat(document.getElementById('palette-opacity').value);
    const paletteInvert = document.getElementById('palette-invert').checked;
    
    console.log('computeStyle: Valores coletados:', {
      styleType,
      geomType,
      field,
      palette,
      paletteOpacity,
      paletteInvert
    });
    
    const style = {
      type: styleType,
      geometry_type: geomType,
      field: field,
      palette: palette,
      palette_opacity: paletteOpacity,
      palette_invert: paletteInvert
    };
    
    if (styleType === 'single') {
      style.stroke_color = document.getElementById('stroke-color').value;
      style.fill_color = document.getElementById('fill-color').value;
      style.stroke_weight = parseInt(document.getElementById('stroke-weight').value);
      style.fill_opacity = parseFloat(document.getElementById('fill-opacity').value);
      
      // IMPORTANTE: Para simbologia single, também tratar configurações de borda de polígono
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      }
      
      if (geomType === 'point') {
        style.radius = parseInt(document.getElementById('point-radius').value);
      } else if (geomType === 'line') {
        style.opacity = parseFloat(document.getElementById('line-opacity').value);
        const dash = document.getElementById('line-dash').value;
        if (dash) style.dashArray = dash;
      }
    } else if (styleType === 'categorized') {
      console.log('computeStyle: Processando simbologia categorizada');
      console.log('Simbologia categorizada aceita qualquer tipo de campo (textual, numérico, etc.)');
      
      // Coletar informações da paleta selecionada
      const paletteSelect = document.getElementById('palette-select');
      const paletteInvert = document.getElementById('palette-invert')?.checked || false;
      
      if (paletteSelect) {
        style.palette = paletteSelect.value;
        style.palette_invert = paletteInvert;
        console.log('Paleta selecionada para categorizada:', style.palette, 'Invertida:', style.palette_invert);
      }
      
      // Carregar categorias do campo selecionado e tratar campos numéricos de forma robusta
      if (field && layerData && layerData.features) {
        const uniqueValues = [...new Set(layerData.features.map(f => {
          const value = f.properties[field];
          // Para campos numéricos, preservar o valor original se possível
          if (typeof value === 'number' || !isNaN(parseFloat(value))) {
            const num = parseFloat(value);
            return isFinite(num) ? num : value;
          }
          return value;
        }))];
        
        // Verificar se há ordem personalizada salva
        const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
        let orderedValues = [...uniqueValues];
        
        if (savedOrder) {
          try {
            const orderArray = JSON.parse(savedOrder);
            // Reordenar baseado na ordem salva
            orderedValues = orderArray.filter(value => uniqueValues.includes(value));
            // Adicionar valores que não estão na ordem salva
            uniqueValues.forEach(value => {
              if (!orderArray.includes(value)) {
                orderedValues.push(value);
              }
            });
          } catch (e) {
            console.warn('Erro ao carregar ordem personalizada:', e);
          }
        }
        
        const categories = orderedValues.map((value, index) => {
          // Verificar se há cor personalizada salva
          const savedColor = localStorage.getItem(`category_color_${layerId}_${value}`);
          
          // Verificar se há nome personalizado salvo
          // IMPORTANTE: Buscar por todos os índices possíveis para encontrar o nome salvo
          let savedName = null;
          for (let i = 0; i < orderedValues.length; i++) {
            const testName = localStorage.getItem(`categorized_class_name_${layerId}_${value}_${i}`);
            if (testName) {
              savedName = testName;
              break;
            }
          }
          
          console.log(`computeStyle - Categoria ${index}: value=${value}, savedName=${savedName}, savedColor=${savedColor}`);
          
          // IMPORTANTE: Preservar cores personalizadas e gerar cores da paleta apenas se não houver cor salva
          let color;
          if (savedColor) {
            // Usar cor personalizada salva (não mudar baseado na posição)
            color = savedColor;
            console.log(`computeStyle - Usando cor personalizada para ${value}: ${color}`);
          } else {
            // IMPORTANTE: Para campos numéricos, tentar encontrar cor salva por valor original
            let foundSavedColor = null;
            if (typeof value === 'number' || !isNaN(parseFloat(value))) {
              // Para campos numéricos, buscar cor salva por valor
              foundSavedColor = localStorage.getItem(`category_color_${layerId}_${value}`);
              if (foundSavedColor) {
                color = foundSavedColor;
                console.log(`computeStyle - Usando cor salva por valor para ${value}: ${color}`);
              }
            }
            
            // Se não encontrou cor salva, gerar cor da paleta
            if (!foundSavedColor) {
              const palette = style.palette || 'Set3';
              const invert = style.palette_invert || false;
              
              if (palette === 'custom') {
                // Para paletas personalizadas, usar cores salvas
                const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
                const selectedPalette = customPalettes.find(p => p.name === paletteSelect.value);
                if (selectedPalette && selectedPalette.colors) {
                  // IMPORTANTE: Distribuir cores de forma inteligente (primeira, última e intermediárias)
                  const distributedColors = distributeColorsIntelligently(selectedPalette.colors, orderedValues.length);
                  color = distributedColors[index];
                  console.log(`computeStyle - Cor distribuída para ${value} na posição ${index}: ${color}`);
                } else {
                  color = brewer('Set3', Math.max(orderedValues.length, 12), invert)[originalIndex % 12];
                }
              } else {
                // Para paletas padrão, usar ColorBrewer com distribuição inteligente
                const paletteColors = brewer(palette, Math.max(orderedValues.length, 12), invert);
                const distributedColors = distributeColorsIntelligently(paletteColors, orderedValues.length);
                color = distributedColors[index];
                console.log(`computeStyle - Cor distribuída da paleta padrão para ${value} na posição ${index}: ${color}`);
              }
              console.log(`computeStyle - Gerando nova cor para ${value} na posição ${index}: ${color}`);
            }
          }
          
          const finalCategory = savedName || value;
          console.log(`computeStyle - Categoria final ${index}: ${value} -> ${finalCategory}`);
          
          // Coletar valores dos controles de linha específicos para esta categoria
          let lineWeight = 2; // valor padrão
          let lineOpacity = 1; // valor padrão
          let lineStyle = ''; // valor padrão (linha contínua)
          
                      // Buscar na interface os valores dos controles de linha para esta categoria
            // IMPORTANTE: Usar o valor da categoria, não o índice, para evitar problemas de reordenação
            const categoryItem = document.querySelector(`.categorized-class-item[data-category="${value}"]`);
            if (categoryItem) {
              const weightInput = categoryItem.querySelector('.line-weight-input');
              const opacityInput = categoryItem.querySelector('.line-opacity-input');
              const styleSelect = categoryItem.querySelector('.line-style-select');
              const spacingSlider = categoryItem.querySelector('.line-spacing-slider');
            
            if (weightInput) lineWeight = parseFloat(weightInput.value) || 2;
            if (opacityInput) lineOpacity = parseFloat(opacityInput.value) || 1;
            if (styleSelect) {
              lineStyle = styleSelect.value || '';
              
              // Mostrar/ocultar controle de espaçamento baseado no estilo selecionado
              if (spacingSlider) {
                const spacingControls = categoryItem.querySelector('.line-spacing-controls');
                if (spacingControls) {
                  if (lineStyle && lineStyle !== '') {
                    spacingControls.classList.remove('d-none');
                  } else {
                    spacingControls.classList.add('d-none');
                  }
                }
              }
              
              // Aplicar espaçamento personalizado se houver slider
              if (spacingSlider && lineStyle) {
                const customSpacing = parseFloat(spacingSlider.value) || 10;
                
                // Modificar o estilo baseado no espaçamento personalizado
                if (lineStyle === '5,5') {
                  lineStyle = `${customSpacing},${customSpacing}`;
                } else if (lineStyle === '10,5') {
                  lineStyle = `${customSpacing * 2},${customSpacing}`;
                } else if (lineStyle === '2,2') {
                  lineStyle = `${customSpacing * 0.4},${customSpacing * 0.4}`;
                } else if (lineStyle === '1,1') {
                  lineStyle = `${customSpacing * 0.2},${customSpacing * 0.2}`;
                } else if (lineStyle === '5,2,1,2') {
                  lineStyle = `${customSpacing},${customSpacing * 0.4},${customSpacing * 0.2},${customSpacing * 0.4}`;
                } else if (lineStyle === '10,2,1,2') {
                  lineStyle = `${customSpacing * 2},${customSpacing * 0.4},${customSpacing * 0.2},${customSpacing * 0.4}`;
                } else if (lineStyle === '15,3,3,3') {
                  lineStyle = `${customSpacing * 1.5},${customSpacing * 0.3},${customSpacing * 0.3},${customSpacing * 0.3}`;
                } else if (lineStyle === '20,5,5,5') {
                  lineStyle = `${customSpacing * 2},${customSpacing * 0.5},${customSpacing * 0.5},${customSpacing * 0.5}`;
                }
                
                console.log(`Estilo modificado com espaçamento personalizado para categoria ${value}:`, lineStyle);
              }
            }
          }
          
          return {
            category: finalCategory, // Usar nome personalizado se disponível
            color: color,
            original_value: value,
            line_weight: lineWeight,
            line_opacity: lineOpacity,
            line_style: lineStyle
          };
        });
        
        style.categories = categories;
        console.log('Categorias carregadas para simbologia categorizada:', categories);
      } else {
        style.categories = [];
      }
      
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      } else if (geomType === 'line') {
        // Configurações específicas para linhas categorizadas
        const lineWeightDefault = document.getElementById('line-weight-default');
        const lineOpacityDefault = document.getElementById('line-opacity-default');
        const lineStyleDefault = document.getElementById('line-style-default');
        const lineSpacingDefault = document.getElementById('line-spacing-default');
        const lineCapDefault = document.getElementById('line-cap-default');
        const lineJoinDefault = document.getElementById('line-join-default');
        const lineMiterLimit = document.getElementById('line-miter-limit');
        
        if (lineWeightDefault) {
          style.stroke_weight = parseFloat(lineWeightDefault.value) || 2;
        }
        if (lineOpacityDefault) {
          style.palette_opacity = parseFloat(lineOpacityDefault.value) || 1;
        }
        if (lineStyleDefault && lineStyleDefault.value) {
          if (lineStyleDefault.value === 'custom') {
            const customPattern = document.getElementById('custom-line-pattern')?.value;
            if (customPattern && customPattern.trim()) {
              style.dashArray = customPattern;
            }
          } else {
            style.dashArray = lineStyleDefault.value;
          }
        }
        if (lineSpacingDefault) {
          style.line_spacing = parseFloat(lineSpacingDefault.value) || 10;
        }
        if (lineCapDefault) {
          style.line_cap = lineCapDefault.value || 'round';
        }
        if (lineJoinDefault) {
          style.line_join = lineJoinDefault.value || 'round';
        }
        if (lineMiterLimit) {
          style.line_miter_limit = parseFloat(lineMiterLimit.value) || 4;
        }
        
        console.log('Configurações de linha aplicadas:', {
          stroke_weight: style.stroke_weight,
          palette_opacity: style.palette_opacity,
          dashArray: style.dashArray,
          line_spacing: style.line_spacing,
          line_cap: style.line_cap,
          line_join: style.line_join,
          line_miter_limit: style.line_miter_limit
        });
      }
    } else if (styleType === 'graduated') {
      const classes = parseInt(document.getElementById('classes').value);
      const method = document.getElementById('method').value;
      style.classes = classes;
      
      // Debug: verificar valores coletados
      console.log('Valores coletados para simbologia graduada:', {
        classes: classes,
        method: method,
        field: style.field,
        palette: style.palette
      });
      
      // Mapear valores do dropdown para os valores esperados pela função
      if (method === 'equal') style.method = 'equal';
      else if (method === 'quantiles') style.method = 'quantile';
      else if (method === 'jenks') style.method = 'jenks';
      else if (method === 'log') style.method = 'log';
      else if (method === 'manual') style.method = 'manual';
      else style.method = 'equal'; // Padrão
      
      if (method === 'manual') {
        const breaks = document.getElementById('manual-breaks').value;
        if (breaks) {
          style.breaks = breaks.split(',').map(b => parseFloat(b.trim()));
        }
      }
      
      if (geomType === 'polygon') {
        const borderToggle = document.getElementById('polygon-border-toggle');
        if (borderToggle.checked) {
          style.border_color = document.getElementById('polygon-border-color').value;
          style.border_width = parseInt(document.getElementById('polygon-border-width').value);
        } else {
          style.border_color = null;
          style.border_width = 0;
        }
      }
      
      // Debug: verificar estilo final
      console.log('Estilo graduado final:', style);
    }
    
    return style;
  }

  // Função para renderizar preview da legenda
  function renderPreview() {
    console.log('renderPreview chamada');
    console.log('Chamando computeStyle...');
    const style = computeStyle();
    console.log('Estilo computado:', style);
    const legendDiv = document.getElementById('preview-legend');
    
    if (style.type === 'single') {
      legendDiv.innerHTML = `
        <div class="d-flex align-items-center gap-2 p-2 border rounded">
          <div style="width: 20px; height: 20px; background-color: ${style.fill_color}; border: 2px solid ${style.stroke_color};"></div>
          <span>${style.field || 'Símbolo único'}</span>
        </div>
      `;
    } else if (style.type === 'categorized' && style.categories) {
      // IMPORTANTE: Para simbologia categorizada, sincronizar diretamente com a interface
      renderCategorizedPreviewFromInterface(legendDiv, style);
    } else if (style.type === 'graduated') {
      // Para dados vetoriais graduados, mostrar legenda discreta
      if (style.geometry_type !== 'raster') {
        // Gerar cores da paleta para a legenda discreta
        const palette = style.palette || 'Blues';
        const classes = style.classes || 5;
        const colors = brewer(palette, classes, style.palette_invert);
        
        // Carregar cores personalizadas se disponíveis
        const customColors = [];
        for (let i = 0; i < classes; i++) {
          const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
          customColors.push(savedColor || colors[i]);
        }
        
        // Criar legenda discreta com cada classe individual
        const legendItems = customColors.map((color, index) => {
          // Obter nome personalizado da classe
          const customClassName = localStorage.getItem(`graduated_class_${layerId}_${style.field}_${index}`) || `Classe ${index + 1}`;
          
          // Verificar se deve mostrar legenda composta
          const compositeLegend = document.getElementById('composite-legend-toggle')?.checked;
          
          let legendText = customClassName;
          
          if (compositeLegend) {
            // Quando marcado (ativado): mostrar nome da classe + intervalo
            const classRangeElement = document.querySelector(`.class-range[data-index="${index}"]`);
            if (classRangeElement) {
              const rangeText = classRangeElement.textContent;
              
              // Verificar se deve ocultar valores de intervalo
              const hideIntervals = document.getElementById('toggle-intervals')?.classList.contains('btn-secondary');
              
              if (hideIntervals) {
                legendText = customClassName; // Apenas o nome da classe
              } else {
                legendText = `${customClassName} - ${rangeText}`; // Nome + intervalo
              }
            }
          } else {
            // Quando desmarcado (desativado): mostrar apenas o intervalo
            const classRangeElement = document.querySelector(`.class-range[data-index="${index}"]`);
            if (classRangeElement) {
              const rangeText = classRangeElement.textContent;
              legendText = rangeText; // Apenas o intervalo
            }
          }
          
          // Adicionar informações de tamanho proporcional para pontos
          let sizeInfo = '';
          if (style.geometry_type === 'point') {
            const isProportionalPointSizeEnabled = document.getElementById('proportional-point-size-toggle')?.checked || false;
            if (isProportionalPointSizeEnabled) {
              const minRadius = parseFloat(document.getElementById('min-point-radius')?.value || '4');
              const maxRadius = parseFloat(document.getElementById('max-point-radius')?.value || '12');
              
              // Calcular raio proporcional para esta classe
              const classPercent = (index / (classes - 1)) * 100;
              const proportionalRadius = minRadius + (classPercent / 100) * (maxRadius - minRadius);
              
              sizeInfo = ` (${proportionalRadius.toFixed(1)}px)`;
            }
          }
          
          console.log(`Classe ${index}: ${customClassName}, Legenda: ${legendText}${sizeInfo}`);
          
          // Renderizar símbolo baseado na geometria
          let symbol = '';
          if (style.geometry_type === 'point') {
            const isProportionalPointSizeEnabled = document.getElementById('proportional-point-size-toggle')?.checked || false;
            if (isProportionalPointSizeEnabled) {
              const minRadius = parseFloat(document.getElementById('min-point-radius')?.value || '4');
              const maxRadius = parseFloat(document.getElementById('max-point-radius')?.value || '12');
              const classPercent = (index / (classes - 1)) * 100;
              const proportionalRadius = minRadius + (classPercent / 100) * (maxRadius - minRadius);
              
              symbol = `<div style="width: ${proportionalRadius * 2}px; height: ${proportionalRadius * 2}px; background-color: ${color}; border: 1px solid #ccc; border-radius: 50%;"></div>`;
            } else {
              symbol = `<div style="width: 20px; height: 20px; background-color: ${color}; border: 1px solid #ccc; border-radius: 50%;"></div>`;
            }
          } else if (style.geometry_type === 'line') {
            const isProportionalSizeEnabled = document.getElementById('proportional-size-toggle')?.checked || false;
            if (isProportionalSizeEnabled) {
              const minWeight = parseFloat(document.getElementById('min-line-weight')?.value || '2');
              const maxWeight = parseFloat(document.getElementById('max-line-weight')?.value || '8');
              const classPercent = (index / (classes - 1)) * 100;
              const proportionalWeight = minWeight + (classPercent / 100) * (maxWeight - minWeight);
              
              symbol = `<div style="width: 40px; height: ${proportionalWeight}px; background-color: ${color}; border: 1px solid #ccc;"></div>`;
            } else {
              symbol = `<div style="width: 40px; height: 4px; background-color: ${color}; border: 1px solid #ccc;"></div>`;
            }
          } else {
            symbol = `<div style="width: 20px; height: 20px; background-color: ${color}; border: 1px solid #ccc;"></div>`;
          }
          
          return `
            <div class="d-flex align-items-center gap-2 p-2 border rounded mb-1">
              ${symbol}
              <span>${legendText}${sizeInfo}</span>
            </div>
          `;
        }).join('');
        
        legendDiv.innerHTML = `
          <div class="mb-2">
            <div><strong>${style.field}</strong></div>
            <div class="small text-muted">Método: ${style.method}</div>
            <div class="small text-muted">Paleta: ${palette}</div>
            <div class="small text-muted">${classes} classes</div>
            <div class="small text-muted">Tipo: Vetorial (discreto)</div>
          </div>
          ${legendItems}
        `;
      } else {
        // Para dados raster, manter legenda contínua
        const palette = style.palette || 'Blues';
        const classes = style.classes || 5;
        const colors = brewer(palette, classes, style.palette_invert);
        
        // Criar gradiente visual para a legenda
        const gradientColors = colors.map(color => color).join(', ');
        
        legendDiv.innerHTML = `
          <div class="d-flex align-items-center gap-2 p-2 border rounded">
            <div class="d-flex flex-column">
              <div style="width: 20px; height: 60px; background: linear-gradient(to bottom, ${gradientColors}); border: 1px solid #ccc;"></div>
              <small class="text-muted text-center">${classes} classes</small>
            </div>
            <div class="flex-grow-1">
              <div><strong>${style.field}</strong></div>
              <div class="small text-muted">Método: ${style.method}</div>
              <div class="small text-muted">Paleta: ${palette}</div>
              <div class="small text-muted">Tipo: Raster (contínuo)</div>
            </div>
          </div>
        `;
      }
    }
  }

  // Função para renderizar rótulos no mapa
  function renderLabelsOnMap() {
    if (!layerData || !map) return;
    
    // Remover rótulos existentes
    map.eachLayer(layer => {
      if (layer._labelLayer) {
        map.removeLayer(layer);
      }
    });
    
    const labelsEnabled = document.getElementById('labels-enabled').checked;
    if (!labelsEnabled) return;
    
    const labelField = document.getElementById('label-field-select').value;
    if (!labelField) return;
    
    const labelConfig = {
      font: document.getElementById('label-font').value,
      size: parseInt(document.getElementById('label-size').value),
      color: document.getElementById('label-color').value,
      bold: document.getElementById('label-bold').checked,
      italic: document.getElementById('label-italic').checked,
      bufferColor: document.getElementById('label-buffer-color').value,
      bufferSize: parseInt(document.getElementById('label-buffer-size').value),
      bufferOpacity: parseFloat(document.getElementById('label-buffer-opacity').value),
      offsetX: parseInt(document.getElementById('label-offset-x').value),
      offsetY: parseInt(document.getElementById('label-offset-y').value)
    };
    
    // Criar camada de rótulos
    const labelLayer = L.layerGroup();
    labelLayer._labelLayer = true;
    
    layerData.features.forEach(feature => {
      if (feature.geometry && feature.properties[labelField]) {
        const labelText = feature.properties[labelField].toString();
        
        // Calcular posição do rótulo baseado na geometria
        let labelPosition;
        if (feature.geometry.type === 'Point') {
          labelPosition = feature.geometry.coordinates;
        } else if (feature.geometry.type === 'LineString') {
          // Posição no meio da linha
          const coords = feature.geometry.coordinates;
          const midIndex = Math.floor(coords.length / 2);
          labelPosition = coords[midIndex];
        } else if (feature.geometry.type === 'Polygon') {
          // Centro do polígono
          const coords = feature.geometry.coordinates[0];
          let sumX = 0, sumY = 0;
          coords.forEach(coord => {
            sumX += coord[0];
            sumY += coord[1];
          });
          labelPosition = [sumX / coords.length, sumY / coords.length];
        }
        
        if (labelPosition) {
          // Converter coordenadas para lat/lng
          const latLng = L.latLng(labelPosition[1], labelPosition[0]);
          
          // Criar elemento HTML para o rótulo
          const labelDiv = document.createElement('div');
          labelDiv.innerHTML = labelText;
          labelDiv.style.cssText = `
            font-family: ${labelConfig.font}, sans-serif;
            font-size: ${labelConfig.size}px;
            color: ${labelConfig.color};
            font-weight: ${labelConfig.bold ? 'bold' : 'normal'};
            font-style: ${labelConfig.italic ? 'italic' : 'normal'};
            text-shadow: 
              -1px -1px 0 ${labelConfig.bufferColor},
              -1px 1px 0 ${labelConfig.bufferColor},
              1px -1px 0 ${labelConfig.bufferColor},
              1px 1px 0 ${labelConfig.bufferColor};
            text-shadow: 
              -1px -1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              -1px 1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              1px -1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor},
              1px 1px ${labelConfig.bufferSize}px ${labelConfig.bufferColor};
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
          `;
          
          // Criar marcador de rótulo
          const labelMarker = L.marker(latLng, {
            icon: L.divIcon({
              html: labelDiv,
              className: 'label-icon',
              iconSize: [labelDiv.offsetWidth, labelDiv.offsetHeight],
              iconAnchor: [labelDiv.offsetWidth / 2, labelDiv.offsetHeight / 2]
            })
          });
          
          // Aplicar deslocamento
          if (labelConfig.offsetX !== 0 || labelConfig.offsetY !== 0) {
            labelMarker.setLatLng([
              latLng.lat + (labelConfig.offsetY / 1000),
              latLng.lng + (labelConfig.offsetX / 1000)
            ]);
          }
          
          labelLayer.addLayer(labelMarker);
        }
      }
    });
    
    labelLayer.addTo(map);
  }

  // Função para renderizar preview no mapa (aplicação instantânea)
  function renderMapPreview() {
    console.log('renderMapPreview chamada');
    console.log('🔍 Debug renderMapPreview:', {
      hasCurrentLayer: !!currentLayer,
      hasMap: !!map,
      currentLayer: currentLayer,
      map: map
    });
    
    if (!currentLayer || !map) {
      console.log('renderMapPreview: currentLayer ou map não disponível');
      return;
    }
    
    // Aplicar mudanças INSTANTANEAMENTE sem remover a camada
    const style = computeStyle();
    
    // Aplicar estilo baseado no tipo
    if (style.type === 'single') {
      // IMPORTANTE: Aplicar borda apenas se estiver habilitada para polígonos
      const layerStyle = {
        fillColor: style.fill_color,
        fillOpacity: style.fill_opacity
      };
      
      // Para polígonos, aplicar borda apenas se estiver habilitada
      if (style.geometry_type === 'polygon') {
        if (style.border_color && style.border_width > 0) {
          layerStyle.color = style.border_color;
          layerStyle.weight = style.border_width;
        } else {
          // Se não quiser borda, definir como transparente
          layerStyle.color = 'transparent';
          layerStyle.weight = 0;
        }
      } else {
        // Para pontos e linhas, usar configurações padrão
        layerStyle.color = style.stroke_color;
        layerStyle.weight = style.stroke_weight;
      }
      
      currentLayer.setStyle(layerStyle);
      
      if (style.geometry_type === 'point') {
        currentLayer.eachLayer(layer => {
          if (layer.setRadius) {
            layer.setRadius(style.radius);
          }
        });
      } else if (style.geometry_type === 'line') {
        currentLayer.eachLayer(layer => {
          const lineStyle = {};
          
          if (style.opacity !== undefined) {
            lineStyle.opacity = style.opacity;
          }
          if (style.dashArray) {
            lineStyle.dashArray = style.dashArray;
          }
          if (style.line_cap) {
            lineStyle.lineCap = style.line_cap;
          }
          if (style.line_join) {
            lineStyle.lineJoin = style.line_join;
          }
          if (style.line_miter_limit) {
            lineStyle.lineMiterLimit = style.line_miter_limit;
          }
          
          if (Object.keys(lineStyle).length > 0) {
            layer.setStyle(lineStyle);
          }
        });
      }
    } else if (style.type === 'categorized' && style.categories) {
      // Aplicar estilo categorizado INSTANTANEAMENTE
      console.log('renderMapPreview: Aplicando estilo categorizado:', style);
      console.log('Campo para simbologia:', style.field);
      console.log('Categorias finais para renderização do mapa:', style.categories);
      
      // Usar as categorias já computadas pelo computeStyle
      // As cores já estão corretas e não devem ser alteradas aqui
      
      let layersUpdated = 0;
      currentLayer.eachLayer(layer => {
        if (layer.feature && layer.feature.properties && style.field) {
          const value = layer.feature.properties[style.field];
          // Para campos numéricos, tratar comparação de forma robusta
          const category = style.categories.find(cat => {
            if (cat.original_value === value) return true;
            // Para campos numéricos, comparar também como números
            if (typeof cat.original_value === 'number' && typeof value === 'number') {
              return Math.abs(cat.original_value - value) < 1e-10; // Tolerância para precisão numérica
            }
            // Para strings numéricas, converter e comparar
            if (!isNaN(parseFloat(cat.original_value)) && !isNaN(parseFloat(value))) {
              return Math.abs(parseFloat(cat.original_value) - parseFloat(value)) < 1e-10;
            }
            return false;
          });
          if (category) {
            console.log(`Atualizando layer ${value} com cor ${category.color}`);
            
            // IMPORTANTE: Aplicar estilo baseado no tipo de geometria
            const layerStyle = {};
            
            if (style.geometry_type === 'line') {
              // Para linhas: usar color (cor da linha) e weight (espessura)
              layerStyle.color = category.color;
              layerStyle.weight = category.line_weight || 2;
              layerStyle.opacity = category.line_opacity || 1;
              
              // Aplicar estilo de linha (tracejado, pontilhado, etc.)
              if (category.line_style) {
                layerStyle.dashArray = category.line_style;
              }
              
              // Aplicar configurações avançadas de linha se disponíveis
              if (style.line_cap) {
                layerStyle.lineCap = style.line_cap;
              }
              if (style.line_join) {
                layerStyle.lineJoin = style.line_join;
              }
              if (style.line_miter_limit) {
                layerStyle.lineMiterLimit = style.line_miter_limit;
              }
            } else if (style.geometry_type === 'point') {
              // Para pontos: usar fillColor e color para borda
              layerStyle.fillColor = category.color;
              layerStyle.fillOpacity = style.palette_opacity || 0.6;
              layerStyle.color = style.border_color || '#333';
              layerStyle.weight = style.border_width || 2;
              
              // Aplicar tamanho proporcional se ativado
              const isProportionalPointSizeEnabled = document.getElementById('proportional-point-size-toggle')?.checked || false;
              if (isProportionalPointSizeEnabled) {
                const minRadius = parseFloat(document.getElementById('min-point-radius')?.value || '4');
                const maxRadius = parseFloat(document.getElementById('max-point-radius')?.value || '12');
                
                // Calcular raio proporcional baseado no valor da categoria
                const featureValue = parseFloat(value);
                if (!isNaN(featureValue)) {
                  // Obter valores min/max do campo para calcular proporção
                  const fieldValues = layerData.features
                    .map(f => parseFloat(f.properties[style.field]))
                    .filter(v => !isNaN(v))
                    .sort((a, b) => a - b);
                  
                  if (fieldValues.length > 0) {
                    const min = fieldValues[0];
                    const max = fieldValues[fieldValues.length - 1];
                    const totalRange = max - min;
                    
                    if (totalRange > 0) {
                      const valuePercent = ((featureValue - min) / totalRange) * 100;
                      const proportionalRadius = minRadius + (valuePercent / 100) * (maxRadius - minRadius);
                      
                      layerStyle.radius = proportionalRadius;
                      console.log(`🎯 Ponto categorizado com raio proporcional: ${proportionalRadius.toFixed(1)}px (${valuePercent.toFixed(1)}%)`);
                    }
                  }
                }
              } else {
                // Usar raio padrão se não estiver ativado
                const pointRadiusDefault = document.getElementById('point-radius-default')?.value;
                if (pointRadiusDefault) {
                  layerStyle.radius = parseFloat(pointRadiusDefault);
                } else {
                  layerStyle.radius = 6; // Raio padrão
                }
              }
              
              // Aplicar configurações específicas de ponto se disponíveis
              const pointOpacityDefault = document.getElementById('point-opacity-default')?.value;
              const pointBorderWidthDefault = document.getElementById('point-border-width-default')?.value;
              const pointBorderColorDefault = document.getElementById('point-border-color-default')?.value;
              
              if (pointOpacityDefault) {
                layerStyle.fillOpacity = parseFloat(pointOpacityDefault);
              }
              if (pointBorderWidthDefault) {
                layerStyle.weight = parseFloat(pointBorderWidthDefault);
              }
              if (pointBorderColorDefault) {
                layerStyle.color = pointBorderColorDefault;
              }
            } else {
              // Para polígonos: usar fillColor e aplicar borda se habilitada
              layerStyle.fillColor = category.color;
              layerStyle.fillOpacity = style.palette_opacity || 0.6;
              
              // Aplicar configurações de borda apenas se estiver habilitada
              if (style.border_color && style.border_width > 0) {
                layerStyle.color = style.border_color;
                layerStyle.weight = style.border_width;
              } else {
                // Se não quiser borda, definir como transparente
                layerStyle.color = 'transparent';
                layerStyle.weight = 0;
              }
            }
            
            layer.setStyle(layerStyle);
            layersUpdated++;
          } else {
            console.log(`Categoria não encontrada para valor: ${value}`);
          }
        }
      });
      
      console.log(`Total de layers atualizados: ${layersUpdated}`);
    } else if (style.type === 'graduated') {
      // Aplicar estilo graduado
      console.log('renderMapPreview: Aplicando estilo graduado:', style);
      console.log('Tipo de geometria detectado:', style.geometry_type);
      console.log('Camada atual:', currentLayer);
      
      if (style.field && style.classes && style.method) {
        console.log('Dados válidos para estilo graduado - chamando applyGraduatedStyle');
        console.log('Campo:', style.field, 'Classes:', style.classes, 'Método:', style.method);
        applyGraduatedStyle(currentLayer, style);
        
        // Aplicar tamanho proporcional para pontos se ativado
        if (style.geometry_type === 'point') {
          const isProportionalPointSizeEnabled = document.getElementById('proportional-point-size-toggle')?.checked || false;
          if (isProportionalPointSizeEnabled) {
            console.log('🎯 Aplicando tamanho proporcional aos pontos graduados...');
            
            // Obter valores do campo para calcular proporções
            const values = layerData.features
              .map(f => parseFloat(f.properties[style.field]))
              .filter(v => !isNaN(v))
              .sort((a, b) => a - b);
            
            if (values.length > 0) {
              const min = values[0];
              const max = values[values.length - 1];
              const totalRange = max - min;
              
              // Aplicar raio proporcional a cada feature
              currentLayer.eachLayer(featureLayer => {
                if (featureLayer.feature && featureLayer.feature.properties) {
                  const featureValue = parseFloat(featureLayer.feature.properties[style.field]);
                  if (!isNaN(featureValue)) {
                    // Calcular percentual do valor em relação ao range total
                    const valuePercent = totalRange > 0 ? ((featureValue - min) / totalRange) * 100 : 0;
                    
                    // Calcular raio proporcional
                    const minRadius = parseFloat(document.getElementById('min-point-radius')?.value || 4);
                    const maxRadius = parseFloat(document.getElementById('max-point-radius')?.value || 12);
                    const proportionalRadius = minRadius + (valuePercent / 100) * (maxRadius - minRadius);
                    
                    // Aplicar raio proporcional
                    const currentStyle = featureLayer.options || {};
                    const newStyle = {
                      ...currentStyle,
                      radius: proportionalRadius
                    };
                    
                    featureLayer.setStyle(newStyle);
                    
                    console.log(`📍 Feature ${featureLayer.feature.id}: valor=${featureValue}, percentual=${valuePercent.toFixed(1)}%, raio=${proportionalRadius.toFixed(1)}px`);
                  }
                }
              });
              
              console.log('✅ Tamanho proporcional dos pontos graduados aplicado com sucesso');
            }
          }
        }
      } else {
        console.log('Dados insuficientes para estilo graduado:', {
          field: style.field,
          classes: style.classes,
          method: style.method,
          geometry_type: style.geometry_type
        });
      }
    }
    
    // Adicionar camada ao mapa se não estiver presente
    if (!map.hasLayer(currentLayer)) {
      console.log('renderMapPreview: Adicionando camada ao mapa');
      currentLayer.addTo(map);
    }
    
    // Renderizar rótulos se habilitados
    renderLabelsOnMap();
    
    // Forçar atualização completa do mapa
    forceMapUpdate();
    
    // Atualizar legenda após renderizar o mapa
    setTimeout(() => {
      renderPreview();
    }, 100);
    
    console.log('renderMapPreview concluída - mudanças aplicadas instantaneamente');
  }

  // Função para atualizar preview
  function refreshPreview() {
    console.log('refreshPreview chamada');
    
    // IMPORTANTE: Para simbologia categorizada, sincronizar diretamente com a interface
    const currentStyleType = document.getElementById('style-type').value;
    if (currentStyleType === 'categorized') {
      console.log('Simbologia categorizada detectada em refreshPreview - sincronizando com interface');
      
      const field = document.getElementById('field-select').value;
      if (field) {
        const categoryList = document.getElementById('category-list');
        if (categoryList && categoryList.children.length > 0) {
          // Atualizar preview diretamente da interface
          const legendDiv = document.getElementById('preview-legend');
          if (legendDiv) {
            const style = computeStyle();
            renderCategorizedPreviewFromInterface(legendDiv, style);
          }
          
          // Atualizar mapa
          renderMapPreview();
          return; // Sair da função para simbologia categorizada
        }
      }
    }
    
    // Para outros tipos de simbologia, usar o método padrão
    console.log('Chamando renderPreview (método padrão)...');
    renderPreview();
    console.log('Chamando renderMapPreview...');
    renderMapPreview(); // Isso agora inclui renderização de rótulos
    updatePalettePreview(); // Atualizar visualização da paleta
    updatePaletteVisualColors();
    
    // Atualizar interface de classes graduadas se aplicável (apenas se não existir)
    const styleType = document.getElementById('style-type').value;
    if (styleType === 'graduated') {
      const style = computeStyle();
      const existingInterface = document.getElementById('graduated-classes-list');
      if (!existingInterface.children.length) {
        createGraduatedClassesInterface(style);
      } else {
        // Apenas atualizar as faixas de valores sem recriar a interface
        updateGraduatedClassRanges(style);
      }
      
          // Atualizar tamanho proporcional dos pontos se aplicável
    const geomType = document.getElementById('geom-type')?.value;
    if (geomType === 'point') {
      const isProportionalPointSizeEnabled = document.getElementById('proportional-point-size-toggle')?.checked || false;
      if (isProportionalPointSizeEnabled) {
        console.log('🔄 Atualizando tamanho proporcional dos pontos em refreshPreview...');
        
        // Forçar atualização completa do mapa
        setTimeout(() => {
          forceMapUpdate();
        }, 100);
      }
    }
    
    // Forçar atualização do mapa para todas as mudanças
    setTimeout(() => {
      forceMapUpdate();
    }, 200);
    }
  }
  
  // Função para gerar cores da paleta para simbologia categorizada
  function generatePaletteColors(paletteName, numCategories, invert = false) {
    console.log('generatePaletteColors chamada:', { paletteName, numCategories, invert });
    
    // Se for uma paleta personalizada, retornar as cores salvas
    if (paletteName === 'custom') {
      const customPalettes = JSON.parse(localStorage.getItem('custom_palettes') || '[]');
      const selectedPalette = customPalettes.find(p => p.name === document.getElementById('palette-select').value);
      if (selectedPalette && selectedPalette.colors) {
        return selectedPalette.colors.slice(0, numCategories);
      }
    }
    
    // Para paletas padrão, usar a biblioteca ColorBrewer
    try {
      let colors = [];
      
      // Determinar o tipo de paleta baseado no nome
      if (['Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'BuGn', 'BuPu', 'GnBu', 'OrRd', 'PuBu', 'PuRd', 'RdPu', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd'].includes(paletteName)) {
        // Paletas sequenciais
        colors = brewer(paletteName, Math.min(numCategories, 9), invert);
      } else if (['RdBu', 'RdYlBu', 'RdYlGn', 'Spectral', 'PuOr', 'BrBG', 'PiYG', 'PRGn', 'RdBu', 'RdGy', 'Spectral'].includes(paletteName)) {
        // Paletas divergentes
        colors = brewer(paletteName, Math.min(numCategories, 11), invert);
      } else if (['Set1', 'Set2', 'Set3', 'Paired', 'Accent', 'Dark2', 'Pastel1', 'Pastel2'].includes(paletteName)) {
        // Paletas qualitativas (ideais para categorias)
        colors = brewer(paletteName, Math.min(numCategories, 12), invert);
      } else {
        // Paleta padrão se não reconhecida
        colors = brewer('Set3', Math.min(numCategories, 12), invert);
      }
      
      // Se precisar de mais cores que a paleta fornece, repetir ou gerar variações
      if (colors.length < numCategories) {
        const baseColors = [...colors];
        while (colors.length < numCategories) {
          colors.push(...baseColors);
        }
        colors = colors.slice(0, numCategories);
      }
      
      console.log('Cores geradas:', colors);
      return colors;
      
    } catch (error) {
      console.error('Erro ao gerar cores da paleta:', error);
      // Fallback: gerar cores aleatórias
      const fallbackColors = [];
      for (let i = 0; i < numCategories; i++) {
        fallbackColors.push(`hsl(${(i * 360) / numCategories}, 70%, 60%)`);
      }
      return fallbackColors;
    }
  }

  // Função para carregar dados da camada
  async function loadLayerData() {
    try {
      console.log('Carregando dados da camada...');
      
      // Usar a URL correta para carregar os dados da camada
      // Primeiro, vamos tentar obter o slug da empresa do usuário logado
      let companySlug = 'amplo'; // Padrão
      
      // Tentar obter do contexto da página ou do usuário
      try {
        // Verificar se há um elemento com o slug da empresa
        const companyElement = document.querySelector('#company-data');
        if (companyElement) {
          companySlug = companyElement.dataset.companySlug;
          console.log('Slug da empresa obtido:', companySlug);
        }
      } catch (e) {
        console.log('Usando slug padrão da empresa:', companySlug);
      }
      
      const url = `/portal/${companySlug}/api/camada_data/${layerId}`;
      console.log('URL da API:', url);
      
      const response = await fetch(url);
      console.log('Resposta da API:', response.status, response.statusText);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      layerData = await response.json();
      console.log('✅ Dados da camada carregados:', layerData);
      
      // Sincronizar currentLayerData com layerData
      currentLayerData = layerData;
      console.log('🔄 currentLayerData sincronizado com layerData');
      
      if (map && layerData.features && layerData.features.length > 0) {
        console.log('Camada tem', layerData.features.length, 'features');
        
        // Remover camada anterior se existir
        if (currentLayer) {
          map.removeLayer(currentLayer);
          console.log('Camada anterior removida');
        }
        
        // Criar nova camada GeoJSON
        currentLayer = L.geoJSON(layerData, {
          style: function(feature) {
            // IMPORTANTE: Para pontos, sempre usar estilo de círculo, nunca pins
            if (feature.geometry.type === 'Point') {
              return {
                color: '#333333',
                weight: 1,
                fillColor: '#38bdf8',
                fillOpacity: 0.8,
                radius: 6,
                renderer: L.canvas.tileCanvas
              };
            } else if (feature.geometry.type === 'LineString') {
              return {
                color: '#333333',
                weight: 2,
                fillColor: '#38bdf8',
                fillOpacity: 0.6
              };
            } else {
              // Para polígonos
              return {
                color: '#333333',
                weight: 2,
                fillColor: '#38bdf8',
                fillOpacity: 0.6
              };
            }
          },
          onEachFeature: function(feature, layer) {
            // IMPORTANTE: Para pontos, garantir que sejam renderizados como círculos
            if (feature.geometry.type === 'Point') {
              // Remover qualquer ícone personalizado
              if (layer.setIcon) {
                layer.setIcon(null);
              }
              
              // Garantir que o estilo seja aplicado corretamente
              const pointStyle = {
                color: '#333333',
                weight: 1,
                fillColor: '#38bdf8',
                fillOpacity: 0.8,
                radius: 6,
                renderer: L.canvas.tileCanvas
              };
              
              layer.setStyle(pointStyle);
              console.log('🎯 Ponto configurado como círculo:', pointStyle);
            }
            
            layer.bindPopup(`
              <strong>${feature.properties[Object.keys(feature.properties)[0]] || 'Sem nome'}</strong><br>
              ${Object.entries(feature.properties).map(([key, value]) => `${key}: ${value}`).join('<br>')}
            `);
          }
        });
        
        console.log('🔍 Debug camada criada:', {
          currentLayer: currentLayer,
          features: currentLayer.getLayers ? currentLayer.getLayers().length : 'N/A',
          bounds: currentLayer.getBounds ? currentLayer.getBounds() : 'N/A'
        });
        
        // Adicionar ao mapa
        currentLayer.addTo(map);
        console.log('Nova camada adicionada ao mapa');
        
        // Ajustar visualização
        if (currentLayer.getBounds) {
          map.fitBounds(currentLayer.getBounds());
          console.log('Mapa ajustado aos limites da camada');
        }
        
        // Detectar e preselecionar tipo de geometria
        const detectedType = detectGeometryType(layerData);
        document.getElementById('geom-type').value = detectedType;
        console.log('Tipo de geometria detectado:', detectedType);
        
        // IMPORTANTE: NÃO aplicar visibilidade aqui para evitar mostrar method-info brevemente
        // applyVisibility(); // REMOVIDO - não deve ser chamado aqui
        
        // Restaurar configurações salvas do usuário
        const configRestored = loadUserConfig();
        
        // IMPORTANTE: Aplicar visibilidade APENAS após restaurar configurações
        // para garantir que o method-info só apareça se for simbologia graduada
        if (configRestored) {
          applyVisibility();
        } else {
          // Se não há configurações salvas, aplicar visibilidade padrão
          applyVisibility();
        }
        
        // Se tiver campo selecionado e for categorizada, carregar categorias
        const field = document.getElementById('field-select').value;
        const styleType = document.getElementById('style-type').value;
        if (field && styleType === 'categorized') {
          loadCategoriesForField(field).then(categories => {
            // Validar e corrigir consistência dos dados
            validateAndFixDataConsistency();
            
            // Verificar se deve aplicar tamanho proporcional após carregar dados
            setTimeout(() => {
              const toggle = document.getElementById('proportional-size-toggle');
              if (toggle && toggle.checked) {
                console.log('🚀 Aplicando tamanho proporcional após carregar dados...');
                applyProportionalSizeToMap();
              }
            }, 500);
            createCategorizedClassesInterface(categories);
            // Limpar nomes duplicados após carregamento
            cleanupDuplicateNames();
            
            // IMPORTANTE: Forçar sincronização da legenda com a interface (com retry)
            setTimeout(() => {
              forceCategorizedLegendSyncWithRetry();
            }, 300);
            
            refreshPreview();
            
            // IMPORTANTE: Forçar sincronização após carregamento completo
            forceSyncAfterPageLoad();
          });
        }
        
        refreshPreview();
        
        // IMPORTANTE: Forçar sincronização após carregamento geral da página
        setTimeout(() => {
          forceSyncAfterPageLoad();
        }, 1000);
        
        console.log('Dados da camada carregados com sucesso');
      } else {
        console.warn('Dados da camada vazios ou mapa não inicializado');
        if (!map) {
          console.error('Mapa não está inicializado!');
        }
        if (!layerData.features || layerData.features.length === 0) {
          console.error('Camada não tem features!');
        }
      }
    } catch (error) {
      console.error('Erro ao carregar dados da camada:', error);
      
      // Mostrar erro para o usuário
      const errorDiv = document.createElement('div');
      errorDiv.className = 'alert alert-danger alert-dismissible fade show';
      errorDiv.innerHTML = `
        <i class="fas fa-exclamation-triangle"></i>
        <strong>Erro ao carregar dados da camada:</strong> ${error.message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
      `;
      
      const container = document.querySelector('.container-fluid');
      if (container) {
        container.insertBefore(errorDiv, container.firstChild);
      }
    }
  }

  // Inicialização da página
  document.addEventListener('DOMContentLoaded', function() {
    // Carregar campos e dados
    initializePage();
    
    // IMPORTANTE: NÃO mostrar informações padrão automaticamente
    // O method-info só deve aparecer quando "Graduada" estiver selecionada
    // showDefaultMethodInfo(); // REMOVIDO - não deve ser chamado automaticamente
    
    // IMPORTANTE: Forçar sincronização após carregamento completo da página
    window.addEventListener('load', function() {
      console.log('Página completamente carregada - forçando sincronização');
      
      // IMPORTANTE: Para simbologia categorizada, verificar se há dados personalizados antes de sincronizar
      const styleType = document.getElementById('style-type').value;
      const field = document.getElementById('field-select').value;
      
      if (styleType === 'categorized' && field) {
        console.log('Simbologia categorizada detectada - verificando dados personalizados antes de sincronizar');
        
        // Verificar se há ordem personalizada salva
        const savedOrder = localStorage.getItem(`categorized_order_${layerId}_${field}`);
        const hasCustomData = savedOrder && savedOrder !== '[]';
        
        if (hasCustomData) {
          console.log('Dados personalizados encontrados - aplicando sincronização completa');
          setTimeout(() => {
            forceSyncAfterPageLoad();
            
            // IMPORTANTE: Verificar se a interface precisa de sincronização adicional
            setTimeout(() => {
              forceInterfaceSyncIfNeeded();
            }, 2000);
            
            // IMPORTANTE: Forçar aplicação da ordem personalizada após carregamento completo
            setTimeout(() => {
              forceApplySavedOrder();
            }, 2500);
          }, 1500);
        } else {
          console.log('Nenhum dado personalizado encontrado - mantendo ordem original das categorias');
          // Para campos sem dados personalizados, apenas sincronizar cores e nomes, sem reordenar
          setTimeout(() => {
            forceSyncAfterPageLoad();
          }, 1500);
        }
      } else {
        // Para outros tipos de simbologia, usar sincronização padrão
        setTimeout(() => {
          forceSyncAfterPageLoad();
          
          // IMPORTANTE: Verificar se a interface precisa de sincronização adicional
          setTimeout(() => {
            forceInterfaceSyncIfNeeded();
          }, 2000);
          
          // IMPORTANTE: Forçar aplicação da ordem personalizada após carregamento completo
          setTimeout(() => {
            forceApplySavedOrder();
          }, 2500);
        }, 1500);
      }
    });
    
    // Event listeners para mudanças
    

    
    document.getElementById('style-type').addEventListener('change', function() {
      const styleType = this.value;
      const fieldSelect = document.getElementById('field-select');
      const field = fieldSelect.value;
      
      applyVisibility();
      
      // Filtrar paletas baseado no tipo de simbologia
      filterPalettesForStyleType(styleType);
      
      // Se mudou para simbologia graduada, verificar se o campo é numérico
      if (styleType === 'graduated') {
        if (field && !isNumericField(field)) {
          showNumericFieldWarning(field);
          // Voltar para o tipo anterior ou padrão
          this.value = 'single';
          applyVisibility();
          return;
        }
        
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      } else if (styleType === 'categorized') {
        // Para simbologia categorizada, aceitar qualquer tipo de campo
        // e criar interface de categorias se houver campo selecionado
        if (field) {
          console.log(`Mudança para simbologia categorizada - aceitando campo: ${field}`);
          console.log('Simbologia categorizada funciona com qualquer tipo de campo (textual, numérico, etc.)');
          
          loadCategoriesForField(field).then(categories => {
            console.log(`Categorias carregadas para campo ${field}:`, categories);
            createCategorizedClassesInterface(categories);
            refreshPreview();
          });
        }
      }
      
      // Controlar visibilidade do modal method-info baseado no tipo de simbologia
      const methodInfoContainer = document.getElementById('method-info');
      if (methodInfoContainer) {
        if (styleType === 'categorized') {
          // Ocultar modal method-info para simbologia categorizada
          methodInfoContainer.classList.add('d-none');
        } else if (styleType === 'graduated') {
          // Mostrar modal method-info para simbologia graduada
          methodInfoContainer.classList.remove('d-none');
          showMethodInfo();
        } else {
          // Para outros tipos (single), ocultar modal method-info
          methodInfoContainer.classList.add('d-none');
        }
      }
      
      refreshPreview();
      saveUserConfig(); // Salvar configuração automaticamente
    });
    document.getElementById('geom-type').addEventListener('change', function() {
      applyVisibility();
      refreshPreview();
      saveUserConfig(); // Salvar configuração automaticamente
    });
    document.getElementById('method').addEventListener('change', function() {
      applyVisibility();
      
      // Atualizar informações do método apenas se for simbologia graduada
      const styleType = document.getElementById('style-type').value;
      if (styleType === 'graduated') {
        showMethodInfo();
      }
      
      saveUserConfig(); // Salvar configuração automaticamente
    });
    
    // Event listener para seleção de campo
    document.getElementById('field-select').addEventListener('change', async function() {
      const field = this.value;
      const styleType = document.getElementById('style-type').value;
      
      if (field && styleType === 'categorized') {
        console.log(`Campo selecionado para simbologia categorizada: ${field}`);
        console.log('Aceitando qualquer tipo de campo (textual, numérico, etc.)');
        
        const categories = await loadCategoriesForField(field);
        console.log(`Categorias carregadas: ${categories.length}`, categories);
        
        // Validar e corrigir consistência dos dados
        validateAndFixDataConsistency();
        createCategorizedClassesInterface(categories);
        // Limpar nomes duplicados após mudança de campo
        cleanupDuplicateNames();
        
        // IMPORTANTE: Forçar sincronização da legenda com a interface (com retry)
        setTimeout(() => {
          forceCategorizedLegendSyncWithRetry();
        }, 300);
        
        refreshPreview();
      } else if (field && styleType === 'graduated') {
        // Verificar se o campo é numérico para simbologia graduada
        if (!isNumericField(field)) {
          showNumericFieldWarning(field);
          // Limpar a seleção do campo
          this.value = '';
          return;
        }
        
        // Para simbologia graduada, atualizar interface de classes
        const style = computeStyle();
        createGraduatedClassesInterface(style);
        refreshPreview();
      }
      saveUserConfig(); // Salvar configuração automaticamente
    });
    
    document.getElementById('palette-select').addEventListener('change', function() {
      // Limpar cores personalizadas antes de aplicar nova paleta
      const field = document.getElementById('field-select').value;
      clearCustomColors(field);
      
      updatePalettePreview();
      
      const styleType = document.getElementById('style-type').value;
      
      // Se for simbologia graduada, apenas atualizar cores sem recriar interface
      if (styleType === 'graduated') {
        // Apenas atualizar as cores das classes existentes, preservando os valores
        updateGraduatedClassColors();
      } else if (styleType === 'categorized') {
        // Para simbologia categorizada, atualizar cores das categorias automaticamente
        console.log('Atualizando cores para simbologia categorizada');
        // Atualizar interface com novas cores
        updateCategorizedClassColors();
      }
      
      refreshPreview();
      saveUserConfig();
    });
    
    document.getElementById('palette-opacity').addEventListener('input', function() {
      // Atualizar valor exibido
      document.getElementById('opacity-value').textContent = this.value;
      
      refreshPreview();
      saveUserConfig();
    });
    
    document.getElementById('palette-invert').addEventListener('change', function() {
      // Limpar cores personalizadas antes de aplicar nova paleta
      const field = document.getElementById('field-select').value;
      clearCustomColors(field);
      
      updatePalettePreview();
      
      const styleType = document.getElementById('style-type').value;
      
      // Se for simbologia graduada, apenas atualizar cores sem recriar interface
      if (styleType === 'graduated') {
        // Apenas atualizar as cores das classes existentes, preservando os valores
        updateGraduatedClassColors();
      } else if (styleType === 'categorized') {
        // Para simbologia categorizada, atualizar cores das categorias automaticamente
        console.log('Atualizando cores para simbologia categorizada (invertida)');
        // Atualizar interface com novas cores
        updateCategorizedClassColors();
      }
      
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listener para legenda composta
    document.getElementById('composite-legend-toggle').addEventListener('change', function() {
      refreshPreview();
      saveUserConfig();
      
      // Atualizar visibilidade do botão para ocultar valores de intervalo
      const blockHideIntervals = document.getElementById('block-hide-intervals');
      if (blockHideIntervals) {
        blockHideIntervals.classList.toggle('d-none', !this.checked);
      }
    });
    
    // Event listener para ocultar/mostrar valores de intervalo
    document.getElementById('toggle-intervals').addEventListener('click', function() {
      // Alternar estado do botão
      this.classList.toggle('btn-secondary');
      this.classList.toggle('btn-outline-secondary');
      
      // Atualizar texto e ícone do botão
      if (this.classList.contains('btn-secondary')) {
        this.innerHTML = '<i class="fas fa-eye"></i> Mostrar Valores de Intervalo';
      } else {
        this.innerHTML = '<i class="fas fa-eye-slash"></i> Ocultar Valores de Intervalo';
      }
      
      // Atualizar preview da legenda
      refreshPreview();
      
      // Salvar configuração
      saveUserConfig();
    });

    // Event listeners para o select customizado de paletas
    document.getElementById('palette-select-header').addEventListener('click', function() {
      const dropdown = document.getElementById('palette-select-dropdown');
      const icon = this.querySelector('i');
      
      if (dropdown.classList.contains('d-none')) {
        dropdown.classList.remove('d-none');
        icon.classList.remove('fa-chevron-down');
        icon.classList.add('fa-chevron-up');
      } else {
        dropdown.classList.add('d-none');
        icon.classList.remove('fa-chevron-up');
        icon.classList.add('fa-chevron-down');
      }
    });

    // Event listeners para as opções de paleta
    document.addEventListener('click', function(e) {
      if (e.target.closest('.palette-option')) {
        const option = e.target.closest('.palette-option');
        const value = option.dataset.value;
        const text = option.querySelector('span').textContent;
        
        console.log('Paleta selecionada:', value, text);
        
        // Atualizar o header
        document.getElementById('palette-select-text').textContent = text;
        document.getElementById('palette-select').value = value;
        
        // Fechar dropdown
        document.getElementById('palette-select-dropdown').classList.add('d-none');
        document.querySelector('#palette-select-header i').classList.remove('fa-chevron-up');
        document.querySelector('#palette-select-header i').classList.add('fa-chevron-down');
        
        // Atualizar preview da paleta imediatamente
        console.log('Atualizando preview da paleta...');
        updatePalettePreview();
        
        // Disparar evento de mudança após a atualização visual
        setTimeout(() => {
          console.log('Disparando evento change...');
          const event = new Event('change');
          document.getElementById('palette-select').dispatchEvent(event);
        }, 50);
      }
    });

    // Fechar dropdown ao clicar fora
    document.addEventListener('click', function(e) {
      if (!e.target.closest('.custom-palette-select')) {
        document.getElementById('palette-select-dropdown').classList.add('d-none');
        document.querySelector('#palette-select-header i').classList.remove('fa-chevron-up');
        document.querySelector('#palette-select-header i').classList.add('fa-chevron-down');
      }
    });
    
    // Event listeners para simbologia graduada
    document.getElementById('classes').addEventListener('change', function() {
      refreshPreview();
      
      // Se for simbologia graduada, atualizar interface de classes
      if (document.getElementById('style-type').value === 'graduated') {
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      }
      
      saveUserConfig();
    });
    
    document.getElementById('method').addEventListener('change', function() {
      applyVisibility();
      refreshPreview();
      
      // Se for simbologia graduada, atualizar interface de classes
      if (document.getElementById('style-type').value === 'graduated') {
        const style = computeStyle();
        createGraduatedClassesInterface(style);
      }
      
      // Atualizar informações do método apenas se for simbologia graduada
      const styleType = document.getElementById('style-type').value;
      if (styleType === 'graduated') {
        showMethodInfo();
      }
      
      saveUserConfig();
    });
    
    // Event listener para breaks manuais
    document.getElementById('manual-breaks').addEventListener('input', function() {
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listeners para campos personalizados
    ['stroke-color', 'fill-color', 'stroke-weight', 'fill-opacity', 'point-radius', 'line-opacity', 'line-dash'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de polígono
    ['polygon-border-color', 'polygon-border-width', 'polygon-border-toggle'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de classificação
    ['classes', 'manual-breaks'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('input', function() {
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listeners para controles de rótulos
    ['labels-enabled', 'label-field-select', 'label-font', 'label-size', 'label-color', 'label-bold', 'label-italic', 'label-buffer-color', 'label-buffer-size', 'label-buffer-opacity', 'label-offset-x', 'label-offset-y'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', function() {
          refreshPreview();
          saveUserConfig(); // Salvar configuração automaticamente
        });
      }
    });
    
    // Event listener específico para o slider de opacidade do buffer
    document.getElementById('label-buffer-opacity').addEventListener('input', function() {
      document.getElementById('buffer-opacity-value').textContent = this.value;
      refreshPreview();
      saveUserConfig();
    });
    
    // Event listener para botão de aplicar simbologia
    document.getElementById('btn-apply').addEventListener('click', async function() {
      const style = computeStyle();
      
      if (!style.field) {
        showToast('Por favor, selecione um campo para simbologia.', 'warning');
        return;
      }
      
      try {
        // Salvar configurações do usuário antes de aplicar
        saveUserConfig();
        
        // Usar a função que já tem toda a lógica implementada
        const config = {
          field: style.field,
          styleType: style.type || 'graduated'
        };
        
        const success = await saveSymbologyToDatabase(config);
        
        if (!success) {
          showToast('Erro ao aplicar simbologia no portal', 'error');
        }
      } catch (error) {
        console.error('Erro ao aplicar simbologia:', error);
        showToast('Erro ao aplicar simbologia. Verifique o console para mais detalhes.', 'error');
      }
    });

    // Event listeners para controles de rótulos
    setupLabelEventListeners();

    // Event listener para botão de aplicar rótulos
    document.getElementById('btn-apply-labels').addEventListener('click', async function() {
      const labelConfig = getLabelConfiguration();

      if (!labelConfig.field) {
        showToast('Por favor, selecione um campo para rótulos.', 'warning');
        return;
      }

      try {
        saveUserConfig(); // Salvar configurações gerais

        const response = await fetch(`/admin/layer/${layerId}/labels/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(labelConfig)
        });

        if (response.ok) {
          showToast('Configurações de rótulos aplicadas com sucesso!', 'success');
          refreshPreview(); // Atualizar preview com novas configurações de rótulos
        } else {
          const error = await response.json();
          showToast(`Erro ao aplicar configurações de rótulos: ${error.error || 'Erro desconhecido'}`, 'error');
        }
      } catch (error) {
        console.error('Erro ao aplicar configurações de rótulos:', error);
        showToast('Erro ao aplicar configurações de rótulos. Verifique o console para mais detalhes.', 'error');
      }
    });

    // Event listener para botão de pré-visualizar rótulos
    document.getElementById('btn-preview-labels').addEventListener('click', function() {
      const labelConfig = getLabelConfiguration();
      if (!labelConfig.field) {
        showToast('Por favor, selecione um campo para rótulos.', 'warning');
        return;
      }
      
      previewLabels(labelConfig);
      showToast('Pré-visualização de rótulos atualizada!', 'info');
    });

    // Event listener para botão de resetar rótulos
    document.getElementById('btn-reset-labels').addEventListener('click', function() {
      resetLabelConfiguration();
      showToast('Configurações de rótulos resetadas!', 'info');
    });
    
    // Selecionar primeira paleta por padrão (Viridis)
    document.getElementById('palette-select').value = 'Viridis';
    
    // Configurar o select customizado com o valor padrão
    document.getElementById('palette-select-text').textContent = 'Viridis - Científica Moderna';
    
    // Event listeners para gerenciamento de paletas personalizadas
    document.getElementById('btn-create-palette').addEventListener('click', createNewPalette);
    document.getElementById('btn-save-current-palette').addEventListener('click', saveCurrentPalette);
    document.getElementById('btn-manage-palettes').addEventListener('click', managePalettes);
    
    // Carregar paletas personalizadas ao inicializar
    loadCustomPalettes();
    
    // Inicializar previews de cores das paletas
    initializePalettePreviews();
    
    // Configurar filtro inicial de paletas
    const initialStyleType = document.getElementById('style-type').value;
    filterPalettesForStyleType(initialStyleType);
  });

  // Função para inicializar os previews de cores das paletas
  function initializePalettePreviews() {
    const paletteOptions = document.querySelectorAll('.palette-preview-mini');
    
    paletteOptions.forEach(option => {
      const paletteName = option.dataset.palette;
      const colors = brewer(paletteName, 8, false);
      
      // Criar variáveis CSS para as cores
      let cssVars = '';
      colors.forEach((color, index) => {
        cssVars += `--color${index + 1}: ${color};`;
      });
      
      option.style.cssText = cssVars;
    });
    
    // Também inicializar previews das paletas personalizadas
    updateCustomPalettePreviews();
  }

  // Função para filtrar paletas baseado no tipo de simbologia
  function filterPalettesForStyleType(styleType) {
    console.log('filterPalettesForStyleType chamada com:', styleType);
    
    // Selecionar todos os grupos de paletas
    const qualitativeGroups = document.querySelectorAll('.palette-optgroup[data-type="qualitative"]');
    const sequentialGroups = document.querySelectorAll('.palette-optgroup[data-type="sequential"]');
    const divergentGroups = document.querySelectorAll('.palette-optgroup[data-type="divergent"]');
    const customGroups = document.querySelectorAll('.palette-optgroup[data-type="custom"]');
    
    console.log('Grupos encontrados:', {
      qualitative: qualitativeGroups.length,
      sequential: sequentialGroups.length,
      divergent: divergentGroups.length,
      custom: customGroups.length
    });
    
    // Primeiro, remover todas as classes de filtro
    const allGroups = document.querySelectorAll('.palette-optgroup');
    console.log('Total de grupos encontrados:', allGroups.length);
    
    allGroups.forEach(group => {
      group.classList.remove('show-for-graduated', 'show-for-categorized', 'show-for-single');
      console.log('Removendo classes de filtro do grupo:', group.dataset.type);
    });
    
    if (styleType === 'graduated') {
      console.log('Aplicando filtro para simbologia graduada');
      // Para simbologia graduada, mostrar apenas sequencial, divergente e personalizadas
      qualitativeGroups.forEach(group => {
        group.classList.add('show-for-graduated');
        group.style.setProperty('display', 'none', 'important');
        console.log('Ocultando grupo qualitativo:', group);
      });
      sequentialGroups.forEach(group => {
        group.classList.add('show-for-graduated');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo sequencial:', group);
      });
      divergentGroups.forEach(group => {
        group.classList.add('show-for-graduated');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo divergente:', group);
      });
      customGroups.forEach(group => {
        group.classList.add('show-for-graduated');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo personalizado:', group);
      });
    } else if (styleType === 'categorized') {
      console.log('Aplicando filtro para simbologia categorizada');
      // Para simbologia categorizada, mostrar APENAS qualitativas e personalizadas
      qualitativeGroups.forEach(group => {
        group.classList.add('show-for-categorized');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo qualitativo:', group);
      });
      sequentialGroups.forEach(group => {
        group.classList.add('show-for-categorized');
        group.style.setProperty('display', 'none', 'important');
        console.log('Ocultando grupo sequencial:', group);
      });
      divergentGroups.forEach(group => {
        group.classList.add('show-for-categorized');
        group.style.setProperty('display', 'none', 'important');
        console.log('Ocultando grupo divergente:', group);
      });
      customGroups.forEach(group => {
        group.classList.add('show-for-categorized');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo personalizado:', group);
      });
      console.log('Paletas habilitadas para simbologia categorizada: Qualitativas e Personalizadas');
    } else {
      console.log('Aplicando filtro para outros tipos');
      // Para outros tipos, mostrar todas as paletas
      qualitativeGroups.forEach(group => {
        group.classList.add('show-for-single');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo qualitativo:', group);
      });
      sequentialGroups.forEach(group => {
        group.classList.add('show-for-single');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo sequencial:', group);
      });
      divergentGroups.forEach(group => {
        group.classList.add('show-for-single');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo divergente:', group);
      });
      customGroups.forEach(group => {
        group.classList.add('show-for-single');
        group.style.setProperty('display', 'block', 'important');
        console.log('Mostrando grupo personalizado:', group);
      });
    }
  }

  // Função para atualizar apenas as cores das classes graduadas (sem recriar interface)
  function updateGraduatedClassColors() {
    const style = computeStyle();
    if (!style || !style.field || !style.classes) return;
    
    const palette = style.palette || 'Blues';
    const colors = brewer(palette, style.classes, style.palette_invert);
    
    // Atualizar apenas as cores das classes existentes
    for (let i = 0; i < style.classes; i++) {
      const colorPreview = document.querySelector(`.color-preview[data-index="${i}"]`);
      const colorInput = document.querySelector(`.graduated-class-color[data-index="${i}"]`);
      const hexInput = document.querySelector(`.graduated-class-hex[data-index="${i}"]`);
      
      if (colorPreview && colorInput && hexInput) {
        // Verificar se há cor personalizada salva
        const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
        const newColor = savedColor || colors[i];
        
        // Atualizar elementos visuais
        colorPreview.style.backgroundColor = newColor;
        colorInput.value = newColor;
        hexInput.value = newColor;
        
        // Atualizar campos RGB se estiverem visíveis
        const rgbInputs = document.querySelector(`.graduated-class-rgb-inputs[data-index="${i}"]`);
        if (rgbInputs && !rgbInputs.classList.contains('d-none')) {
          const rgb = hexToRgb(newColor);
          if (rgb) {
            const rInput = rgbInputs.querySelector('input[placeholder="R"]');
            const gInput = rgbInputs.querySelector('input[placeholder="G"]');
            const bInput = rgbInputs.querySelector('input[placeholder="B"]');
            if (rInput && gInput && bInput) {
              rInput.value = rgb.r;
              gInput.value = rgb.g;
              bInput.value = rgb.b;
            }
          }
        }
      }
    }
  }

  // Função para aplicar estilo graduado
  function applyGraduatedStyle(layer, style) {
    console.log('applyGraduatedStyle chamada com:', style);
    
    if (!layerData || !style.field) {
      console.warn('applyGraduatedStyle: layerData ou style.field não disponível:', {
        hasLayerData: !!layerData,
        hasField: !!style.field,
        field: style.field
      });
      return;
    }
    
    // Coletar valores do campo selecionado
    const values = layerData.features
      .map(f => parseFloat(f.properties[style.field]))
      .filter(v => !isNaN(v))
      .sort((a, b) => a - b);
    
    console.log('Valores coletados do campo:', {
      totalFeatures: layerData.features.length,
      valuesWithNaN: layerData.features.map(f => f.properties[style.field]),
      valuesFiltered: values,
      field: style.field
    });
    
    if (values.length === 0) {
      console.warn('applyGraduatedStyle: Nenhum valor válido encontrado para o campo:', style.field);
      return;
    }
    
    const min = values[0];
    const max = values[values.length - 1];
    const classes = style.classes || 5;
    
    // Gerar breaks baseado no método
    let breaks = [];
    if (style.method === 'equal') {
      // Equal Interval
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
      console.log(`📊 DEBUG Equal Interval: step=${step}, breaks=`, breaks);
    } else if (style.method === 'quantile') {
      // Quantiles
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
      console.log(`📊 DEBUG Quantiles: step=${step}, breaks=`, breaks);
    } else if (style.method === 'jenks') {
      // Jenks Natural Breaks (simplificado)
      const step = values.length / classes;
      for (let i = 0; i <= classes; i++) {
        const index = Math.floor(i * step);
        breaks.push(values[Math.min(index, values.length - 1)]);
      }
      console.log(`📊 DEBUG Jenks: step=${step}, breaks=`, breaks);
    } else if (style.method === 'log') {
      // Logarithmic
      const logMin = Math.log(Math.max(min, 0.1));
      const logMax = Math.log(max);
      const step = (logMax - logMin) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(Math.exp(logMin + (i * step)));
      }
      console.log(`📊 DEBUG Logarithmic: step=${step}, breaks=`, breaks);
    } else if (style.method === 'stddev') {
      // Standard Deviation
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
      const stddev = Math.sqrt(variance);
      
      // Criar classes baseadas em desvios padrão
      const stddevStep = (2 * stddev) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(mean - stddev + (i * stddevStep));
      }
      console.log(`📊 DEBUG Standard Deviation: mean=${mean}, stddev=${stddev}, breaks=`, breaks);
    } else if (style.method === 'arithmetic') {
      // Arithmetic Progression
      const step = (max - min) / classes;
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (i * step));
      }
      console.log(`📊 DEBUG Arithmetic: step=${step}, breaks=`, breaks);
    } else if (style.method === 'geometric') {
      // Geometric Progression
      const ratio = Math.pow(max / min, 1 / classes);
      for (let i = 0; i <= classes; i++) {
        breaks.push(min * Math.pow(ratio, i));
      }
      console.log(`📊 DEBUG Geometric: ratio=${ratio}, breaks=`, breaks);
    } else if (style.method === 'manual' && style.breaks) {
      breaks = style.breaks;
      console.log(`📊 DEBUG Manual: breaks=`, breaks);
    }
    
    console.log(`📊 DEBUG Resumo dos Breaks:`);
    console.log(`  Método: ${style.method}`);
    console.log(`  Min: ${min}, Max: ${max}`);
    console.log(`  Classes: ${classes}`);
    console.log(`  Breaks finais:`, breaks);
    
    // Gerar cores da paleta
    const palette = style.palette || 'Blues';
    const colors = brewer(palette, classes, style.palette_invert);
    
    console.log(`🎨 DEBUG Geração de Cores:`);
    console.log(`  Paleta: ${palette}`);
    console.log(`  Classes: ${classes}`);
    console.log(`  Inverter: ${style.palette_invert}`);
    console.log(`  Cores geradas:`, colors);
    
    // Carregar cores personalizadas se disponíveis
    const customColors = [];
    for (let i = 0; i < classes; i++) {
      const savedColor = localStorage.getItem(`graduated_class_color_${layerId}_${style.field}_${i}`);
      customColors.push(savedColor || colors[i]);
      console.log(`  Classe ${i}: ${savedColor ? 'Personalizada' : 'Padrão'} -> ${customColors[i]}`);
    }
    
    // Aplicar estilo a cada feature
    console.log('Aplicando estilo a cada feature. Total de features:', layer.getLayers().length);
    console.log('Breaks calculados:', breaks);
    console.log('Cores disponíveis:', customColors);
    
    // DEBUG: Verificar distribuição dos valores
    console.log(`📊 DEBUG Distribuição dos Valores:`);
    console.log(`  Total de valores: ${values.length}`);
    console.log(`  Valores únicos:`, [...new Set(values)].sort((a, b) => a - b));
    console.log(`  Min: ${min}, Max: ${max}`);
    console.log(`  Range: ${max - min}`);
    
    // Verificar se há valores que não se encaixam nos breaks
    const valuesOutsideBreaks = values.filter(v => v < breaks[0] || v >= breaks[breaks.length - 1]);
    if (valuesOutsideBreaks.length > 0) {
      console.warn(`⚠️ Valores fora dos breaks:`, valuesOutsideBreaks);
    }
    
    let featuresStyled = 0;
    layer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.properties) {
        const value = parseFloat(featureLayer.feature.properties[style.field]);
        if (isNaN(value)) {
          console.log('Feature com valor NaN:', featureLayer.feature.properties[style.field]);
          return;
        }
        
        // Encontrar classe para o valor
        let colorIndex = 0;
        for (let i = 0; i < breaks.length - 1; i++) {
          // Para a última classe, incluir o valor máximo
          if (i === breaks.length - 2) {
            if (value >= breaks[i] && value <= breaks[i + 1]) {
              colorIndex = i;
              break;
            }
          } else {
            if (value >= breaks[i] && value < breaks[i + 1]) {
              colorIndex = i;
              break;
            }
          }
        }
        
        // DEBUG: Verificar mapeamento de cores
        console.log(`🔍 DEBUG Mapeamento de Cores:`);
        console.log(`  Feature valor: ${value}`);
        console.log(`  Break encontrado: [${breaks[colorIndex]}, ${breaks[colorIndex + 1]})`);
        console.log(`  Índice da cor: ${colorIndex}`);
        console.log(`  Cor aplicada: ${customColors[colorIndex]}`);
        console.log(`  Todas as cores:`, customColors);
        console.log(`  Todos os breaks:`, breaks);
        
        // Aplicar cor
        const color = customColors[colorIndex] || customColors[0];
        
        console.log(`Feature ${value} -> Classe ${colorIndex} -> Cor ${color} | Break: [${breaks[colorIndex]}, ${breaks[colorIndex + 1]})`);
        
        // IMPORTANTE: Carregar configurações de linha personalizadas para esta classe
        let customLineOpacity = null;
        let customLineStyle = null;
        let customLineSpacing = null;
        
        if (style.geometry_type === 'line') {
          customLineOpacity = localStorage.getItem(`graduated_line_opacity_${layerId}_${style.field}_${colorIndex}`);
          customLineStyle = localStorage.getItem(`graduated_line_style_${layerId}_${style.field}_${colorIndex}`);
          customLineSpacing = localStorage.getItem(`graduated_line_spacing_${layerId}_${style.field}_${colorIndex}`);
          
          console.log(`Configurações de linha para classe ${colorIndex}:`, {
            opacity: customLineOpacity,
            style: customLineStyle,
            spacing: customLineSpacing
          });
        }
        
        // Configurar estilo base baseado no tipo de geometria
        let layerStyle = {};
        
        if (style.geometry_type === 'polygon') {
          // Para polígonos, usar fillColor
          layerStyle = {
            fillColor: color,
            fillOpacity: style.palette_opacity || 1.0
          };
          
          // Aplicar configurações de borda se estiver habilitada
          if (style.border_color && style.border_width > 0) {
            layerStyle.color = style.border_color;
            layerStyle.weight = style.border_width;
          } else {
            // Se não quiser borda, definir como transparente
            layerStyle.color = 'transparent';
            layerStyle.weight = 0;
          }
        } else if (style.geometry_type === 'line') {
          // Para linhas, usar color (cor da linha) com configurações personalizadas
          let lineWeight = style.border_width || 2;
          
          // Verificar se o tamanho proporcional está ativado
          const isProportionalSizeEnabled = document.getElementById('proportional-size-toggle')?.checked || false;
          console.log('🔍 Tamanho proporcional ativado:', isProportionalSizeEnabled);
          
          if (isProportionalSizeEnabled) {
            const minWeight = parseFloat(document.getElementById('min-line-weight')?.value || '2');
            const maxWeight = parseFloat(document.getElementById('max-line-weight')?.value || '8');
            
            console.log('⚖️ Pesos configurados:', { minWeight, maxWeight, colorIndex, classes });
            
            // IMPORTANTE: Calcular peso proporcional baseado no VALOR REAL da feature, não na posição da classe
            // Isso garante que features com valores maiores tenham espessuras maiores, independente da classe
            const featureValue = parseFloat(featureLayer.feature.properties[style.field]);
            const totalRange = max - min;
            const valuePercent = totalRange > 0 ? ((featureValue - min) / totalRange) * 100 : 0;
            
            // Calcular peso proporcional baseado no valor real da feature
            const proportionalWeight = minWeight + (valuePercent / 100) * (maxWeight - minWeight);
            
            console.log(`📏 Feature ${featureValue} (Classe ${colorIndex}): ${valuePercent.toFixed(1)}% -> Peso: ${proportionalWeight.toFixed(1)}px`);
            console.log(`🎯 Break da classe: [${breaks[colorIndex]}, ${breaks[colorIndex + 1]}) | Valor da feature: ${featureValue}`);
            
            lineWeight = proportionalWeight;
          } else {
            console.log('📏 Usando peso padrão:', lineWeight);
          }
          
          layerStyle = {
            color: color,
            weight: lineWeight,
            opacity: customLineOpacity ? parseFloat(customLineOpacity) : (style.palette_opacity || 1.0)
          };
          
          // Aplicar estilo da linha se personalizado
          if (customLineStyle && customLineStyle !== '') {
            // Aplicar espaçamento personalizado se houver
            if (customLineSpacing && customLineStyle !== 'custom') {
              const spacing = parseFloat(customLineSpacing);
              if (customLineStyle === '5,5') {
                layerStyle.dashArray = `${spacing},${spacing}`;
              } else if (customLineStyle === '10,5') {
                layerStyle.dashArray = `${spacing * 2},${spacing}`;
              } else if (customLineStyle === '2,2') {
                layerStyle.dashArray = `${spacing * 0.4},${spacing * 0.4}`;
              } else if (customLineStyle === '1,1') {
                layerStyle.dashArray = `${spacing * 0.2},${spacing * 0.2}`;
              } else if (customLineStyle === '5,2,1,2') {
                layerStyle.dashArray = `${spacing},${spacing * 0.4},${spacing * 0.2},${spacing * 0.4}`;
              } else if (customLineStyle === '10,2,1,2') {
                layerStyle.dashArray = `${spacing * 2},${spacing * 0.4},${spacing * 0.2},${spacing * 0.4}`;
              } else if (customLineStyle === '15,3,3,3') {
                layerStyle.dashArray = `${spacing * 1.5},${spacing * 0.3},${spacing * 0.3},${spacing * 0.3}`;
              } else if (customLineStyle === '20,5,5,5') {
                layerStyle.dashArray = `${spacing * 2},${spacing * 0.5},${spacing * 0.5},${spacing * 0.5}`;
              } else {
                layerStyle.dashArray = customLineStyle;
              }
            } else {
              layerStyle.dashArray = customLineStyle;
            }
          }
          
          // Aplicar configurações específicas de linha se disponíveis
          if (style.line_cap) layerStyle.lineCap = style.line_cap;
          if (style.line_join) layerStyle.lineJoin = style.line_join;
          if (style.line_miter_limit) layerStyle.lineMiterLimit = style.line_miter_limit;
          
        } else if (style.geometry_type === 'point') {
          // Para pontos, usar fillColor
          let pointRadius = style.border_width || 6;
          
          // Verificar se o tamanho proporcional dos pontos está ativado
          const isProportionalPointSizeEnabled = document.getElementById('proportional-point-size-toggle')?.checked || false;
          console.log('🔍 Tamanho proporcional dos pontos ativado:', isProportionalPointSizeEnabled);
          
          if (isProportionalPointSizeEnabled) {
            const minRadius = parseFloat(document.getElementById('min-point-radius')?.value || '4');
            const maxRadius = parseFloat(document.getElementById('max-point-radius')?.value || '12');
            
            console.log('⚖️ Raios configurados:', { minRadius, maxRadius, colorIndex, classes });
            
            // IMPORTANTE: Calcular raio proporcional baseado no VALOR REAL da feature, não na posição da classe
            // Isso garante que features com valores maiores tenham raios maiores, independente da classe
            const featureValue = parseFloat(featureLayer.feature.properties[style.field]);
            const totalRange = max - min;
            const valuePercent = totalRange > 0 ? ((featureValue - min) / totalRange) * 100 : 0;
            
            // Calcular raio proporcional baseado no valor real da feature
            const proportionalRadius = minRadius + (valuePercent / 100) * (maxRadius - minRadius);
            
            console.log(`📏 Feature ${featureValue} (Classe ${colorIndex}): ${valuePercent.toFixed(1)}% -> Raio: ${proportionalRadius.toFixed(1)}px`);
            console.log(`🎯 Break da classe: [${breaks[colorIndex]}, ${breaks[colorIndex + 1]}) | Valor da feature: ${featureValue}`);
            
            pointRadius = proportionalRadius;
          } else {
            console.log('📏 Usando raio padrão:', pointRadius);
          }
          
          layerStyle = {
            fillColor: color,
            fillOpacity: style.palette_opacity || 1.0,
            color: style.border_color || '#333333',
            weight: style.border_width || 1,
            radius: pointRadius,
            renderer: L.canvas.tileCanvas
          };
          
          // Aplicar configurações específicas de ponto se disponíveis
          const pointRadiusDefault = document.getElementById('point-radius-default')?.value;
          const pointOpacityDefault = document.getElementById('point-opacity-default')?.value;
          const pointShapeDefault = document.getElementById('point-shape-default')?.value;
          const pointBorderWidthDefault = document.getElementById('point-border-width-default')?.value;
          const pointBorderColorDefault = document.getElementById('point-border-color-default')?.value;
          const pointBorderStyleDefault = document.getElementById('point-border-style-default')?.value;
          const pointShadowDefault = document.getElementById('point-shadow-default')?.value;
          
          if (pointRadiusDefault && !isProportionalPointSizeEnabled) {
            layerStyle.radius = parseFloat(pointRadiusDefault);
          }
          if (pointOpacityDefault) {
            layerStyle.fillOpacity = parseFloat(pointOpacityDefault);
          }
          if (pointBorderWidthDefault) {
            layerStyle.weight = parseFloat(pointBorderWidthDefault);
          }
          if (pointBorderColorDefault) {
            layerStyle.color = pointBorderColorDefault;
          }
          
          // Aplicar forma personalizada se selecionada
          if (pointShapeDefault && pointShapeDefault !== 'circle') {
            layerStyle.shape = pointShapeDefault;
          }
          
          // Aplicar estilo da borda
          if (pointBorderStyleDefault) {
            layerStyle.dashArray = pointBorderStyleDefault === 'dashed' ? '5,5' : 
                                 pointBorderStyleDefault === 'dotted' ? '2,2' : '';
          }
          
          // Aplicar sombra
          if (pointShadowDefault && parseFloat(pointShadowDefault) > 0) {
            layerStyle.shadowBlur = parseFloat(pointShadowDefault);
            layerStyle.shadowColor = 'rgba(0,0,0,0.3)';
            layerStyle.shadowOffsetX = 2;
            layerStyle.shadowOffsetY = 2;
          }
          
          console.log('🎯 Estilo de ponto configurado:', layerStyle);
        }
        
        console.log('Aplicando estilo ao feature:', layerStyle);
        console.log('Feature antes do estilo:', featureLayer);
        
        try {
          // IMPORTANTE: Para pontos, remover ícones personalizados antes de aplicar o estilo
          if (style.geometry_type === 'point' && featureLayer.setIcon) {
            featureLayer.setIcon(null);
            console.log('🎯 Ícone personalizado removido do ponto');
          }
          
          featureLayer.setStyle(layerStyle);
          console.log('Estilo aplicado com sucesso ao feature');
        } catch (error) {
          console.error('Erro ao aplicar estilo ao feature:', error);
        }
        
        featuresStyled++;
      }
    });
    
    // Log de execução da função
    console.log(`applyGraduatedStyle executada com sucesso. Features estilizadas: ${featuresStyled}`);
    
    // Atualizar legenda após aplicar o estilo
    setTimeout(() => {
      renderPreview();
      
      // Se o tamanho proporcional estiver ativado para linhas, atualizar a legenda
      if (style.geometry_type === 'line') {
        const isProportionalSizeEnabled = document.getElementById('proportional-size-toggle')?.checked || false;
        if (isProportionalSizeEnabled) {
          const minWeight = parseFloat(document.getElementById('min-line-weight')?.value || '2');
          const maxWeight = parseFloat(document.getElementById('max-line-weight')?.value || '8');
          updateLegendWithProportionalSizes(minWeight, maxWeight, values);
        }
      }
      
      // Se o tamanho proporcional estiver ativado para pontos, atualizar a legenda
      if (style.geometry_type === 'point') {
        const isProportionalPointSizeEnabled = document.getElementById('proportional-point-size-toggle')?.checked || false;
        if (isProportionalPointSizeEnabled) {
          const minRadius = parseFloat(document.getElementById('min-point-radius')?.value || '4');
          const maxRadius = parseFloat(document.getElementById('max-point-radius')?.value || '12');
          updateLegendWithProportionalPointSizes(minRadius, maxRadius, values);
        }
      }
    }, 100);
  }

  // ========================================
  // FUNÇÕES PARA RÓTULOS AVANÇADOS
  // ========================================

  /**
   * Configura todos os event listeners para controles de rótulos
   */
  function setupLabelEventListeners() {
    // Sliders com valores dinâmicos
    const sliders = [
      { id: 'label-opacity', valueId: 'text-opacity-value', suffix: '' },
      { id: 'label-buffer-opacity', valueId: 'buffer-opacity-value', suffix: '' },
      { id: 'label-stroke-opacity', valueId: 'stroke-opacity-value', suffix: '' },
      { id: 'label-rotation', valueId: 'rotation-value', suffix: '°' },
      { id: 'label-callout-opacity', valueId: 'callout-opacity-value', suffix: '' }
    ];

    sliders.forEach(slider => {
      const element = document.getElementById(slider.id);
      const valueElement = document.getElementById(slider.valueId);
      
      if (element && valueElement) {
        element.addEventListener('input', function() {
          valueElement.textContent = this.value + slider.suffix;
        });
      }
    });

    // Event listeners para habilitar/desabilitar seções
    document.getElementById('label-buffer-enabled').addEventListener('change', function() {
      toggleLabelSection('buffer', this.checked);
    });

    document.getElementById('label-stroke-enabled').addEventListener('change', function() {
      toggleLabelSection('stroke', this.checked);
    });

    document.getElementById('label-callout-enabled').addEventListener('change', function() {
      toggleLabelSection('callout', this.checked);
    });

    document.getElementById('label-filter-enabled').addEventListener('change', function() {
      toggleLabelSection('filter', this.checked);
    });

    // Event listeners para pré-visualização em tempo real
    const previewElements = [
      'label-field-select', 'label-font', 'label-size', 'label-color',
      'label-bold', 'label-italic', 'label-underline', 'label-uppercase',
      'label-rotation', 'label-alignment', 'label-opacity'
    ];

    previewElements.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('change', debounce(updateLabelPreview, 300));
      }
    });
  }

  /**
   * Habilita/desabilita seções de configuração de rótulos
   */
  function toggleLabelSection(section, enabled) {
    const sectionMap = {
      'buffer': ['label-buffer-color', 'label-buffer-size', 'label-buffer-opacity'],
      'stroke': ['label-stroke-color', 'label-stroke-width', 'label-stroke-opacity'],
      'callout': ['label-callout-color', 'label-callout-width', 'label-callout-style', 
                  'label-callout-opacity', 'label-arrow-type', 'label-arrow-size', 
                  'label-callout-max-distance'],
      'filter': ['label-filter-expression']
    };

    const elements = sectionMap[section] || [];
    elements.forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.disabled = !enabled;
        element.style.opacity = enabled ? '1' : '0.5';
      }
    });
  }

  /**
   * Configura controles específicos para linhas na simbologia categorizada
   */
  function setupLineSpecificControls() {
    console.log('setupLineSpecificControls: Configurando controles específicos para linhas');
    
    // Event listener para espessura padrão das linhas
    const lineWeightDefault = document.getElementById('line-weight-default');
    if (lineWeightDefault) {
      lineWeightDefault.addEventListener('change', function() {
        console.log('Espessura padrão das linhas alterada:', this.value);
        updateAllLineWeights(this.value);
        refreshPreview();
      });
    }
    
    // Event listener para opacidade padrão das linhas
    const lineOpacityDefault = document.getElementById('line-opacity-default');
    if (lineOpacityDefault) {
      lineOpacityDefault.addEventListener('input', function() {
        const value = this.value;
        document.getElementById('line-opacity-value').textContent = value;
        console.log('Opacidade padrão das linhas alterada:', value);
        updateAllLineOpacities(value);
        refreshPreview();
      });
    }
    
    // Event listener para estilo padrão das linhas
    const lineStyleDefault = document.getElementById('line-style-default');
    if (lineStyleDefault) {
      lineStyleDefault.addEventListener('change', function() {
        console.log('Estilo padrão das linhas alterado:', this.value);
        if (this.value === 'custom') {
          document.getElementById('custom-line-style-controls').classList.remove('d-none');
        } else {
          document.getElementById('custom-line-style-controls').classList.add('d-none');
          updateAllLineStyles(this.value);
          refreshPreview();
        }
      });
    }
    
    // Event listener para espaçamento padrão das linhas
    const lineSpacingDefault = document.getElementById('line-spacing-default');
    if (lineSpacingDefault) {
      lineSpacingDefault.addEventListener('input', function() {
        const value = this.value;
        document.getElementById('line-spacing-value').textContent = value + 'px';
        console.log('Espaçamento padrão das linhas alterado:', value);
        updateAllLineSpacings(value);
        refreshPreview();
      });
    }
    
    // Event listener para padrão de linha personalizado
    const customLinePattern = document.getElementById('custom-line-pattern');
    if (customLinePattern) {
      customLinePattern.addEventListener('input', function() {
        updateCustomLinePreview(this.value);
      });
      
      customLinePattern.addEventListener('change', function() {
        if (this.value.trim()) {
          updateAllLineStyles(this.value);
          refreshPreview();
        }
      });
    }
    
    // Event listener para permitir personalização individual por categoria
    const allowCustomPerCategory = document.getElementById('line-allow-custom-per-category');
    if (allowCustomPerCategory) {
      allowCustomPerCategory.addEventListener('change', function() {
        console.log('Personalização individual por categoria:', this.checked);
        toggleIndividualLineControls(this.checked);
        refreshPreview();
      });
    }
    
    // Event listeners para controles avançados
    const lineCapDefault = document.getElementById('line-cap-default');
    if (lineCapDefault) {
      lineCapDefault.addEventListener('change', function() {
        console.log('Cap das linhas alterado:', this.value);
        refreshPreview();
      });
    }
    
    const lineJoinDefault = document.getElementById('line-join-default');
    if (lineJoinDefault) {
      lineJoinDefault.addEventListener('change', function() {
        console.log('Junção das linhas alterada:', this.value);
        refreshPreview();
      });
    }
    
        const lineMiterLimit = document.getElementById('line-miter-limit');
    
    if (lineMiterLimit) {
      lineMiterLimit.addEventListener('change', function() {
        console.log('Miter limit das linhas alterado:', this.value);
        refreshPreview();
      });
    }
  }
  
  /**
   * Configura controles específicos para pontos na simbologia categorizada
   */
  function setupPointSpecificControls() {
    console.log('setupPointSpecificControls: Configurando controles específicos para pontos');
    
    // Event listener para raio padrão dos pontos
    const pointRadiusDefault = document.getElementById('point-radius-default');
    if (pointRadiusDefault) {
      pointRadiusDefault.addEventListener('change', function() {
        console.log('Raio padrão dos pontos alterado:', this.value);
        updateAllPointRadii(this.value);
        refreshPreview();
      });
    }
    
    // Event listener para opacidade padrão dos pontos
    const pointOpacityDefault = document.getElementById('point-opacity-default');
    if (pointOpacityDefault) {
      pointOpacityDefault.addEventListener('input', function() {
        const value = this.value;
        document.getElementById('point-opacity-value').textContent = value;
        console.log('Opacidade padrão dos pontos alterada:', value);
        updateAllPointOpacities(value);
        refreshPreview();
      });
    }
    
    // Event listener para forma padrão dos pontos
    const pointShapeDefault = document.getElementById('point-shape-default');
    if (pointShapeDefault) {
      pointShapeDefault.addEventListener('change', function() {
        console.log('Forma padrão dos pontos alterada:', this.value);
        if (this.value === 'custom') {
          document.getElementById('custom-point-shape-controls').classList.remove('d-none');
        } else {
          document.getElementById('custom-point-shape-controls').classList.add('d-none');
          updateAllPointShapes(this.value);
          refreshPreview();
        }
      });
    }
    
    // Event listener para borda padrão dos pontos
    const pointBorderWidthDefault = document.getElementById('point-border-width-default');
    if (pointBorderWidthDefault) {
      pointBorderWidthDefault.addEventListener('input', function() {
        const value = this.value;
        document.getElementById('point-border-width-value').textContent = value + 'px';
        console.log('Borda padrão dos pontos alterada:', value);
        updateAllPointBorderWidths(value);
        refreshPreview();
      });
    }
    
    // Event listener para forma personalizada dos pontos
    const customPointShape = document.getElementById('custom-point-shape');
    if (customPointShape) {
      customPointShape.addEventListener('input', function() {
        updateCustomPointPreview(this.value);
      });
      
      customPointShape.addEventListener('change', function() {
        if (this.value.trim()) {
          updateAllPointShapes(this.value);
          refreshPreview();
        }
      });
    }
    
    // Event listener para permitir personalização individual por categoria
    const allowCustomPerCategory = document.getElementById('point-allow-custom-per-category');
    if (allowCustomPerCategory) {
      allowCustomPerCategory.addEventListener('change', function() {
        console.log('Personalização individual por categoria:', this.checked);
        toggleIndividualPointControls(this.checked);
        refreshPreview();
      });
    }
    
    // Event listeners para controles avançados
    const pointBorderColorDefault = document.getElementById('point-border-color-default');
    if (pointBorderColorDefault) {
      pointBorderColorDefault.addEventListener('change', function() {
        console.log('Cor da borda dos pontos alterada:', this.value);
        refreshPreview();
      });
    }
    
    const pointBorderStyleDefault = document.getElementById('point-border-style-default');
    if (pointBorderStyleDefault) {
      pointBorderStyleDefault.addEventListener('change', function() {
        console.log('Estilo da borda dos pontos alterado:', this.value);
        refreshPreview();
      });
    }
    
    const pointShadowDefault = document.getElementById('point-shadow-default');
    if (pointShadowDefault) {
      pointShadowDefault.addEventListener('input', function() {
        const value = this.value;
        document.getElementById('point-shadow-value').textContent = value + 'px';
        console.log('Sombra dos pontos alterada:', value);
        refreshPreview();
      });
    }
    
    // Configurar biblioteca de ícones temáticos
    setupIconLibrary();
  }

  /**
   * Atualiza a espessura de todas as linhas para o valor padrão
   */
  function updateAllLineWeights(weight) {
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    categoryItems.forEach(item => {
      const weightInput = item.querySelector('.line-weight-input');
      if (weightInput) {
        weightInput.value = weight;
        // Disparar evento de mudança para atualizar a interface
        weightInput.dispatchEvent(new Event('change'));
      }
    });
  }

  /**
   * Atualiza a opacidade de todas as linhas para o valor padrão
   */
  function updateAllLineOpacities(opacity) {
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    categoryItems.forEach(item => {
      const opacityInput = item.querySelector('.line-opacity-input');
      if (opacityInput) {
        opacityInput.value = opacity;
        // Disparar evento de mudança para atualizar a interface
        opacityInput.dispatchEvent(new Event('change'));
      }
    });
  }

  /**
   * Atualiza o estilo de todas as linhas para o valor padrão
   */
  function updateAllLineStyles(style) {
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    categoryItems.forEach(item => {
      const styleSelect = item.querySelector('.line-style-select');
      if (styleSelect) {
        styleSelect.value = style;
        // Disparar evento de mudança para atualizar a interface
        styleSelect.dispatchEvent(new Event('change'));
      }
    });
  }

  /**
   * Habilita/desabilita controles individuais de linha por categoria
   */
  function toggleIndividualLineControls(enabled) {
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    categoryItems.forEach(item => {
      const lineControls = item.querySelectorAll('.line-control-individual');
      lineControls.forEach(control => {
        control.disabled = !enabled;
        control.style.opacity = enabled ? '1' : '0.5';
      });
    });
  }
  
  /**
   * Sincroniza o espaçamento de todas as categorias com o valor padrão
   * IMPORTANTE: Chamar esta função após reordenação de categorias
   */
  function syncLineSpacingAfterReorder() {
    const defaultSpacing = document.getElementById('line-spacing-default')?.value || 10;
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    
    categoryItems.forEach(item => {
      const category = item.dataset.category;
      const spacingSlider = item.querySelector('.line-spacing-slider');
      const spacingValue = item.querySelector('.line-spacing-value');
      const styleSelect = item.querySelector('.line-style-select');
      const spacingControls = item.querySelector('.line-spacing-controls');
      const weightInput = item.querySelector('.line-weight-input');
      const opacityInput = item.querySelector('.line-opacity-input');
      
      // IMPORTANTE: Aplicar configurações salvas de linha se existirem
      const savedLineStyle = localStorage.getItem(`line_style_${layerId}_${category}`);
      const savedLineSpacing = localStorage.getItem(`line_spacing_${layerId}_${category}`);
      const savedLineWeight = localStorage.getItem(`line_weight_${layerId}_${category}`);
      const savedLineOpacity = localStorage.getItem(`line_opacity_${layerId}_${category}`);
      
      // Aplicar estilo da linha salvo
      if (savedLineStyle !== null && styleSelect) {
        styleSelect.value = savedLineStyle;
        console.log(`Estilo da linha restaurado para ${category}: ${savedLineStyle}`);
      }
      
      // Aplicar espaçamento da linha salvo ou usar padrão
      if (spacingSlider && spacingValue) {
        const finalSpacing = savedLineSpacing !== null ? savedLineSpacing : defaultSpacing;
        spacingSlider.value = finalSpacing;
        spacingValue.textContent = finalSpacing + 'px';
        console.log(`Espaçamento da linha aplicado para ${category}: ${finalSpacing}`);
      }
      
      // Aplicar espessura da linha salva
      if (savedLineWeight !== null && weightInput) {
        weightInput.value = savedLineWeight;
        console.log(`Espessura da linha restaurada para ${category}: ${savedLineWeight}`);
      }
      
      // Aplicar opacidade da linha salva
      if (savedLineOpacity !== null && opacityInput) {
        opacityInput.value = savedLineOpacity;
        console.log(`Opacidade da linha restaurada para ${category}: ${savedLineOpacity}`);
      }
      
      // Mostrar/ocultar controle de espaçamento baseado no estilo selecionado
      if (styleSelect && spacingControls) {
        const currentStyle = savedLineStyle !== null ? savedLineStyle : styleSelect.value;
        if (currentStyle === '') {
          // Estilo "Contínua" - ocultar controles
          spacingControls.classList.add('d-none');
        } else {
          // Outros estilos - mostrar controles
          spacingControls.classList.remove('d-none');
        }
      }
    });
    
    console.log('Configurações de linha sincronizadas após reordenação');
  }
  
  /**
   * Atualiza o espaçamento de todas as linhas para o valor padrão
   */
  function updateAllLineSpacings(spacing) {
    const categoryItems = document.querySelectorAll('.categorized-class-item');
    categoryItems.forEach(item => {
      const spacingSlider = item.querySelector('.line-spacing-slider');
      if (spacingSlider) {
        spacingSlider.value = spacing;
        const spacingValue = item.querySelector('.line-spacing-value');
        if (spacingValue) {
          spacingValue.textContent = spacing + 'px';
        }
        // Disparar evento de mudança para atualizar a interface
        spacingSlider.dispatchEvent(new Event('change'));
      }
    });
  }
  
  /**
   * Atualiza o preview do padrão de linha personalizado
   */
  function updateCustomLinePreview(pattern) {
    const previewElement = document.getElementById('custom-line-preview');
    if (!previewElement) return;
    
    try {
      const parts = pattern.split(',').map(p => parseInt(p.trim()) || 0);
      if (parts.length < 2) return;
      
      // Criar SVG para preview
      const totalWidth = parts.reduce((sum, part) => sum + part, 0);
      const height = 40;
      
      let pathData = '';
      let currentX = 0;
      
      for (let i = 0; i < parts.length; i++) {
        if (i % 2 === 0) { // Traço
          pathData += `M${currentX},${height/2} L${currentX + parts[i]},${height/2} `;
        }
        currentX += parts[i];
      }
      
      const svg = `
        <svg width="${totalWidth}" height="${height}" xmlns="http://www.w3.org/2000/svg">
          <path d="${pathData}" stroke="#333" stroke-width="3" fill="none"/>
        </svg>
      `;
      
      previewElement.innerHTML = svg;
    } catch (error) {
      console.error('Erro ao criar preview do padrão de linha:', error);
      previewElement.innerHTML = '<div class="text-muted">Preview não disponível</div>';
    }
  }

  /**
   * Coleta todas as configurações de rótulos
   */
  function getLabelConfiguration() {
    return {
      // Configurações básicas
      enabled: document.getElementById('labels-enabled').checked,
      field: document.getElementById('label-field-select').value,
      font: document.getElementById('label-font').value,
      size: parseInt(document.getElementById('label-size').value),
      color: document.getElementById('label-color').value,
      opacity: parseFloat(document.getElementById('label-opacity').value),
      
      // Estilo do texto
      bold: document.getElementById('label-bold').checked,
      italic: document.getElementById('label-italic').checked,
      underline: document.getElementById('label-underline').checked,
      uppercase: document.getElementById('label-uppercase').checked,
      rotation: parseInt(document.getElementById('label-rotation').value),
      alignment: document.getElementById('label-alignment').value,
      
      // Buffer
      bufferEnabled: document.getElementById('label-buffer-enabled').checked,
      bufferColor: document.getElementById('label-buffer-color').value,
      bufferSize: parseFloat(document.getElementById('label-buffer-size').value),
      bufferOpacity: parseFloat(document.getElementById('label-buffer-opacity').value),
      
      // Contorno
      strokeEnabled: document.getElementById('label-stroke-enabled').checked,
      strokeColor: document.getElementById('label-stroke-color').value,
      strokeWidth: parseFloat(document.getElementById('label-stroke-width').value),
      strokeOpacity: parseFloat(document.getElementById('label-stroke-opacity').value),
      
      // Posicionamento
      offsetX: parseInt(document.getElementById('label-offset-x').value),
      offsetY: parseInt(document.getElementById('label-offset-y').value),
      collisionDetection: document.getElementById('label-collision-detection').checked,
      minDistance: parseInt(document.getElementById('label-min-distance').value),
      priority: document.getElementById('label-priority').value,
      maxPerScreen: parseInt(document.getElementById('label-max-per-screen').value),
      
      // Linhas de chamada
      calloutEnabled: document.getElementById('label-callout-enabled').checked,
      calloutColor: document.getElementById('label-callout-color').value,
      calloutWidth: parseFloat(document.getElementById('label-callout-width').value),
      calloutStyle: document.getElementById('label-callout-style').value,
      calloutOpacity: parseFloat(document.getElementById('label-callout-opacity').value),
      arrowType: document.getElementById('label-arrow-type').value,
      arrowSize: parseInt(document.getElementById('label-arrow-size').value),
      calloutMaxDistance: parseInt(document.getElementById('label-callout-max-distance').value),
      
      // Filtros
      minZoom: parseInt(document.getElementById('label-min-zoom').value),
      maxZoom: parseInt(document.getElementById('label-max-zoom').value),
      filterEnabled: document.getElementById('label-filter-enabled').checked,
      filterExpression: document.getElementById('label-filter-expression').value
    };
  }

  /**
   * Aplica pré-visualização de rótulos no mapa
   */
  function previewLabels(labelConfig) {
    if (!currentLayer || !labelConfig.enabled || !labelConfig.field) {
      return;
    }

    // Remover rótulos existentes
    if (window.labelLayer) {
      map.removeLayer(window.labelLayer);
    }

    // Criar nova camada de rótulos
    window.labelLayer = L.layerGroup();

    currentLayer.eachLayer(function(layer) {
      if (layer.feature && layer.feature.properties) {
        const properties = layer.feature.properties;
        const labelText = properties[labelConfig.field];
        
        if (labelText !== null && labelText !== undefined) {
          // Aplicar filtros se habilitados
          if (labelConfig.filterEnabled && labelConfig.filterExpression) {
            if (!evaluateFilterExpression(properties, labelConfig.filterExpression)) {
              return;
            }
          }

          // Calcular posição do rótulo
          const bounds = layer.getBounds ? layer.getBounds() : null;
          const center = bounds ? bounds.getCenter() : layer.getLatLng();
          
          if (center) {
            const labelPosition = calculateLabelPosition(center, labelConfig);
            const labelMarker = createLabelMarker(labelText, labelPosition, labelConfig, center);
            
            window.labelLayer.addLayer(labelMarker);
          }
        }
      }
    });

    // Adicionar camada de rótulos ao mapa
    window.labelLayer.addTo(map);
  }

  /**
   * Calcula a posição do rótulo baseado no alinhamento e deslocamento
   */
  function calculateLabelPosition(center, config) {
    const offsetX = config.offsetX || 0;
    const offsetY = config.offsetY || 0;
    
    // Converter pixels para graus (aproximação)
    const pixelToDegree = 0.0001;
    
    return L.latLng(
      center.lat + (offsetY * pixelToDegree),
      center.lng + (offsetX * pixelToDegree)
    );
  }

  /**
   * Cria um marcador de rótulo com todas as configurações aplicadas
   */
  function createLabelMarker(text, position, config, originalPosition) {
    // Aplicar transformações de texto
    let displayText = text.toString();
    if (config.uppercase) {
      displayText = displayText.toUpperCase();
    }

    // Criar estilos CSS
    const styles = {
      fontFamily: config.font || 'Arial',
      fontSize: (config.size || 12) + 'px',
      color: config.color || '#000000',
      opacity: config.opacity || 1,
      fontWeight: config.bold ? 'bold' : 'normal',
      fontStyle: config.italic ? 'italic' : 'normal',
      textDecoration: config.underline ? 'underline' : 'none',
      transform: `rotate(${config.rotation || 0}deg)`,
      textAlign: getTextAlign(config.alignment),
      whiteSpace: 'nowrap',
      pointerEvents: 'none',
      zIndex: 1000
    };

    // Aplicar buffer se habilitado
    if (config.bufferEnabled && config.bufferSize > 0) {
      styles.textShadow = createTextShadow(config);
    }

    // Aplicar contorno se habilitado
    if (config.strokeEnabled && config.strokeWidth > 0) {
      styles.webkitTextStroke = `${config.strokeWidth}px ${config.strokeColor}`;
      styles.webkitTextStrokeOpacity = config.strokeOpacity || 1;
    }

    // Criar HTML do rótulo
    const labelHtml = `<div style="${objectToCSS(styles)}">${displayText}</div>`;

    // Criar marcador
    const labelMarker = L.marker(position, {
      icon: L.divIcon({
        html: labelHtml,
        className: 'custom-label-marker',
        iconSize: [0, 0],
        iconAnchor: [0, 0]
      })
    });

    // Adicionar linha de chamada se habilitada e necessária
    if (config.calloutEnabled && config.offsetX !== 0 || config.offsetY !== 0) {
      const calloutLine = createCalloutLine(originalPosition, position, config);
      if (calloutLine) {
        labelMarker.calloutLine = calloutLine;
      }
    }

    return labelMarker;
  }

  /**
   * Cria sombra de texto para buffer
   */
  function createTextShadow(config) {
    const size = config.bufferSize;
    const color = config.bufferColor;
    const opacity = config.bufferOpacity;
    
    const shadows = [];
    for (let x = -size; x <= size; x++) {
      for (let y = -size; y <= size; y++) {
        if (x !== 0 || y !== 0) {
          shadows.push(`${x}px ${y}px 0 ${color}`);
        }
      }
    }
    
    return shadows.join(', ');
  }

  /**
   * Converte alinhamento para CSS text-align
   */
  function getTextAlign(alignment) {
    const alignMap = {
      'left': 'left',
      'right': 'right',
      'center': 'center',
      'top': 'center',
      'bottom': 'center',
      'top-left': 'left',
      'top-right': 'right',
      'bottom-left': 'left',
      'bottom-right': 'right'
    };
    
    return alignMap[alignment] || 'center';
  }

  /**
   * Converte objeto de estilos para string CSS
   */
  function objectToCSS(styles) {
    return Object.entries(styles)
      .map(([key, value]) => `${camelToKebab(key)}: ${value}`)
      .join('; ');
  }

  /**
   * Converte camelCase para kebab-case
   */
  function camelToKebab(str) {
    return str.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
  }

  /**
   * Cria linha de chamada entre rótulo e ponto original
   */
  function createCalloutLine(start, end, config) {
    const distance = start.distanceTo(end);
    
    if (distance > config.calloutMaxDistance) {
      return null;
    }

    const lineOptions = {
      color: config.calloutColor || '#666666',
      weight: config.calloutWidth || 1,
      opacity: config.calloutOpacity || 0.7,
      dashArray: getLineDashArray(config.calloutStyle)
    };

    return L.polyline([start, end], lineOptions);
  }

  /**
   * Retorna padrão de linha baseado no estilo
   */
  function getLineDashArray(style) {
    const patterns = {
      'solid': null,
      'dashed': '10, 5',
      'dotted': '2, 3'
    };
    
    return patterns[style] || null;
  }

  /**
   * Avalia expressão de filtro
   */
  function evaluateFilterExpression(properties, expression) {
    try {
      // Substituir nomes de campos por valores
      let evalExpression = expression;
      
      Object.keys(properties).forEach(key => {
        const value = properties[key];
        const regex = new RegExp(`\\b${key}\\b`, 'g');
        
        if (typeof value === 'string') {
          evalExpression = evalExpression.replace(regex, `"${value}"`);
        } else {
          evalExpression = evalExpression.replace(regex, value);
        }
      });

      // Substituir operadores SQL por JavaScript
      evalExpression = evalExpression
        .replace(/\bAND\b/g, '&&')
        .replace(/\bOR\b/g, '||')
        .replace(/\bLIKE\b/g, '.includes')
        .replace(/=/g, '==');

      // Avaliar expressão (cuidado com segurança em produção)
      return new Function('return ' + evalExpression)();
    } catch (error) {
      console.warn('Erro ao avaliar expressão de filtro:', error);
      return true;
    }
  }

  /**
   * Reseta configurações de rótulos para padrão
   */
  function resetLabelConfiguration() {
    // Configurações básicas
    document.getElementById('labels-enabled').checked = true;
    document.getElementById('label-field-select').value = '';
    document.getElementById('label-font').value = 'Arial';
    document.getElementById('label-size').value = 12;
    document.getElementById('label-color').value = '#000000';
    document.getElementById('label-opacity').value = 1;
    document.getElementById('text-opacity-value').textContent = '1.0';
    
    // Estilo do texto
    document.getElementById('label-bold').checked = false;
    document.getElementById('label-italic').checked = false;
    document.getElementById('label-underline').checked = false;
    document.getElementById('label-uppercase').checked = false;
    document.getElementById('label-rotation').value = 0;
    document.getElementById('rotation-value').textContent = '0°';
    document.getElementById('label-alignment').value = 'center';
    
    // Buffer
    document.getElementById('label-buffer-enabled').checked = true;
    document.getElementById('label-buffer-color').value = '#ffffff';
    document.getElementById('label-buffer-size').value = 2;
    document.getElementById('label-buffer-opacity').value = 0.8;
    document.getElementById('buffer-opacity-value').textContent = '0.8';
    
    // Contorno
    document.getElementById('label-stroke-enabled').checked = false;
    document.getElementById('label-stroke-color').value = '#000000';
    document.getElementById('label-stroke-width').value = 1;
    document.getElementById('label-stroke-opacity').value = 1;
    document.getElementById('stroke-opacity-value').textContent = '1.0';
    
    // Posicionamento
    document.getElementById('label-offset-x').value = 0;
    document.getElementById('label-offset-y').value = 0;
    document.getElementById('label-collision-detection').checked = true;
    document.getElementById('label-min-distance').value = 10;
    document.getElementById('label-priority').value = 'medium';
    document.getElementById('label-max-per-screen').value = 100;
    
    // Linhas de chamada
    document.getElementById('label-callout-enabled').checked = false;
    document.getElementById('label-callout-color').value = '#666666';
    document.getElementById('label-callout-width').value = 1;
    document.getElementById('label-callout-style').value = 'solid';
    document.getElementById('label-callout-opacity').value = 0.7;
    document.getElementById('callout-opacity-value').textContent = '0.7';
    document.getElementById('label-arrow-type').value = 'simple';
    document.getElementById('label-arrow-size').value = 6;
    document.getElementById('label-callout-max-distance').value = 50;
    
    // Filtros
    document.getElementById('label-min-zoom').value = 1;
    document.getElementById('label-max-zoom').value = 20;
    document.getElementById('label-filter-enabled').checked = false;
    document.getElementById('label-filter-expression').value = '';

    // Atualizar seções habilitadas/desabilitadas
    toggleLabelSection('buffer', true);
    toggleLabelSection('stroke', false);
    toggleLabelSection('callout', false);
    toggleLabelSection('filter', false);
  }

  /**
   * Atualiza pré-visualização de rótulos em tempo real
   */
  function updateLabelPreview() {
    const labelConfig = getLabelConfiguration();
    if (labelConfig.enabled && labelConfig.field) {
      previewLabels(labelConfig);
    }
  }

  /**
   * Função debounce para otimizar performance
   */
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // ========================================
  // FUNÇÕES PARA O MODAL DE PROPRIEDADES DA LINHA GRADUADA
  // ========================================

  let currentGraduatedClassIndex = null;
  let currentGraduatedClassField = null;

  /**
   * Inicializa o modal de propriedades da linha graduada
   */
  function initializeGraduatedLinePropertiesModal() {
    // Event listener para o botão de propriedades da linha
    document.addEventListener('click', function(e) {
      if (e.target.closest('.graduated-line-properties-btn')) {
        const btn = e.target.closest('.graduated-line-properties-btn');
        const index = btn.dataset.index;
        const field = btn.dataset.field;
        
        openGraduatedLinePropertiesModal(index, field);
      }
    });

    // Event listener para o seletor de classe
    const classSelector = document.getElementById('graduated-class-selector');
    if (classSelector) {
      classSelector.addEventListener('change', function() {
        const selectedIndex = this.value;
        if (selectedIndex !== '') {
          loadGraduatedClassProperties(selectedIndex);
        } else {
          hideGraduatedLineProperties();
        }
      });
    }

    // Event listeners para os controles do modal
    setupGraduatedLinePropertiesEventListeners();
  }

  /**
   * Abre o modal de propriedades da linha graduada
   */
  function openGraduatedLinePropertiesModal(index, field) {
    console.log(`🚀 Abrindo modal para classe ${index} do campo ${field}`);
    
    currentGraduatedClassIndex = index;
    currentGraduatedClassField = field;
    
    console.log(`📝 Variáveis globais definidas:`, { 
      currentGraduatedClassIndex, 
      currentGraduatedClassField 
    });
    
    // Popular o seletor de classes
    populateGraduatedClassSelector();
    
    // Selecionar a classe atual
    const classSelector = document.getElementById('graduated-class-selector');
    if (classSelector) {
      classSelector.value = index;
      console.log(`✅ Seletor de classe definido para: ${index}`);
      loadGraduatedClassProperties(index);
    } else {
      console.error(`❌ Seletor de classe não encontrado`);
    }
    
    // Mostrar o modal
    const modal = new bootstrap.Modal(document.getElementById('graduatedLinePropertiesModal'));
    modal.show();
    
    console.log(`✅ Modal aberto com sucesso para classe ${index}`);
  }

  /**
   * Popula o seletor de classes graduadas
   */
  function populateGraduatedClassSelector() {
    const classSelector = document.getElementById('graduated-class-selector');
    if (!classSelector) {
      console.error(`❌ Seletor de classe não encontrado`);
      return;
    }
    
    console.log(`🔍 Populando seletor de classes...`);
    
    // Limpar opções existentes
    classSelector.innerHTML = '<option value="">Selecione uma classe...</option>';
    
    // Obter todas as classes graduadas
    const graduatedClasses = document.querySelectorAll('.graduated-class-item');
    console.log(`📊 Classes graduadas encontradas: ${graduatedClasses.length}`);
    
    graduatedClasses.forEach((classItem, index) => {
      const option = document.createElement('option');
      option.value = index;
      option.textContent = `Classe ${index + 1}`;
      classSelector.appendChild(option);
      console.log(`➕ Opção adicionada: Classe ${index + 1} (valor: ${index})`);
    });
    
    console.log(`✅ Seletor populado com ${graduatedClasses.length} classes`);
  }

  /**
   * Carrega as propriedades de uma classe graduada específica
   */
  function loadGraduatedClassProperties(index) {
    if (index === null || index === '') return;
    
    console.log(`🔍 Carregando propriedades da classe ${index} para campo ${currentGraduatedClassField}`);
    
    // Carregar valores salvos do localStorage
    const opacity = localStorage.getItem(`graduated_line_opacity_${layerId}_${currentGraduatedClassField}_${index}`) || '1';
    const style = localStorage.getItem(`graduated_line_style_${layerId}_${currentGraduatedClassField}_${index}`) || '';
    const spacing = localStorage.getItem(`graduated_line_spacing_${layerId}_${currentGraduatedClassField}_${index}`) || '10';
    
    console.log(`📊 Valores carregados:`, { opacity, style, spacing });
    
    // Aplicar valores aos controles
    const opacityInput = document.getElementById('graduated-line-opacity-modal');
    const styleSelect = document.getElementById('graduated-line-style-modal');
    const spacingInput = document.getElementById('graduated-line-spacing-modal');
    
    if (opacityInput) opacityInput.value = opacity;
    if (styleSelect) styleSelect.value = style;
    if (spacingInput) spacingInput.value = spacing;
    
    // Atualizar valores exibidos
    updateGraduatedLinePropertyValues();
    
    // Mostrar/ocultar controles baseado no estilo
    toggleGraduatedLineSpacingControl(style);
    
    // Mostrar propriedades
    showGraduatedLineProperties();
    
    // Atualizar preview
    updateGraduatedLinePreview();
  }

  /**
   * Configura os event listeners para os controles do modal
   */
  function setupGraduatedLinePropertiesEventListeners() {
    // Opacidade
    const opacityInput = document.getElementById('graduated-line-opacity-modal');
    if (opacityInput) {
      opacityInput.addEventListener('input', function() {
        updateGraduatedLinePropertyValues();
        updateGraduatedLinePreview();
        // Aplicar mudanças em tempo real ao mapa
        applyGraduatedLinePropertiesToMap(true);
      });
    }

    // Estilo da linha
    const styleSelect = document.getElementById('graduated-line-style-modal');
    if (styleSelect) {
      styleSelect.addEventListener('change', function() {
        const selectedStyle = this.value;
        console.log(`🎨 Estilo da linha alterado para: ${selectedStyle}`);
        
        toggleGraduatedLineSpacingControl(selectedStyle);
        toggleGraduatedCustomPatternContainer(selectedStyle);
        updateGraduatedLinePreview();
        
        // Aplicar mudanças em tempo real ao mapa
        console.log(`⚡ Aplicando mudanças em tempo real...`);
        applyGraduatedLinePropertiesToMap(true);
      });
    }

    // Espaçamento
    const spacingInput = document.getElementById('graduated-line-spacing-modal');
    if (spacingInput) {
      spacingInput.addEventListener('input', function() {
        updateGraduatedLinePropertyValues();
        updateGraduatedLinePreview();
        // Aplicar mudanças em tempo real ao mapa
        applyGraduatedLinePropertiesToMap(true);
      });
    }

    // Padrão personalizado
    const customPatternInput = document.getElementById('graduated-custom-pattern');
    if (customPatternInput) {
      customPatternInput.addEventListener('input', function() {
        updateGraduatedLinePreview();
        // Aplicar mudanças em tempo real ao mapa
        applyGraduatedLinePropertiesToMap(true);
      });
    }

    // Botão de preview do padrão
    const previewBtn = document.getElementById('graduated-preview-pattern-btn');
    if (previewBtn) {
      previewBtn.addEventListener('click', function() {
        updateGraduatedCustomPatternPreview();
      });
    }

    // Botão de aplicar configurações
    const applyBtn = document.getElementById('graduated-apply-line-properties');
    if (applyBtn) {
      applyBtn.addEventListener('click', function() {
        applyGraduatedLineProperties();
      });
    }
  }

  /**
   * Atualiza os valores exibidos dos controles
   */
  function updateGraduatedLinePropertyValues() {
    const opacityInput = document.getElementById('graduated-line-opacity-modal');
    const spacingInput = document.getElementById('graduated-line-spacing-modal');
    
    if (opacityInput) {
      const opacityValue = document.getElementById('graduated-line-opacity-value');
      if (opacityValue) opacityValue.textContent = parseFloat(opacityInput.value).toFixed(2);
    }
    
    if (spacingInput) {
      const spacingValue = document.getElementById('graduated-line-spacing-value');
      if (spacingValue) spacingValue.textContent = spacingInput.value + 'px';
    }
  }

  /**
   * Mostra/oculta o controle de espaçamento baseado no estilo selecionado
   */
  function toggleGraduatedLineSpacingControl(style) {
    const spacingContainer = document.getElementById('graduated-line-spacing-container');
    if (spacingContainer) {
      if (style && style !== '') {
        spacingContainer.style.display = 'block';
      } else {
        spacingContainer.style.display = 'none';
      }
    }
  }

  /**
   * Mostra/oculta o container de padrão personalizado
   */
  function toggleGraduatedCustomPatternContainer(style) {
    const customContainer = document.getElementById('graduated-custom-pattern-container');
    if (customContainer) {
      if (style === 'custom') {
        customContainer.style.display = 'block';
      } else {
        customContainer.style.display = 'none';
      }
    }
  }

  /**
   * Atualiza o preview da linha graduada
   */
  function updateGraduatedLinePreview() {
    const previewContainer = document.getElementById('graduated-line-preview');
    if (!previewContainer) return;
    
    const opacity = document.getElementById('graduated-line-opacity-modal')?.value || '1';
    const style = document.getElementById('graduated-line-style-modal')?.value || '';
    const spacing = document.getElementById('graduated-line-spacing-modal')?.value || '10';
    const customPattern = document.getElementById('graduated-custom-pattern')?.value || '';
    
    // Criar preview SVG
    let dashArray = '';
    if (style && style !== '') {
      if (style === 'custom' && customPattern) {
        dashArray = customPattern;
      } else {
        // Aplicar espaçamento personalizado
        const spacingValue = parseFloat(spacing);
        if (style === '5,5') {
          dashArray = `${spacingValue},${spacingValue}`;
        } else if (style === '10,5') {
          dashArray = `${spacingValue * 2},${spacingValue}`;
        } else if (style === '2,2') {
          dashArray = `${spacingValue * 0.4},${spacingValue * 0.4}`;
        } else if (style === '1,1') {
          dashArray = `${spacingValue * 0.2},${spacingValue * 0.2}`;
        } else if (style === '5,2,1,2') {
          dashArray = `${spacingValue},${spacingValue * 0.4},${spacingValue * 0.2},${spacingValue * 0.4}`;
        } else if (style === '10,2,1,2') {
          dashArray = `${spacingValue * 2},${spacingValue * 0.4},${spacingValue * 0.2},${spacingValue * 0.4}`;
        } else if (style === '15,3,3,3') {
          dashArray = `${spacingValue * 1.5},${spacingValue * 0.3},${spacingValue * 0.3},${spacingValue * 0.3}`;
        } else if (style === '20,5,5,5') {
          dashArray = `${spacingValue * 2},${spacingValue * 0.5},${spacingValue * 0.5},${spacingValue * 0.5}`;
        } else {
          dashArray = style;
        }
      }
    }
    
    // Criar SVG da linha
    const svg = createLinePreviewSVG(dashArray, opacity);
    previewContainer.innerHTML = svg;
  }

  /**
   * Atualiza o preview do padrão personalizado
   */
  function updateGraduatedCustomPatternPreview() {
    const previewContainer = document.getElementById('graduated-custom-pattern-preview');
    if (!previewContainer) return;
    
    const pattern = document.getElementById('graduated-custom-pattern')?.value || '';
    if (!pattern) {
      previewContainer.innerHTML = '<div class="text-muted">Digite um padrão para preview</div>';
      return;
    }
    
    try {
      const parts = pattern.split(',').map(p => parseInt(p.trim()) || 0);
      if (parts.length < 2) {
        previewContainer.innerHTML = '<div class="text-danger">Formato inválido</div>';
        return;
      }
      
      const svg = createLinePreviewSVG(pattern, 1);
      previewContainer.innerHTML = svg;
    } catch (error) {
      previewContainer.innerHTML = '<div class="text-danger">Erro no formato</div>';
    }
  }

  /**
   * Cria SVG para preview da linha
   */
  function createLinePreviewSVG(dashArray, opacity) {
    const width = 300;
    const height = 60;
    const strokeWidth = 3;
    const strokeColor = '#333';
    
    let strokeDasharray = '';
    if (dashArray) {
      strokeDasharray = `stroke-dasharray="${dashArray}"`;
    }
    
    return `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
        <line x1="20" y1="${height/2}" x2="${width-20}" y2="${height/2}" 
              stroke="${strokeColor}" stroke-width="${strokeWidth}" 
              opacity="${opacity}" ${strokeDasharray}/>
      </svg>
    `;
  }

  /**
   * Aplica as propriedades da linha graduada em tempo real ao mapa
   */
  function applyGraduatedLinePropertiesToMap(isPreview = false) {
    console.log(`🎯 applyGraduatedLinePropertiesToMap chamada com isPreview: ${isPreview}`);
    
    if (currentGraduatedClassIndex === null || currentGraduatedClassField === null) {
      console.error(`❌ Variáveis globais não definidas:`, { 
        currentGraduatedClassIndex, 
        currentGraduatedClassField 
      });
      return;
    }
    
    console.log(`✅ Variáveis globais OK:`, { 
      currentGraduatedClassIndex, 
      currentGraduatedClassField 
    });
    
    // Coletar valores dos controles
    const opacity = document.getElementById('graduated-line-opacity-modal')?.value || '1';
    const style = document.getElementById('graduated-line-style-modal')?.value || '';
    const spacing = document.getElementById('graduated-line-spacing-modal')?.value || '10';
    const customPattern = document.getElementById('graduated-custom-pattern')?.value || '';
    
    console.log(`📊 Valores coletados dos controles:`, { opacity, style, spacing, customPattern });
    
    // Calcular estilo final
    const finalStyle = style === 'custom' ? customPattern : style;
    console.log(`🎨 Estilo final calculado: ${finalStyle}`);
    
    // Se for preview, salvar temporariamente para aplicação imediata
    if (isPreview) {
      console.log(`⚡ Aplicando estilo em tempo real...`);
      // Aplicar estilo diretamente ao mapa sem salvar no localStorage
      applyGraduatedStyleToMapLayer(finalStyle, opacity, spacing);
    } else {
      console.log(`💾 Modo não-preview - não aplicando ao mapa`);
    }
  }

  /**
   * Aplica o estilo da linha diretamente à camada do mapa
   */
  function applyGraduatedStyleToMapLayer(style, opacity, spacing) {
    if (!currentLayer || !currentLayerData) return;
    
    // Obter o campo atual da simbologia
    const field = document.getElementById('field-select').value;
    if (!field) return;
    
    // Calcular dashArray baseado no estilo e espaçamento
    let dashArray = '';
    if (style && style !== '') {
      const spacingValue = parseFloat(spacing);
      if (style === '5,5') {
        dashArray = `${spacingValue},${spacingValue}`;
      } else if (style === '10,5') {
        dashArray = `${spacingValue * 2},${spacingValue}`;
      } else if (style === '2,2') {
        dashArray = `${spacingValue * 0.4},${spacingValue * 0.4}`;
      } else if (style === '1,1') {
        dashArray = `${spacingValue * 0.2},${spacingValue * 0.2}`;
      } else if (style === '5,2,1,2') {
        dashArray = `${spacingValue},${spacingValue * 0.4},${spacingValue * 0.2},${spacingValue * 0.4}`;
      } else if (style === '10,2,1,2') {
        dashArray = `${spacingValue * 2},${spacingValue * 0.4},${spacingValue * 0.2},${spacingValue * 0.4}`;
      } else if (style === '15,3,3,3') {
        dashArray = `${spacingValue * 1.5},${spacingValue * 0.3},${spacingValue * 0.3},${spacingValue * 0.3}`;
      } else if (style === '20,5,5,5') {
        dashArray = `${spacingValue * 2},${spacingValue * 0.5},${spacingValue * 0.5},${spacingValue * 0.5}`;
      } else {
        dashArray = style;
      }
    }
    
    // IMPORTANTE: Aplicar estilo APENAS às features da classe selecionada
    console.log(`🎯 Aplicando estilo à classe ${currentGraduatedClassIndex} com:`, { style, opacity, spacing });
    
    currentLayer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.properties) {
        const value = parseFloat(featureLayer.feature.properties[field]);
        if (isNaN(value)) return;
        
        // Encontrar a classe para este valor
        const styleConfig = computeStyle();
        if (!styleConfig || !styleConfig.classes) return;
        
        // Calcular breaks para determinar a classe
        const values = currentLayerData.features
          .map(f => parseFloat(f.properties[field]))
          .filter(v => !isNaN(v))
          .sort((a, b) => a - b);
        
        if (values.length === 0) return;
        
        const min = values[0];
        const max = values[values.length - 1];
        const classes = styleConfig.classes || 5;
        
        // Calcular breaks baseado no método
        let breaks = [];
        if (styleConfig.method === 'equal') {
          const step = (max - min) / classes;
          for (let i = 0; i <= classes; i++) {
            breaks.push(min + (i * step));
          }
        } else if (styleConfig.method === 'quantile') {
          const step = values.length / classes;
          for (let i = 0; i <= classes; i++) {
            const index = Math.floor(i * step);
            breaks.push(values[Math.min(index, values.length - 1)]);
          }
        } else if (styleConfig.method === 'jenks') {
          const step = values.length / classes;
          for (let i = 0; i <= classes; i++) {
            const index = Math.floor(i * step);
            breaks.push(values[Math.min(index, values.length - 1)]);
          }
        } else if (styleConfig.method === 'manual' && styleConfig.breaks) {
          breaks = styleConfig.breaks;
        }
        
        // Encontrar índice da classe
        let classIndex = 0;
        for (let i = 0; i < breaks.length - 1; i++) {
          if (value >= breaks[i] && value < breaks[i + 1]) {
            classIndex = i;
            break;
          }
        }
        
        // Aplicar estilo APENAS se for a classe selecionada
        if (classIndex === parseInt(currentGraduatedClassIndex)) {
          console.log(`✅ Aplicando estilo à feature ${value} da classe ${classIndex}`);
          
          const newStyle = {
            opacity: parseFloat(opacity),
            dashArray: dashArray || undefined
          };
          
          // Aplicar estilo à feature
          featureLayer.setStyle(newStyle);
        } else {
          console.log(`⏭️ Pulando feature ${value} da classe ${classIndex} (não é a classe selecionada ${currentGraduatedClassIndex})`);
        }
      }
    });
    
    // Forçar atualização do mapa
    if (map) {
      map.invalidateSize();
    }
    
    console.log(`🎨 Estilo aplicado com sucesso à classe ${currentGraduatedClassIndex}`);
  }

  /**
   * Aplica as propriedades da linha graduada
   */
  function applyGraduatedLineProperties() {
    if (currentGraduatedClassIndex === null || currentGraduatedClassField === null) {
      showToast('Erro: Classe não selecionada', 'error');
      return;
    }
    
    // Coletar valores dos controles
    const opacity = document.getElementById('graduated-line-opacity-modal')?.value || '1';
    const style = document.getElementById('graduated-line-style-modal')?.value || '';
    const spacing = document.getElementById('graduated-line-spacing-modal')?.value || '10';
    const customPattern = document.getElementById('graduated-custom-pattern')?.value || '';
    
    // Salvar no localStorage
    const finalStyle = style === 'custom' ? customPattern : style;
    
    localStorage.setItem(`graduated_line_opacity_${layerId}_${currentGraduatedClassField}_${currentGraduatedClassIndex}`, opacity);
    localStorage.setItem(`graduated_line_style_${layerId}_${currentGraduatedClassField}_${currentGraduatedClassIndex}`, finalStyle);
    localStorage.setItem(`graduated_line_spacing_${layerId}_${currentGraduatedClassField}_${currentGraduatedClassIndex}`, spacing);
    
    // Aplicar mudanças imediatamente ao mapa
    applyGraduatedStyleToMapLayer(finalStyle, opacity, spacing);
    
    // Atualizar preview do mapa
    renderMapPreview();
    
    // Mostrar mensagem de sucesso
    showToast('Propriedades da linha aplicadas com sucesso!', 'success');
    
    // Fechar modal e remover backdrop
    const modal = bootstrap.Modal.getInstance(document.getElementById('graduatedLinePropertiesModal'));
    if (modal) {
      modal.hide();
    }
    
    // Remover backdrop manualmente se necessário
    setTimeout(() => {
      const backdrop = document.querySelector('.modal-backdrop');
      if (backdrop) {
        backdrop.remove();
      }
      
      // Remover classe 'modal-open' do body
      document.body.classList.remove('modal-open');
      document.body.style.paddingRight = '';
      document.body.style.overflow = '';
    }, 150);
  }

  /**
   * Mostra as propriedades da linha graduada
   */
  function showGraduatedLineProperties() {
    const container = document.getElementById('graduated-line-properties-container');
    if (container) {
      container.classList.remove('d-none');
    }
  }

  /**
   * Oculta as propriedades da linha graduada
   */
  function hideGraduatedLineProperties() {
    const container = document.getElementById('graduated-line-properties-container');
    if (container) {
      container.classList.add('d-none');
    }
  }

  // Inicializar modal quando o documento estiver pronto
  document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 DOM carregado, inicializando modais...');
    
    initializeGraduatedLinePropertiesModal();
    initializeProportionalSizeModal();
    
    // Event listener para limpar backdrop quando modal for fechado
    const modal = document.getElementById('graduatedLinePropertiesModal');
    if (modal) {
      modal.addEventListener('hidden.bs.modal', function() {
        // Remover backdrop manualmente
        const backdrop = document.querySelector('.modal-backdrop');
        if (backdrop) {
          backdrop.remove();
        }
        
        // Limpar classes e estilos do body
        document.body.classList.remove('modal-open');
        document.body.style.paddingRight = '';
        document.body.style.overflow = '';
      });
    }
    
    console.log('✅ Modais inicializados com sucesso');
  });
  
  // Função para limpar todos os timeouts relacionados ao tamanho proporcional
  function clearAllProportionalSizeTimeouts() {
    console.log('🧹 Limpando todos os timeouts de tamanho proporcional...');
    
    const timeouts = [
      'proportionalSizeMapUpdateTimeout',
      'toggleProportionalSizeTimeout',
      'applyVisibilityTimeout',
      'initializeProportionalSizeTimeout',
      'sliderUpdateTimeout'
    ];
    
    timeouts.forEach(timeoutName => {
      if (window[timeoutName]) {
        clearTimeout(window[timeoutName]);
        window[timeoutName] = null;
        console.log(`✅ Timeout ${timeoutName} limpo`);
      }
    });
    
    console.log('✅ Todos os timeouts limpos com sucesso');
  }
  
  // Limpar todos os timeouts quando a página for descarregada
  window.addEventListener('beforeunload', function() {
    clearAllProportionalSizeTimeouts();
  });

  // ========================================
  // FUNÇÕES PARA O MODAL DE TAMANHO PROPORCIONAL
  // ========================================

  /**
   * Inicializa o modal de tamanho proporcional
   */
  function initializeProportionalSizeModal() {
    console.log('🚀 Inicializando modal de tamanho proporcional...');
    
    // Verificar se os elementos existem
    const minWeightSlider = document.getElementById('min-line-weight');
    const maxWeightSlider = document.getElementById('max-line-weight');
    const toggleSwitch = document.getElementById('proportional-size-toggle');
    
    if (!minWeightSlider || !maxWeightSlider || !toggleSwitch) {
      console.error('❌ Elementos do modal de tamanho proporcional não encontrados');
      return;
    }
    
    console.log('✅ Elementos encontrados, configurando valores iniciais...');
    
    // Sincronizar currentLayerData com layerData
    if (layerData && !currentLayerData) {
      currentLayerData = layerData;
      console.log('🔄 currentLayerData sincronizado com layerData');
    }
    
    // Carregar valores salvos
    loadProportionalSizeSettings();
    
    // Atualizar preview inicial
    updateProportionalSizeValues();
    updateProportionalSizePreview();
    toggleProportionalSizeContent();
    
    // IMPORTANTE: Verificar se deve mostrar o modal baseado no estado atual
    // Usar debounce para evitar múltiplas execuções
    if (window.initializeProportionalSizeTimeout) {
      clearTimeout(window.initializeProportionalSizeTimeout);
    }
    
    window.initializeProportionalSizeTimeout = setTimeout(() => {
      checkAndShowProportionalSizeModal();
    }, 100);
    
    console.log('✅ Modal de tamanho proporcional inicializado com sucesso');
    
    // Configurar event listeners específicos para os sliders
    if (minWeightSlider) {
      minWeightSlider.addEventListener('input', function() {
        console.log('🎛️ Slider min-weight alterado:', this.value);
        updateProportionalSizeValues();
        updateProportionalSizePreview();
        
        // Salvar e aplicar automaticamente
        saveProportionalSizeSettings();
      });
    }
    
    if (maxWeightSlider) {
      maxWeightSlider.addEventListener('input', function() {
        console.log('🎛️ Slider max-weight alterado:', this.value);
        updateProportionalSizeValues();
        updateProportionalSizePreview();
        
        // Salvar e aplicar automaticamente
        saveProportionalSizeSettings();
      });
    }
  }

  /**
   * Atualiza os valores exibidos dos sliders
   */
  function updateProportionalSizeValues() {
    const minWeightSlider = document.getElementById('min-line-weight');
    const maxWeightSlider = document.getElementById('max-line-weight');
    const minWeightValue = document.getElementById('min-line-weight-value');
    const maxWeightValue = document.getElementById('max-line-weight-value');
    
    if (minWeightSlider && minWeightValue) {
      minWeightValue.textContent = minWeightSlider.value + 'px';
      console.log('📏 Valor min-weight atualizado:', minWeightSlider.value + 'px');
    }
    
    if (maxWeightSlider && maxWeightValue) {
      maxWeightValue.textContent = maxWeightSlider.value + 'px';
      console.log('📏 Valor max-weight atualizado:', maxWeightSlider.value + 'px');
    }
    
    // Validar que o máximo seja maior que o mínimo
    if (minWeightSlider && maxWeightSlider) {
      const minVal = parseFloat(minWeightSlider.value);
      const maxVal = parseFloat(maxWeightSlider.value);
      
      if (maxVal <= minVal) {
        maxWeightSlider.value = minVal + 1;
        if (maxWeightValue) {
          maxWeightValue.textContent = maxWeightSlider.value + 'px';
        }
        console.log('⚠️ Valor máximo ajustado para:', maxWeightSlider.value + 'px');
      }
    }
  }

  /**
   * Atualiza o preview da distribuição de tamanhos
   */
  function updateProportionalSizePreview() {
    const previewContainer = document.getElementById('proportional-size-preview');
    if (!previewContainer) {
      console.log('⚠️ Container de preview não encontrado');
      return;
    }
    
    const minWeight = parseFloat(document.getElementById('min-line-weight')?.value || '2');
    const maxWeight = parseFloat(document.getElementById('max-line-weight')?.value || '8');
    
    console.log('🎨 Atualizando preview com pesos:', { minWeight, maxWeight });
    
    // Criar preview SVG com linhas de diferentes espessuras
    const svg = createProportionalSizePreviewSVG(minWeight, maxWeight);
    previewContainer.innerHTML = svg;
    
    console.log('✅ Preview atualizado com sucesso');
  }

  /**
   * Cria SVG para preview da distribuição de tamanhos
   */
  function createProportionalSizePreviewSVG(minWeight, maxWeight) {
    const width = 400;
    const height = 80;
    const strokeColor = '#17a2b8';
    
    // Simular 5 classes com tamanhos proporcionais
    const classes = 5;
    let svgContent = '';
    
    for (let i = 0; i < classes; i++) {
      const percent = (i / (classes - 1)) * 100; // 0% a 100%
      const weight = minWeight + (percent / 100) * (maxWeight - minWeight);
      const y = 20 + (i * 15);
      const lineLength = 300;
      
      svgContent += `
        <line x1="50" y1="${y}" x2="${50 + lineLength}" y2="${y}" 
               stroke="${strokeColor}" stroke-width="${weight}" 
               opacity="0.8"/>
        <text x="370" y="${y + 4}" font-family="Arial" font-size="12" 
               fill="#495057" text-anchor="end">
          ${weight.toFixed(1)}px
        </text>
      `;
    }
    
    return `
      <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
        ${svgContent}
        <text x="200" y="75" font-family="Arial" font-size="10" 
               fill="#6c757d" text-anchor="middle">Distribuição Proporcional de Espessuras</text>
      </svg>
    `;
  }

  /**
   * Aplica o tamanho proporcional ao mapa
   */
  // Sistema de controle global simplificado
  if (!window.proportionalSizeControl) {
    window.proportionalSizeControl = {
      isApplying: false,
      lastUpdate: 0,
      updateCount: 0,
      startTime: Date.now()
    };
  }
  
  // Função para monitorar performance das atualizações
  function logProportionalSizePerformance(action) {
    const now = Date.now();
    const elapsed = now - window.proportionalSizeControl.startTime;
    window.proportionalSizeControl.updateCount++;
    
    console.log(`📊 Performance: ${action} | Total de atualizações: ${window.proportionalSizeControl.updateCount} | Tempo decorrido: ${elapsed}ms`);
  }
  
  function applyProportionalSizeToMap() {
    // Evitar múltiplas execuções simultâneas
    if (window.proportionalSizeControl.isApplying) {
      console.log('⏳ Já está aplicando tamanho proporcional, aguardando...');
      return;
    }
    
    window.proportionalSizeControl.isApplying = true;
    console.log('🎯 applyProportionalSizeToMap chamada');
    
    // Monitorar performance
    logProportionalSizePerformance('Aplicação de tamanho proporcional');
    
    // Verificar se o toggle está ativado
    const toggle = document.getElementById('proportional-size-toggle');
    if (!toggle || !toggle.checked) {
      console.log('❌ Toggle de tamanho proporcional não está ativado');
      window.proportionalSizeControl.isApplying = false;
      return;
    }
    
    // Verificar se é simbologia graduada e geometria linha
    const styleType = document.getElementById('style-type')?.value;
    const geomType = document.getElementById('geom-type')?.value;
    
    console.log('📊 Tipo de simbologia:', styleType, 'Geometria:', geomType);
    
    if (styleType !== 'graduated' || geomType !== 'line') {
      console.log('❌ Não é simbologia graduada + linha');
      return;
    }
    
    // Obter configurações de tamanho
    const minWeight = parseFloat(document.getElementById('min-line-weight')?.value || '2');
    const maxWeight = parseFloat(document.getElementById('max-line-weight')?.value || '8');
    
    console.log('⚖️ Configurações de peso:', { minWeight, maxWeight });
    
    // Obter o campo atual da simbologia
    const field = document.getElementById('field-select')?.value;
    if (!field) {
      console.log('❌ Campo não selecionado');
      return;
    }
    
    // Sincronizar currentLayerData com layerData se necessário
    if (!currentLayerData && layerData) {
      currentLayerData = layerData;
      console.log('🔄 currentLayerData sincronizado com layerData');
    }
    
    // Verificar se temos dados da camada
    if (!currentLayerData || !currentLayerData.features) {
      console.log('❌ Dados da camada não disponíveis');
      return;
    }
    
    // Calcular estatísticas do campo
    const values = currentLayerData.features
      .map(f => parseFloat(f.properties[field]))
      .filter(v => !isNaN(v))
      .sort((a, b) => a - b);
    
    if (values.length === 0) {
      console.log('Nenhum valor válido encontrado');
      return;
    }
    
    console.log('Valores encontrados:', values.length, 'Min:', values[0], 'Max:', values[values.length - 1]);
    
    const min = values[0];
    const max = values[values.length - 1];
    const totalRange = max - min;
    
    // Verificar se temos a camada atual
    if (!currentLayer) {
      console.log('Camada atual não disponível');
      return;
    }
    
    console.log('Aplicando tamanho proporcional a', currentLayer.getLayers().length, 'features');
    
    // Aplicar tamanho proporcional a cada feature
    let featuresUpdated = 0;
    currentLayer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.properties) {
        const value = parseFloat(featureLayer.feature.properties[field]);
        if (isNaN(value)) return;
        
        // Calcular percentual do valor em relação ao total
        const percent = totalRange > 0 ? ((value - min) / totalRange) * 100 : 0;
        
        // Calcular peso proporcional
        const proportionalWeight = minWeight + (percent / 100) * (maxWeight - minWeight);
        
        console.log(`Feature ${value} -> Percentual: ${percent.toFixed(1)}% -> Peso: ${proportionalWeight.toFixed(1)}px`);
        
        // Aplicar novo peso à feature
        const currentStyle = featureLayer.options || {};
        const newStyle = {
          ...currentStyle,
          weight: proportionalWeight
        };
        
        try {
          featureLayer.setStyle(newStyle);
          featuresUpdated++;
        } catch (error) {
          console.error('Erro ao aplicar estilo:', error);
        }
      }
    });
    
    console.log('Features atualizadas:', featuresUpdated);
    
    // Atualizar a legenda com os novos tamanhos
    updateLegendWithProportionalSizes(minWeight, maxWeight, values);
    
    // Salvar configurações
    saveProportionalSizeSettings();
    
    // Forçar atualização do mapa apenas uma vez
    if (map) {
      requestAnimationFrame(() => {
        map.invalidateSize();
        console.log('🗺️ Mapa atualizado com requestAnimationFrame');
      });
    }
    
    // Atualizar mapa de prévia imediatamente
    if (typeof renderMapPreview === 'function') {
      renderMapPreview();
      console.log('✅ Mapa de prévia atualizado imediatamente');
    }
    
    // Atualizar preview apenas se necessário
    if (typeof updateProportionalSizePreview === 'function') {
      requestAnimationFrame(() => {
        updateProportionalSizePreview();
        console.log('✅ Preview atualizado com requestAnimationFrame');
      });
    }
    
    // Resetar flag de controle
    window.proportionalSizeControl.isApplying = false;
    console.log('✅ Aplicação de tamanho proporcional concluída');
  }

  /**
   * Reseta o tamanho proporcional no mapa
   */
  function resetProportionalSizeOnMap() {
    if (!currentLayer) {
      console.log('⚠️ currentLayer não disponível para reset');
      return;
    }
    
    console.log('🔄 Resetando tamanho proporcional no mapa...');
    
    // Aplicar peso padrão a todas as features
    let featuresReset = 0;
    currentLayer.eachLayer(featureLayer => {
      if (featureLayer.feature) {
        const currentStyle = featureLayer.options || {};
        const newStyle = {
          ...currentStyle,
          weight: 2 // Peso padrão
        };
        
        featureLayer.setStyle(newStyle);
        featuresReset++;
      }
    });
    
    console.log(`✅ ${featuresReset} features resetadas para peso padrão`);
    
    // Forçar atualização do mapa apenas uma vez
    if (map) {
      requestAnimationFrame(() => {
        map.invalidateSize();
        console.log('🗺️ Mapa atualizado após reset com requestAnimationFrame');
      });
    }
    
    // Atualizar mapa de prévia imediatamente
    if (typeof renderMapPreview === 'function') {
      renderMapPreview();
      console.log('✅ Mapa de prévia atualizado após reset imediatamente');
    }
  }

  /**
   * Salva as configurações de tamanho proporcional
   */
  function saveProportionalSizeSettings() {
    const minWeight = document.getElementById('min-line-weight')?.value || '2';
    const maxWeight = document.getElementById('max-line-weight')?.value || '8';
    const isEnabled = document.getElementById('proportional-size-toggle')?.checked || false;
    
    console.log('💾 Salvando configurações de tamanho proporcional:', { minWeight, maxWeight, isEnabled, layerId });
    
    // Salvar no localStorage com chaves específicas para esta camada
    localStorage.setItem(`proportional_size_enabled_${layerId}`, isEnabled);
    localStorage.setItem(`proportional_size_min_weight_${layerId}`, minWeight);
    localStorage.setItem(`proportional_size_max_weight_${layerId}`, maxWeight);
    
    // Salvar também com chave genérica para compatibilidade
    localStorage.setItem('proportional_size_enabled', isEnabled);
    localStorage.setItem('proportional_size_min_weight', minWeight);
    localStorage.setItem('proportional_size_max_weight', maxWeight);
    
    console.log('✅ Configurações salvas com sucesso no localStorage');
    
    // Verificar se foram salvas corretamente
    const savedEnabled = localStorage.getItem(`proportional_size_enabled_${layerId}`);
    const savedMinWeight = localStorage.getItem(`proportional_size_min_weight_${layerId}`);
    const savedMaxWeight = localStorage.getItem(`proportional_size_max_weight_${layerId}`);
    
    console.log('🔍 Configurações verificadas no localStorage:', {
      enabled: savedEnabled,
      minWeight: savedMinWeight,
      maxWeight: savedMaxWeight
    });
    
    // Aplicar imediatamente se estiver ativado (com debounce)
    if (isEnabled) {
      console.log('🚀 Aplicando configurações salvas imediatamente...');
      // Usar requestAnimationFrame para sincronizar com o ciclo de renderização
      requestAnimationFrame(() => {
        applyProportionalSizeToMap();
      });
    }
  }

  /**
   * Carrega as configurações de tamanho proporcional
   */
  function loadProportionalSizeSettings() {
    console.log('📥 Carregando configurações de tamanho proporcional para layerId:', layerId);
    
    // Tentar carregar configurações específicas da camada primeiro
    let minWeight = localStorage.getItem(`proportional_size_min_weight_${layerId}`);
    let maxWeight = localStorage.getItem(`proportional_size_max_weight_${layerId}`);
    let isEnabled = localStorage.getItem(`proportional_size_enabled_${layerId}`);
    
    // Se não houver configurações específicas da camada, usar configurações genéricas
    if (!minWeight) {
      minWeight = localStorage.getItem('proportional_size_min_weight') || '2';
    }
    if (!maxWeight) {
      maxWeight = localStorage.getItem('proportional_size_max_weight') || '8';
    }
    if (isEnabled === null) {
      isEnabled = localStorage.getItem('proportional_size_enabled') || 'false';
    }
    
    // Converter para boolean
    isEnabled = isEnabled === 'true';
    
    console.log('🔍 Configurações carregadas:', { minWeight, maxWeight, isEnabled, layerId });
    
    const minWeightSlider = document.getElementById('min-line-weight');
    const maxWeightSlider = document.getElementById('max-line-weight');
    const toggleSwitch = document.getElementById('proportional-size-toggle');
    
    if (minWeightSlider) {
      minWeightSlider.value = minWeight;
      console.log('✅ Slider min-weight definido para:', minWeight);
    }
    
    if (maxWeightSlider) {
      maxWeightSlider.value = maxWeight;
      console.log('✅ Slider max-weight definido para:', maxWeight);
    }
    
    if (toggleSwitch) {
      toggleSwitch.checked = isEnabled;
      console.log('✅ Toggle definido para:', isEnabled);
    }
    
    // Atualizar valores exibidos e preview
    updateProportionalSizeValues();
    updateProportionalSizePreview();
    toggleProportionalSizeContent();
    
    // Se estiver ativado, aplicar imediatamente
    if (isEnabled) {
      console.log('🚀 Configuração ativada, aplicando tamanho proporcional...');
      setTimeout(() => {
        applyProportionalSizeToMap();
      }, 500);
    }
  }

  /**
   * Mostra/oculta o conteúdo do modal de tamanho proporcional
   */
  function toggleProportionalSizeContent() {
    const content = document.getElementById('proportional-size-content');
    const toggle = document.getElementById('proportional-size-toggle');
    
    if (content && toggle) {
      if (toggle.checked) {
        content.style.display = 'block';
        console.log('✅ Conteúdo do modal de tamanho proporcional mostrado');
      } else {
        content.style.display = 'none';
        console.log('❌ Conteúdo do modal de tamanho proporcional ocultado');
      }
    } else {
      console.log('⚠️ Elementos do modal não encontrados');
    }
  }

  /**
   * Verifica e mostra o modal de tamanho proporcional se necessário
   */
  function checkAndShowProportionalSizeModal() {
    console.log('🔍 Verificando se deve mostrar modal de tamanho proporcional...');
    
    const styleType = document.getElementById('style-type')?.value;
    const geomType = document.getElementById('geom-type')?.value;
    const blockProportionalSize = document.getElementById('block-proportional-size');
    
    console.log('📊 Estado atual:', { styleType, geomType });
    
    if (!blockProportionalSize) {
      console.error('❌ Elemento block-proportional-size não encontrado');
      return;
    }
    
    if (styleType === 'graduated' && geomType === 'line') {
      console.log('✅ Condições atendidas, mostrando modal...');
      blockProportionalSize.style.display = 'block';
      
      // Carregar configurações salvas
      loadProportionalSizeSettings();
      
      // Verificar se deve aplicar tamanho proporcional automaticamente
      const toggle = document.getElementById('proportional-size-toggle');
      if (toggle && toggle.checked) {
        console.log('🚀 Toggle ativado, aplicando tamanho proporcional...');
        // Usar requestAnimationFrame para sincronizar com o ciclo de renderização
        requestAnimationFrame(() => {
          applyProportionalSizeToMap();
        });
      }
    } else {
      console.log('❌ Condições não atendidas, ocultando modal...');
      blockProportionalSize.style.display = 'none';
      
      // Se não for graduada + linha, desativar toggle
      const toggle = document.getElementById('proportional-size-toggle');
      if (toggle && toggle.checked) {
        toggle.checked = false;
        toggleProportionalSizeContent();
        console.log('🔄 Toggle desativado automaticamente');
      }
    }
  }


  
  /**
   * Mostra/oculta o modal de tamanho proporcional baseado no tipo de simbologia e geometria
   */
  function toggleProportionalSizeModal() {
    console.log('🔄 toggleProportionalSizeModal chamada');
    
    // Usar debounce para evitar múltiplas execuções
    if (window.toggleProportionalSizeTimeout) {
      clearTimeout(window.toggleProportionalSizeTimeout);
    }
    
    window.toggleProportionalSizeTimeout = setTimeout(() => {
      checkAndShowProportionalSizeModal();
    }, 100);
  }
  
  /**
   * Mostra/oculta o modal de tamanho proporcional dos pontos baseado no tipo de simbologia e geometria
   */
  function checkAndShowProportionalPointSizeModal() {
    const styleType = document.getElementById('style-type')?.value;
    const geomType = document.getElementById('geom-type')?.value;
    
    console.log('🔍 Verificando modal de tamanho proporcional dos pontos:', { styleType, geomType });
    
    const blockProportionalPointSize = document.getElementById('block-proportional-point-size');
    if (!blockProportionalPointSize) {
      console.error('❌ Elemento block-proportional-point-size não encontrado');
      return;
    }
    
    // Mostrar apenas para simbologia graduada + geometria ponto
    const shouldShow = styleType === 'graduated' && geomType === 'point';
    console.log('✅ Modal de tamanho proporcional dos pontos:', { shouldShow });
    
    if (shouldShow) {
      blockProportionalPointSize.style.display = 'block';
      blockProportionalPointSize.classList.remove('d-none');
    } else {
      blockProportionalPointSize.style.display = 'none';
      blockProportionalPointSize.classList.add('d-none');
    }
  }

  /**
   * Atualiza a legenda com os tamanhos proporcionais das linhas
   */
  function updateLegendWithProportionalSizes(minWeight, maxWeight, values) {
    // Obter o campo atual da simbologia
    const field = document.getElementById('field-select')?.value;
    if (!field) return;
    
    // Obter as classes da legenda graduada
    const legendItems = document.querySelectorAll('.graduated-class-item');
    if (legendItems.length === 0) return;
    
    // Calcular estatísticas para distribuição proporcional
    const min = values[0];
    const max = values[values.length - 1];
    const totalRange = max - min;
    
    // Atualizar cada item da legenda
    legendItems.forEach((item, index) => {
      // IMPORTANTE: Calcular peso proporcional baseado nos valores reais das features
      // Não na posição da classe, mas no valor representativo da classe
      
      // Obter o valor representativo da classe (usar o valor médio ou o valor do break)
      const classIndex = index;
      const totalClasses = legendItems.length;
      
      // Calcular o valor representativo da classe baseado nos breaks
      // Para isso, precisamos dos breaks calculados na função applyGraduatedStyle
      const style = computeStyle();
      let representativeValue = 0;
      
      if (style && style.field === field) {
        // Tentar obter o valor representativo da classe
        // Se não conseguirmos, usar a posição como fallback
        const classRangeElement = item.querySelector('.class-range');
        if (classRangeElement) {
          const rangeText = classRangeElement.textContent;
          // Extrair valor médio do intervalo (ex: "10-20" -> 15)
          const rangeMatch = rangeText.match(/(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)/);
          if (rangeMatch) {
            const minVal = parseFloat(rangeMatch[1]);
            const maxVal = parseFloat(rangeMatch[2]);
            representativeValue = (minVal + maxVal) / 2;
          }
        }
      }
      
      // Se não conseguimos o valor real, usar a posição como fallback
      if (representativeValue === 0) {
        const percent = (classIndex / (totalClasses - 1)) * 100;
        representativeValue = min + (percent / 100) * totalRange;
      }
      
      // Calcular percentual baseado no valor real da classe
      const valuePercent = totalRange > 0 ? ((representativeValue - min) / totalRange) * 100 : 0;
      
      // Calcular peso proporcional baseado no valor real
      const proportionalWeight = minWeight + (valuePercent / 100) * (maxWeight - minWeight);
      
      // Atualizar o indicador visual de peso na legenda
      let weightIndicator = item.querySelector('.line-weight-indicator');
      if (!weightIndicator) {
        // Criar indicador se não existir
        weightIndicator = document.createElement('div');
        weightIndicator.className = 'line-weight-indicator';
        weightIndicator.style.cssText = `
          width: ${proportionalWeight}px;
          height: 4px;
          background: #17a2b8;
          border-radius: 2px;
          margin: 2px 0;
          transition: all 0.3s ease;
        `;
        
        // Inserir após o nome da classe
        const className = item.querySelector('.class-name');
        if (className) {
          className.parentNode.insertBefore(weightIndicator, className.nextSibling);
        }
      } else {
        // Atualizar o indicador existente
        weightIndicator.style.width = `${proportionalWeight}px`;
      }
      
      // Adicionar tooltip com informações detalhadas
      weightIndicator.title = `Espessura: ${proportionalWeight.toFixed(1)}px | Percentual: ${valuePercent.toFixed(1)}%`;
      
      // Atualizar o texto da classe para mostrar o peso
      const classValue = item.querySelector('.class-value');
      if (classValue) {
        const originalText = classValue.textContent;
        const weightText = ` (${proportionalWeight.toFixed(1)}px)`;
        
        // Remover peso anterior se existir
        if (originalText.includes('px)')) {
          classValue.textContent = originalText.replace(/\s*\(\d+\.?\d*px\)/, '') + weightText;
        } else {
          classValue.textContent = originalText + weightText;
        }
      }
    });
    
    // Adicionar legenda explicativa dos tamanhos
    addProportionalSizeLegend(minWeight, maxWeight);
  }

  /**
   * Adiciona legenda explicativa dos tamanhos proporcionais
   */
  function addProportionalSizeLegend(minWeight, maxWeight) {
    // Remover legenda anterior se existir
    const existingLegend = document.getElementById('proportional-size-legend');
    if (existingLegend) {
      existingLegend.remove();
    }
    
    // Criar nova legenda
    const legendContainer = document.createElement('div');
    legendContainer.id = 'proportional-size-legend';
    legendContainer.className = 'mt-3 p-3 bg-light border rounded';
    legendContainer.innerHTML = `
      <div class="d-flex align-items-center justify-content-between mb-2">
        <h6 class="mb-0 text-info">
          <i class="fas fa-arrows-alt-v"></i> Legenda de Espessuras
        </h6>
        <small class="text-muted">Tamanho Proporcional</small>
      </div>
      <div class="row g-2">
        <div class="col-md-6">
          <div class="d-flex align-items-center gap-2">
            <div class="line-weight-indicator" style="width: ${minWeight}px; height: 4px; background: #17a2b8; border-radius: 2px;"></div>
            <small class="text-muted">Mínimo: ${minWeight}px</small>
          </div>
        </div>
        <div class="col-md-6">
          <div class="d-flex align-items-center gap-2">
            <div class="line-weight-indicator" style="width: ${maxWeight}px; height: 4px; background: #17a2b8; border-radius: 2px;"></div>
            <small class="text-muted">Máximo: ${maxWeight}px</small>
          </div>
        </div>
      </div>
      <small class="text-muted">
        <i class="fas fa-info-circle"></i> 
        As espessuras são calculadas proporcionalmente ao percentual dos dados em cada classe.
      </small>
    `;
    
    // Inserir após a legenda principal
    const legendSection = document.querySelector('#block-legend');
    if (legendSection) {
      legendSection.appendChild(legendContainer);
    }
  }

  /**
   * Reseta o tamanho proporcional no mapa e na legenda
   */
  function resetProportionalSizeOnMap() {
    if (!currentLayer) return;
    
    // Aplicar peso padrão a todas as features
    currentLayer.eachLayer(featureLayer => {
      if (featureLayer.feature) {
        const currentStyle = featureLayer.options || {};
        const newStyle = {
          ...currentStyle,
          weight: 2 // Peso padrão
        };
        
        featureLayer.setStyle(newStyle);
      }
    });
    
    // Remover indicadores de peso da legenda
    const weightIndicators = document.querySelectorAll('.line-weight-indicator');
    weightIndicators.forEach(indicator => {
      indicator.remove();
    });
    
    // Remover legenda explicativa
    const proportionalLegend = document.getElementById('proportional-size-legend');
    if (proportionalLegend) {
      proportionalLegend.remove();
    }
    
    // Limpar pesos dos textos das classes
    const classValues = document.querySelectorAll('.class-value');
    classValues.forEach(classValue => {
      if (classValue.textContent.includes('px)')) {
        classValue.textContent = classValue.textContent.replace(/\s*\(\d+\.?\d*px\)/, '');
      }
    });
    
    // Forçar atualização do mapa
    if (map) {
      map.invalidateSize();
    }
  }

  /**
   * Força a aplicação do tamanho proporcional quando necessário
   */
  function forceApplyProportionalSize() {
    console.log('💪 Forçando aplicação do tamanho proporcional...');
    
    // Verificar se o toggle está ativado
    const toggle = document.getElementById('proportional-size-toggle');
    if (!toggle || !toggle.checked) {
      console.log('❌ Toggle não está ativado, saindo...');
      return;
    }
    
    // Verificar se é simbologia graduada e geometria linha
    const styleType = document.getElementById('style-type')?.value;
    const geomType = document.getElementById('geom-type')?.value;
    
    if (styleType === 'graduated' && geomType === 'line') {
      console.log('✅ Condições atendidas, aplicando tamanho proporcional...');
      // Usar requestAnimationFrame para sincronizar com o ciclo de renderização
      requestAnimationFrame(() => {
        applyProportionalSizeToMap();
      });
    } else {
      console.log('❌ Condições não atendidas:', { styleType, geomType });
    }
  }

  // Event listeners para mudanças de tipo de simbologia e geometria
  document.addEventListener('change', function(e) {
    if (e.target.id === 'style-type' || e.target.id === 'geom-type') {
      console.log('🔄 Mudança detectada:', e.target.id, 'valor:', e.target.value);
      
      toggleProportionalSizeModal();
      
      // Se mudou para graduada + linha, verificar se deve aplicar tamanho proporcional
      if (e.target.value === 'graduated' || e.target.value === 'line') {
        console.log('🎯 Verificando se deve aplicar tamanho proporcional...');
        setTimeout(() => {
          forceApplyProportionalSize();
        }, 200);
      }
      
      // Se mudou para graduada + ponto, verificar se deve aplicar tamanho proporcional dos pontos
      if (e.target.value === 'graduated' || e.target.value === 'point') {
        console.log('🎯 Verificando se deve aplicar tamanho proporcional dos pontos...');
        setTimeout(() => {
          forceApplyProportionalPointSize();
        }, 200);
      }
    }
  });

  // Event listener para mudanças nos sliders de peso - aplicação imediata
  document.addEventListener('input', function(e) {
    if (e.target.id === 'min-line-weight' || e.target.id === 'max-line-weight') {
      console.log('🎛️ Slider alterado:', e.target.id, 'valor:', e.target.value);
      
      // Atualizar valores exibidos imediatamente
      updateProportionalSizeValues();
      updateProportionalSizePreview();
      
      // Se o toggle estiver ativado, aplicar mudanças imediatamente
      const toggle = document.getElementById('proportional-size-toggle');
      if (toggle && toggle.checked) {
        console.log('⚡ Aplicando mudanças imediatamente...');
        
        // Forçar atualização do mapa de prévia para aplicar mudanças
        if (typeof renderMapPreview === 'function') {
          console.log('🔄 Chamando renderMapPreview para aplicar mudanças...');
          
          // Forçar atualização imediata
          setTimeout(() => {
            renderMapPreview();
            console.log('✅ renderMapPreview executado após timeout');
            
            // Verificar se as mudanças foram aplicadas
            setTimeout(() => {
              console.log('🔍 Verificando se as mudanças foram aplicadas...');
              if (currentLayer) {
                let featuresWithProportionalWeight = 0;
                currentLayer.eachLayer(featureLayer => {
                  if (featureLayer.options && featureLayer.options.weight) {
                    console.log(`Feature weight: ${featureLayer.options.weight}`);
                    featuresWithProportionalWeight++;
                  }
                });
                console.log(`✅ ${featuresWithProportionalWeight} features com peso proporcional aplicado`);
              }
            }, 100);
          }, 50);
        } else {
          console.log('⚠️ renderMapPreview não disponível, chamando applyProportionalSizeToMap...');
          applyProportionalSizeToMap();
        }
      }
      
      // Salvar configurações com debounce
      if (window.sliderUpdateTimeout) {
        clearTimeout(window.sliderUpdateTimeout);
      }
      window.sliderUpdateTimeout = setTimeout(() => {
        saveProportionalSizeSettings();
      }, 300);
    }
    
    // Event listener para mudanças nos sliders de raio dos pontos - aplicação imediata
    if (e.target.id === 'min-point-radius' || e.target.id === 'max-point-radius') {
      console.log('🎛️ Slider de raio dos pontos alterado:', e.target.id, 'valor:', e.target.value);
      
      // Atualizar valores exibidos imediatamente
      updateProportionalPointSizeValues();
      updateProportionalPointSizePreview();
      
      // Se o toggle estiver ativado, aplicar mudanças imediatamente
      const toggle = document.getElementById('proportional-point-size-toggle');
      if (toggle && toggle.checked) {
        console.log('⚡ Aplicando mudanças imediatamente...');
        
        // Forçar atualização do mapa de prévia para aplicar mudanças
        if (typeof renderMapPreview === 'function') {
          console.log('🔄 Chamando renderMapPreview para aplicar mudanças...');
          
          // Forçar atualização imediata
          setTimeout(() => {
            renderMapPreview();
            console.log('✅ renderMapPreview executado após timeout');
            
            // Verificar se as mudanças foram aplicadas
            setTimeout(() => {
              console.log('🔍 Verificando se as mudanças foram aplicadas...');
              if (currentLayer) {
                let featuresWithProportionalRadius = 0;
                currentLayer.eachLayer(featureLayer => {
                  if (featureLayer.options && featureLayer.options.radius) {
                    console.log(`Feature radius: ${featureLayer.options.radius}`);
                    featuresWithProportionalRadius++;
                  }
                });
                console.log(`✅ ${featuresWithProportionalRadius} features com raio proporcional aplicado`);
              }
            }, 100);
          }, 50);
        } else {
          console.log('⚠️ renderMapPreview não disponível, chamando applyProportionalPointSizeToMap...');
          applyProportionalPointSizeToMap();
        }
      }
      
      // Salvar configurações com debounce
      if (window.pointSliderUpdateTimeout) {
        clearTimeout(window.pointSliderUpdateTimeout);
      }
      window.pointSliderUpdateTimeout = setTimeout(() => {
        saveProportionalPointSizeSettings();
      }, 300);
    }
  });

  // Event listener para mudanças no toggle
  document.addEventListener('change', function(e) {
    if (e.target.id === 'proportional-size-toggle') {
      console.log('🔄 Toggle de tamanho proporcional alterado:', e.target.checked);
      
      if (e.target.checked) {
        // Ativar tamanho proporcional
        console.log('✅ Ativando tamanho proporcional...');
        toggleProportionalSizeContent();
        requestAnimationFrame(() => {
          applyProportionalSizeToMap();
        });
      } else {
        // Desativar tamanho proporcional
        console.log('❌ Desativando tamanho proporcional...');
        toggleProportionalSizeContent();
        resetProportionalSizeOnMap();
      }
      
      // Salvar configuração
      saveProportionalSizeSettings();
    }
    
    // Event listener para mudanças no toggle de tamanho proporcional dos pontos
    if (e.target.id === 'proportional-point-size-toggle') {
      console.log('🔄 Toggle de tamanho proporcional dos pontos alterado:', e.target.checked);
      
      if (e.target.checked) {
        // Ativar tamanho proporcional dos pontos
        console.log('✅ Ativando tamanho proporcional dos pontos...');
        toggleProportionalPointSizeContent();
        requestAnimationFrame(() => {
          applyProportionalPointSizeToMap();
        });
      } else {
        // Desativar tamanho proporcional dos pontos
        console.log('❌ Desativando tamanho proporcional dos pontos...');
        toggleProportionalPointSizeContent();
        resetProportionalPointSizeOnMap();
      }
      
      // Salvar configuração
      saveProportionalPointSizeSettings();
    }
  });
  
  // Funções auxiliares para tamanho proporcional dos pontos
  function toggleProportionalPointSizeContent() {
    const content = document.getElementById('proportional-point-size-content');
    if (content) {
      content.style.display = content.style.display === 'none' ? 'block' : 'none';
    }
  }
  
  function updateProportionalPointSizeValues() {
    const minRadius = document.getElementById('min-point-radius')?.value || 4;
    const maxRadius = document.getElementById('max-point-radius')?.value || 12;
    
    const minValue = document.getElementById('min-point-radius-value');
    const maxValue = document.getElementById('max-point-radius-value');
    
    if (minValue) minValue.textContent = `${minRadius}px`;
    if (maxValue) maxValue.textContent = `${maxRadius}px`;
  }
  
  function updateProportionalPointSizePreview() {
    const preview = document.getElementById('proportional-point-size-preview');
    if (!preview) return;
    
    const minRadius = parseFloat(document.getElementById('min-point-radius')?.value || 4);
    const maxRadius = parseFloat(document.getElementById('max-point-radius')?.value || 12);
    
    // Criar preview visual com diferentes tamanhos de pontos
    const previewHTML = `
      <div class="d-flex align-items-center justify-content-center gap-3">
        <div class="text-center">
          <div class="bg-primary rounded-circle mx-auto" style="width: ${minRadius * 2}px; height: ${minRadius * 2}px;"></div>
          <small class="text-muted">Mín: ${minRadius}px</small>
        </div>
        <div class="text-center">
          <div class="bg-primary rounded-circle mx-auto" style="width: ${(minRadius + maxRadius)}px; height: ${(minRadius + maxRadius)}px;"></div>
          <small class="text-muted">Médio</small>
        </div>
        <div class="text-center">
          <div class="bg-primary rounded-circle mx-auto" style="width: ${maxRadius * 2}px; height: ${maxRadius * 2}px;"></div>
          <small class="text-muted">Máx: ${maxRadius}px</small>
        </div>
      </div>
    `;
    
    preview.innerHTML = previewHTML;
  }
  
  function applyProportionalPointSizeToMap() {
    if (!currentLayer) return;
    
    const minRadius = parseFloat(document.getElementById('min-point-radius')?.value || 4);
    const maxRadius = parseFloat(document.getElementById('max-point-radius')?.value || 12);
    const field = document.getElementById('field-select')?.value;
    
    if (!field) return;
    
    // Obter valores do campo para calcular proporções
    const values = layerData.features
      .map(f => parseFloat(f.properties[field]))
      .filter(v => !isNaN(v))
      .sort((a, b) => a - b);
    
    if (values.length === 0) return;
    
    const min = values[0];
    const max = values[values.length - 1];
    const totalRange = max - min;
    
    console.log('🎯 Aplicando tamanho proporcional aos pontos:', { min, max, totalRange, minRadius, maxRadius });
    
    // Aplicar raio proporcional a cada feature
    currentLayer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.properties) {
        const featureValue = parseFloat(featureLayer.feature.properties[field]);
        if (!isNaN(featureValue)) {
          // Calcular percentual do valor em relação ao range total
          const valuePercent = totalRange > 0 ? ((featureValue - min) / totalRange) * 100 : 0;
          
          // Calcular raio proporcional
          const proportionalRadius = minRadius + (valuePercent / 100) * (maxRadius - minRadius);
          
          // Aplicar raio proporcional
          const currentStyle = featureLayer.options || {};
          const newStyle = {
            ...currentStyle,
            radius: proportionalRadius
          };
          
          featureLayer.setStyle(newStyle);
          
          console.log(`📍 Feature ${featureLayer.feature.id}: valor=${featureValue}, percentual=${valuePercent.toFixed(1)}%, raio=${proportionalRadius.toFixed(1)}px`);
        }
      }
    });
    
    // Atualizar legenda com tamanhos proporcionais
    updateLegendWithProportionalPointSizes(minRadius, maxRadius, values);
    
    console.log('✅ Tamanho proporcional dos pontos aplicado com sucesso');
  }
  
  function resetProportionalPointSizeOnMap() {
    if (!currentLayer) return;
    
    // Aplicar raio padrão a todas as features
    currentLayer.eachLayer(featureLayer => {
      if (featureLayer.feature) {
        const currentStyle = featureLayer.options || {};
        const newStyle = {
          ...currentStyle,
          radius: 6 // Raio padrão
        };
        
        featureLayer.setStyle(newStyle);
      }
    });
    
    // Remover indicadores de raio da legenda
    const radiusIndicators = document.querySelectorAll('.point-radius-indicator');
    radiusIndicators.forEach(indicator => {
      indicator.remove();
    });
    
    // Remover legenda explicativa
    const proportionalLegend = document.getElementById('proportional-point-size-legend');
    if (proportionalLegend) {
      proportionalLegend.remove();
    }
    
    // Limpar raios dos textos das classes
    const classValues = document.querySelectorAll('.class-value');
    classValues.forEach(classValue => {
      if (classValue.textContent.includes('px)')) {
        classValue.textContent = classValue.textContent.replace(/\s*\(\d+\.?\d*px\)/, '');
      }
    });
    
    // Forçar atualização do mapa
    if (map) {
      map.invalidateSize();
    }
  }
  
  function forceApplyProportionalPointSize() {
    console.log('💪 Forçando aplicação do tamanho proporcional dos pontos...');
    
    // Verificar se o toggle está ativado
    const toggle = document.getElementById('proportional-point-size-toggle');
    if (!toggle || !toggle.checked) {
      console.log('❌ Toggle não está ativado, saindo...');
      return;
    }
    
    // Verificar se é simbologia graduada e geometria ponto
    const styleType = document.getElementById('style-type')?.value;
    const geomType = document.getElementById('geom-type')?.value;
    
    if (styleType === 'graduated' && geomType === 'point') {
      console.log('✅ Condições atendidas, aplicando tamanho proporcional dos pontos...');
      // Usar requestAnimationFrame para sincronizar com o ciclo de renderização
      requestAnimationFrame(() => {
        applyProportionalPointSizeToMap();
      });
    } else {
      console.log('❌ Condições não atendidas:', { styleType, geomType });
    }
  }
  
  function updateLegendWithProportionalPointSizes(minRadius, maxRadius, values) {
    // Obter o campo atual da simbologia
    const field = document.getElementById('field-select')?.value;
    if (!field) return;
    
    // Obter as classes da legenda graduada
    const legendItems = document.querySelectorAll('.graduated-class-item');
    if (legendItems.length === 0) return;
    
    // Calcular estatísticas para distribuição proporcional
    const min = values[0];
    const max = values[values.length - 1];
    const totalRange = max - min;
    
    // Atualizar cada item da legenda
    legendItems.forEach((item, index) => {
      // Calcular valor representativo da classe
      const classIndex = index;
      const totalClasses = legendItems.length;
      
      // Calcular o valor representativo da classe baseado nos breaks
      const style = computeStyle();
      let representativeValue = 0;
      
      if (style && style.field === field) {
        // Tentar obter o valor representativo da classe
        const classRangeElement = item.querySelector('.class-range');
        if (classRangeElement) {
          const rangeText = classRangeElement.textContent;
          // Extrair valor médio do intervalo (ex: "10-20" -> 15)
          const rangeMatch = rangeText.match(/(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)/);
          if (rangeMatch) {
            const minVal = parseFloat(rangeMatch[1]);
            const maxVal = parseFloat(rangeMatch[2]);
            representativeValue = (minVal + maxVal) / 2;
          }
        }
      }
      
      // Se não conseguimos o valor real, usar a posição como fallback
      if (representativeValue === 0) {
        const percent = (classIndex / (totalClasses - 1)) * 100;
        representativeValue = min + (percent / 100) * totalRange;
      }
      
      // Calcular percentual baseado no valor real da classe
      const valuePercent = totalRange > 0 ? ((representativeValue - min) / totalRange) * 100 : 0;
      
      // Calcular raio proporcional baseado no valor real
      const proportionalRadius = minRadius + (valuePercent / 100) * (maxRadius - minRadius);
      
      // Atualizar o indicador visual de raio na legenda
      let radiusIndicator = item.querySelector('.point-radius-indicator');
      if (!radiusIndicator) {
        // Criar indicador se não existir
        radiusIndicator = document.createElement('div');
        radiusIndicator.className = 'point-radius-indicator';
        radiusIndicator.style.cssText = `
          width: ${proportionalRadius * 2}px;
          height: ${proportionalRadius * 2}px;
          background: #28a745;
          border-radius: 50%;
          margin: 2px auto;
          transition: all 0.3s ease;
        `;
        
        // Inserir após o nome da classe
        const className = item.querySelector('.class-name');
        if (className) {
          className.parentNode.insertBefore(radiusIndicator, className.nextSibling);
        }
      } else {
        // Atualizar o indicador existente
        radiusIndicator.style.width = `${proportionalRadius * 2}px`;
        radiusIndicator.style.height = `${proportionalRadius * 2}px`;
      }
      
      // Adicionar tooltip com informações detalhadas
      radiusIndicator.title = `Raio: ${proportionalRadius.toFixed(1)}px | Percentual: ${valuePercent.toFixed(1)}%`;
      
      // Atualizar o texto da classe para mostrar o raio
      const classValue = item.querySelector('.class-value');
      if (classValue) {
        const originalText = classValue.textContent;
        const radiusText = ` (${proportionalRadius.toFixed(1)}px)`;
        
        // Remover raio anterior se existir
        if (originalText.includes('px)')) {
          classValue.textContent = originalText.replace(/\s*\(\d+\.?\d*px\)/, '') + radiusText;
        } else {
          classValue.textContent = originalText + radiusText;
        }
      }
    });
    
    // Adicionar legenda explicativa dos tamanhos
    addProportionalPointSizeLegend(minRadius, maxRadius);
  }
  
  function addProportionalPointSizeLegend(minRadius, maxRadius) {
    // Remover legenda anterior se existir
    const existingLegend = document.getElementById('proportional-point-size-legend');
    if (existingLegend) {
      existingLegend.remove();
    }
    
    // Criar nova legenda
    const legendContainer = document.createElement('div');
    legendContainer.id = 'proportional-point-size-legend';
    legendContainer.className = 'mt-3 p-3 bg-light border rounded';
    legendContainer.innerHTML = `
      <div class="d-flex align-items-center justify-between mb-2">
        <h6 class="mb-0 text-success">
          <i class="fas fa-circle"></i> Legenda de Raios
        </h6>
        <small class="text-muted">Tamanho Proporcional</small>
      </div>
      <div class="row g-2">
        <div class="col-md-6">
          <div class="d-flex align-items-center gap-2">
            <div class="point-radius-indicator" style="width: ${minRadius * 2}px; height: ${minRadius * 2}px; background: #28a745; border-radius: 50%;"></div>
            <small class="text-muted">Mínimo: ${minRadius}px</small>
          </div>
        </div>
        <div class="col-md-6">
          <div class="d-flex align-items-center gap-2">
            <div class="point-radius-indicator" style="width: ${maxRadius * 2}px; height: ${maxRadius * 2}px; background: #28a745; border-radius: 50%;"></div>
            <small class="text-muted">Máximo: ${maxRadius}px</small>
          </div>
        </div>
      </div>
      <small class="text-muted">
        <i class="fas fa-info-circle"></i> 
        Os raios são calculados proporcionalmente ao percentual dos dados em cada classe.
      </small>
    `;
    
    // Inserir após a legenda principal
    const legendSection = document.querySelector('#block-legend');
    if (legendSection) {
      legendSection.appendChild(legendContainer);
    }
  }
</script>

<!-- Modal para Propriedades da Linha da Simbologia Graduada -->
<div class="modal fade" id="graduatedLinePropertiesModal" tabindex="-1" aria-labelledby="graduatedLinePropertiesModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="graduatedLinePropertiesModalLabel">
          <i class="fas fa-cog"></i> Propriedades da Linha - Classe Graduada
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="row">
          <div class="col-md-12">
            <!-- Seletor de Classe -->
            <div class="mb-3">
              <label for="graduated-class-selector" class="form-label">
                <strong>Selecionar Classe:</strong>
              </label>
              <select class="form-select" id="graduated-class-selector">
                <option value="">Selecione uma classe...</option>
              </select>
            </div>
            
            <!-- Propriedades da Linha (inicialmente ocultas) -->
            <div id="graduated-line-properties-container" class="d-none">
              <div class="card">
                <div class="card-header bg-light">
                  <h6 class="mb-0">
                    <i class="fas fa-sliders-h"></i> Configurações da Linha
                  </h6>
                </div>
                <div class="card-body">
                  <div class="row">
                    <!-- Opacidade -->
                    <div class="col-md-4">
                      <div class="mb-3">
                        <label for="graduated-line-opacity-modal" class="form-label">
                          <i class="fas fa-eye"></i> Opacidade
                        </label>
                        <div class="d-flex align-items-center gap-2">
                          <input type="range" class="form-range" id="graduated-line-opacity-modal" 
                                 min="0" max="1" step="0.05" value="1"
                                 title="Ajustar opacidade da linha">
                          <span class="badge bg-secondary" id="graduated-line-opacity-value">1.0</span>
                        </div>
                      </div>
                    </div>
                    
                    <!-- Estilo da Linha -->
                    <div class="col-md-4">
                      <div class="mb-3">
                        <label for="graduated-line-style-modal" class="form-label">
                          <i class="fas fa-pen-fancy"></i> Estilo da Linha
                        </label>
                        <select class="form-select" id="graduated-line-style-modal" title="Selecionar estilo da linha">
                          <option value="">Contínua</option>
                          <option value="5,5">Tracejada</option>
                          <option value="10,5">Tracejada Longa</option>
                          <option value="2,2">Pontilhada</option>
                          <option value="1,1">Pontilhada Fina</option>
                          <option value="5,2,1,2">Traço-Ponto</option>
                          <option value="10,2,1,2">Traço-Ponto Longo</option>
                          <option value="15,3,3,3">Traço-Ponto-Ponto</option>
                          <option value="20,5,5,5">Traço-Ponto-Ponto Longo</option>
                          <option value="custom">Personalizado...</option>
                        </select>
                      </div>
                    </div>
                    
                    <!-- Espaçamento (condicional) -->
                    <div class="col-md-4">
                      <div class="mb-3" id="graduated-line-spacing-container">
                        <label for="graduated-line-spacing-modal" class="form-label">
                          <i class="fas fa-arrows-alt-h"></i> Espaçamento
                        </label>
                        <div class="d-flex align-items-center gap-2">
                          <input type="range" class="form-range" id="graduated-line-spacing-modal" 
                                 min="1" max="30" step="0.5" value="10"
                                 title="Ajustar espaçamento entre traços/pontos">
                          <span class="badge bg-info" id="graduated-line-spacing-value">10px</span>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Padrão Personalizado -->
                  <div class="row mt-3" id="graduated-custom-pattern-container" style="display: none;">
                    <div class="col-md-12">
                      <div class="mb-3">
                        <label for="graduated-custom-pattern" class="form-label">
                          <i class="fas fa-edit"></i> Padrão Personalizado
                        </label>
                        <div class="input-group">
                          <input type="text" class="form-control" id="graduated-custom-pattern" 
                                 placeholder="Ex: 10,5,2,5" 
                                 title="Formato: traço,espaço,traço,espaço...">
                          <button class="btn btn-outline-secondary" type="button" id="graduated-preview-pattern-btn">
                            <i class="fas fa-eye"></i> Preview
                          </button>
                        </div>
                        <div class="form-text">Formato: traço,espaço,traço,espaço...</div>
                      </div>
                      
                      <!-- Preview do Padrão -->
                      <div class="mt-2">
                        <label class="form-label small">Preview:</label>
                        <div id="graduated-custom-pattern-preview" class="border rounded p-2 bg-light text-center">
                          <div class="text-muted">Preview do padrão personalizado</div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Preview da Linha -->
              <div class="card mt-3">
                <div class="card-header bg-light">
                  <h6 class="mb-0">
                    <i class="fas fa-eye"></i> Preview da Linha
                  </h6>
                </div>
                <div class="card-body text-center">
                  <div id="graduated-line-preview" class="border rounded p-3 bg-white">
                    <div class="text-muted">Preview da linha com as configurações selecionadas</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          <i class="fas fa-times"></i> Fechar
        </button>
        <button type="button" class="btn btn-primary" id="graduated-apply-line-properties">
          <i class="fas fa-check"></i> Aplicar Configurações
        </button>
      </div>
    </div>
  </div>
</div>

<!-- ======================================== -->
<!-- BIBLIOTECA DE ÍCONES TEMÁTICOS -->
<!-- ======================================== -->

<script>
// Biblioteca de ícones temáticos para pontos
const ICON_LIBRARY = {
  transport: {
    name: 'Transporte',
    icons: {
      airport: { name: 'Aeroporto', svg: 'M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z' },
      port: { name: 'Porto', svg: 'M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5' },
      train_station: { name: 'Estação de Trem', svg: 'M12 2c-4 0-8 .5-8 4v9.5C4 17.43 5.57 19 7.5 19L6 20v1h2l2-2h4l2 2h2v-1l-1.5-1c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-4-4-8-4zM7.5 17c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm3.5-7H6V6h5v4zm5.5 7c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-7h-5V6h5v4z' },
      bus_stop: { name: 'Ponto de Ônibus', svg: 'M4 16c0 .88.39 1.67 1 2.22V20c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1h8v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-1.78c.61-.55 1-1.34 1-2.22V6c0-3.5-3.58-4-8-4s-8 .5-8 4v10zm3.5 1c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm9 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm1.5-5H6V6h12v6z' },
      gas_station: { name: 'Posto de Gasolina', svg: 'M18 10h-1V4c0-.55-.45-1-1-1H8c-.55 0-1 .45-1 1v6H6c-1.1 0-2 .9-2 2v6c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-6c0-1.1-.9-2-2-2zM8 4h8v6H8V4z' },
      parking: { name: 'Estacionamento', svg: 'M13 3H6v18h4v-6h3c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10h-3V9h3c1.66 0 3 1.34 3 3s-1.34 3-3 3z' }
    }
  },
  emergency: {
    name: 'Serviços de Emergência',
    icons: {
      hospital: { name: 'Hospital', svg: 'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-2h2v2zm0-4h-2V7h2v6z' },
      police: { name: 'Delegacia', svg: 'M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z' },
      fire_station: { name: 'Quartel de Bombeiros', svg: 'M12 12.9l-3.03 3.26c-1.68 1.82-1.68 4.71 0 6.53C10.39 23.56 12 24 12 24s1.61-.44 3.03-1.31c1.68-1.82 1.68-4.71 0-6.53L12 12.9z' },
      ambulance: { name: 'Ambulância', svg: 'M7 14c1.66 0 3 1.34 3 3 0 1.31-1.16 2-2 2 0 0-1 0-1-1v-4H7v4zm6 0c1.66 0 3 1.34 3 3 0 1.31-1.16 2-2 2 0 0-1 0-1-1v-4h-2v4zm-6-5c1.1 0 2 .9 2 2H7c-.55 0-1-.45-1-1s.45-1 1-1zm6 0c1.1 0 2 .9 2 2h-2c-.55 0-1-.45-1-1s.45-1 1-1z' },
      emergency_phone: { name: 'Telefone de Emergência', svg: 'M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z' }
    }
  },
  commerce: {
    name: 'Comércio',
    icons: {
      store: { name: 'Loja', svg: 'M20 4H4v2h16V4zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4H6v-4h6v4z' },
      shopping_mall: { name: 'Shopping', svg: 'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z' },
      market: { name: 'Mercado', svg: 'M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12L8.1 13h7.45c.75 0 1.41-.41 1.75-1.03L21.7 4H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z' },
      restaurant: { name: 'Restaurante', svg: 'M11 9H9V2H7v7H5V2H3v7c0 2.12 1.66 3.84 3.75 3.97V22h2.5v-9.03C11.34 12.84 13 11.12 13 9V2h-2v7zm5-3v8h2.5v8H21V2c-2.76 0-5 2.24-5 4z' },
      bank: { name: 'Banco', svg: 'M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5zM12 15c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z' }
    }
  },
  education: {
    name: 'Educação',
    icons: {
      school: { name: 'Escola', svg: 'M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82zM12 3L1 9l11 6 9-4.91V17h2V9L12 3z' },
      university: { name: 'Universidade', svg: 'M12 3L1 9l4 2.18v6L12 21l7-3.82v-6l2 1.09v2.73L12 21l-7-3.82v-6L1 9l11-6z' },
      library: { name: 'Biblioteca', svg: 'M12 11.55C9.64 9.35 6.48 8 3 8v11c3.48 0 6.64 1.35 9 3.55 2.36-2.19 5.52-3.55 9-3.55V8c-3.48 0-6.64 1.35-9 3.55zM12 8c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3z' },
      museum: { name: 'Museu', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' },
      research_center: { name: 'Centro de Pesquisa', svg: 'M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z' }
    }
  },
  nature: {
    name: 'Natureza',
    icons: {
      park: { name: 'Parque', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' },
      river: { name: 'Rio', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' },
      mountain: { name: 'Montanha', svg: 'M14 6l-3.75 5 2.85 3.8-1.6 1.2C7.81 13.75 6 15.5 6 17.5C6 19.43 7.57 21 9.5 21c1.54 0 2.5-1 2.5-2.5c0-.88-.56-1.75-1.25-2.25L12 15l-1.75 1.25C9.56 16.75 9 17.62 9 18.5C9 19.88 10.12 21 11.5 21c.74 0 1.44-.23 2.03-.61L14 20.5V6z' },
      forest: { name: 'Floresta', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' },
      beach: { name: 'Praia', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' }
    }
  },
  health: {
    name: 'Saúde',
    icons: {
      clinic: { name: 'Clínica', svg: 'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-2h2v2zm0-4h-2V7h2v6z' },
      pharmacy: { name: 'Farmácia', svg: 'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-2h2v2zm0-4h-2V7h2v6z' },
      laboratory: { name: 'Laboratório', svg: 'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-2h2v2zm0-4h-2V7h2v6z' },
      dental_clinic: { name: 'Clínica Odontológica', svg: 'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-2h2v2zm0-4h-2V7h2v6z' },
      mental_health: { name: 'Saúde Mental', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' }
    }
  },
  government: {
    name: 'Governo',
    icons: {
      city_hall: { name: 'Prefeitura', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' },
      court: { name: 'Tribunal', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' },
      police_station: { name: 'Delegacia', svg: 'M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z' },
      post_office: { name: 'Correios', svg: 'M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z' },
      embassy: { name: 'Embaixada', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' }
    }
  },
  recreation: {
    name: 'Recreação',
    icons: {
      cinema: { name: 'Cinema', svg: 'M18 4l2 4h-3l-2-4h-2l2 4h-3l-2-4H8l2 4H7L5 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4h-4z' },
      theater: { name: 'Teatro', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' },
      sports_center: { name: 'Centro Esportivo', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' },
      amusement_park: { name: 'Parque de Diversões', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' },
      museum: { name: 'Museu', svg: 'M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z' }
    }
  }
};

/**
 * Configura a biblioteca de ícones temáticos
 */
function setupIconLibrary() {
  console.log('🎨 Configurando biblioteca de ícones temáticos...');
  
  // Event listener para categoria temática
  const iconThemeCategory = document.getElementById('icon-theme-category');
  if (iconThemeCategory) {
    iconThemeCategory.addEventListener('change', function() {
      updateIconSpecificTypes(this.value);
      updateIconPreview();
    });
  }
  
  // Event listener para ícone específico
  const iconSpecificType = document.getElementById('icon-specific-type');
  if (iconSpecificType) {
    iconSpecificType.addEventListener('change', function() {
      updateIconPreview();
      enableApplyButton();
    });
  }
  
  // Event listener para tamanho do ícone
  const iconSizeSlider = document.getElementById('icon-size-slider');
  if (iconSizeSlider) {
    iconSizeSlider.addEventListener('input', function() {
      const value = this.value;
      document.getElementById('icon-size-value').textContent = value + 'px';
      updateIconPreview();
    });
  }
  
  // Event listener para cor do ícone
  const iconColorPicker = document.getElementById('icon-color-picker');
  if (iconColorPicker) {
    iconColorPicker.addEventListener('change', function() {
      updateIconPreview();
    });
  }
  
  // Event listener para aplicar ícone aos pontos
  const applyIconToPoints = document.getElementById('apply-icon-to-points');
  if (applyIconToPoints) {
    applyIconToPoints.addEventListener('click', function() {
      applyIconToAllPoints();
    });
  }
  
  // Event listener para resetar configurações
  const resetIconSettings = document.getElementById('reset-icon-settings');
  if (resetIconSettings) {
    resetIconSettings.addEventListener('click', function() {
      resetIconSettingsToDefault();
    });
  }
  
  // Event listener para exportar configurações
  const exportIconSettings = document.getElementById('export-icon-settings');
  if (exportIconSettings) {
    exportIconSettings.addEventListener('click', function() {
      exportIconSettingsToFile();
    });
  }
  
  console.log('✅ Biblioteca de ícones temáticos configurada com sucesso');
}

/**
 * Atualiza os tipos de ícones específicos baseado na categoria selecionada
 */
function updateIconSpecificTypes(category) {
  const iconSpecificType = document.getElementById('icon-specific-type');
  if (!iconSpecificType) return;
  
  // Limpar opções existentes
  iconSpecificType.innerHTML = '<option value="">Selecionar ícone...</option>';
  
  if (category && ICON_LIBRARY[category]) {
    const icons = ICON_LIBRARY[category].icons;
    
    // Adicionar opções para cada ícone da categoria
    Object.keys(icons).forEach(iconKey => {
      const icon = icons[iconKey];
      const option = document.createElement('option');
      option.value = iconKey;
      option.textContent = icon.name;
      iconSpecificType.appendChild(option);
    });
    
    // Habilitar select
    iconSpecificType.disabled = false;
  } else {
    // Desabilitar select se nenhuma categoria for selecionada
    iconSpecificType.disabled = true;
  }
}

/**
 * Atualiza o preview do ícone selecionado
 */
function updateIconPreview() {
  const previewContainer = document.getElementById('icon-preview-container');
  if (!previewContainer) return;
  
  const category = document.getElementById('icon-theme-category')?.value;
  const iconType = document.getElementById('icon-specific-type')?.value;
  const iconSize = document.getElementById('icon-size-slider')?.value || 24;
  const iconColor = document.getElementById('icon-color-picker')?.value || '#ff0000';
  
  if (category && iconType && ICON_LIBRARY[category]?.icons[iconType]) {
    const icon = ICON_LIBRARY[category].icons[iconType];
    
    // Criar SVG do ícone
    const svg = `
      <svg width="${iconSize}" height="${iconSize}" viewBox="0 0 24 24" fill="${iconColor}">
        <path d="${icon.svg}"/>
      </svg>
    `;
    
    previewContainer.innerHTML = `
      <div class="d-flex align-items-center justify-content-center h-100">
        <div class="text-center">
          <div class="mb-2">${svg}</div>
          <div class="small text-muted">${icon.name}</div>
          <div class="small text-muted">${iconSize}px - ${iconColor}</div>
        </div>
      </div>
    `;
  } else {
    previewContainer.innerHTML = `
      <div class="text-muted">Selecione uma categoria e ícone para visualizar</div>
    `;
  }
}

/**
 * Habilita o botão de aplicar ícone
 */
function enableApplyButton() {
  const applyButton = document.getElementById('apply-icon-to-points');
  if (applyButton) {
    const category = document.getElementById('icon-theme-category')?.value;
    const iconType = document.getElementById('icon-specific-type')?.value;
    
    applyButton.disabled = !(category && iconType);
  }
}

/**
 * Aplica o ícone selecionado a todos os pontos da camada
 */
function applyIconToAllPoints() {
  const category = document.getElementById('icon-theme-category')?.value;
  const iconType = document.getElementById('icon-specific-type')?.value;
  const iconSize = document.getElementById('icon-size-slider')?.value || 24;
  const iconColor = document.getElementById('icon-color-picker')?.value || '#ff0000';
  
  if (!category || !iconType || !ICON_LIBRARY[category]?.icons[iconType]) {
    console.error('❌ Categoria ou ícone não selecionado');
    return;
  }
  
  console.log('🎯 Aplicando ícone aos pontos:', { category, iconType, iconSize, iconColor });
  
  // Salvar configurações do ícone
  const iconSettings = {
    category,
    iconType,
    iconSize: parseInt(iconSize),
    iconColor,
    timestamp: Date.now()
  };
  
  localStorage.setItem(`icon_settings_${layerId}`, JSON.stringify(iconSettings));
  
  // Aplicar ícone aos pontos no mapa
  if (currentLayer) {
    currentLayer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.geometry?.type === 'Point') {
        // Criar ícone personalizado
        const customIcon = createCustomIcon(iconSettings);
        
        // Aplicar ícone ao feature
        featureLayer.setIcon(customIcon);
        
        console.log(`📍 Ícone aplicado ao ponto ${featureLayer.feature.id}`);
      }
    });
  }
  
  // Forçar atualização do mapa de pré-visualização
  forceMapUpdate();
  
  // Atualizar preview
  refreshPreview();
  
  // Mostrar mensagem de sucesso
  showNotification('✅ Ícone aplicado com sucesso a todos os pontos!', 'success');
}

/**
 * Cria um ícone personalizado baseado nas configurações
 */
function createCustomIcon(iconSettings) {
  const { category, iconType, iconSize, iconColor } = iconSettings;
  
  if (!ICON_LIBRARY[category]?.icons[iconType]) {
    console.error('❌ Ícone não encontrado na biblioteca');
    return null;
  }
  
  const icon = ICON_LIBRARY[category].icons[iconType];
  
  // Criar SVG do ícone
  const svg = `
    <svg width="${iconSize}" height="${iconSize}" viewBox="0 0 24 24" fill="${iconColor}">
      <path d="${icon.svg}"/>
    </svg>
  `;
  
  // Criar elemento HTML para o ícone
  const iconElement = document.createElement('div');
  iconElement.innerHTML = svg;
  iconElement.style.width = `${iconSize}px`;
  iconElement.style.height = `${iconSize}px`;
  
  // Criar ícone Leaflet
  const customIcon = L.divIcon({
    html: iconElement,
    className: 'custom-icon',
    iconSize: [iconSize, iconSize],
    iconAnchor: [iconSize / 2, iconSize / 2]
  });
  
  return customIcon;
}

/**
 * Resetar configurações de ícone para valores padrão
 */
function resetIconSettingsToDefault() {
  console.log('🔄 Resetando configurações de ícone...');
  
  // Resetar valores dos controles
  const iconThemeCategory = document.getElementById('icon-theme-category');
  const iconSpecificType = document.getElementById('icon-specific-type');
  const iconSizeSlider = document.getElementById('icon-size-slider');
  const iconColorPicker = document.getElementById('icon-color-picker');
  
  if (iconThemeCategory) iconThemeCategory.value = '';
  if (iconSpecificType) {
    iconSpecificType.value = '';
    iconSpecificType.disabled = true;
  }
  if (iconSizeSlider) iconSizeSlider.value = 24;
  if (iconColorPicker) iconColorPicker.value = '#ff0000';
  
  // Atualizar preview
  updateIconPreview();
  
  // Desabilitar botão de aplicar
  enableApplyButton();
  
  // Limpar configurações salvas
  localStorage.removeItem(`icon_settings_${layerId}`);
  
  // Remover ícones personalizados dos pontos
  if (currentLayer) {
    currentLayer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.geometry?.type === 'Point') {
        // Resetar para ícone padrão
        featureLayer.setIcon(null);
      }
    });
  }
  
  // Atualizar preview
  refreshPreview();
  
  showNotification('🔄 Configurações de ícone resetadas com sucesso!', 'info');
}

/**
 * Exportar configurações de ícone para arquivo
 */
function exportIconSettingsToFile() {
  const category = document.getElementById('icon-theme-category')?.value;
  const iconType = document.getElementById('icon-specific-type')?.value;
  
  if (!category || !iconType) {
    showNotification('❌ Selecione uma categoria e ícone antes de exportar', 'error');
    return;
  }
  
  const iconSettings = {
    category,
    iconType,
    iconSize: parseInt(document.getElementById('icon-size-slider')?.value || 24),
    iconColor: document.getElementById('icon-color-picker')?.value || '#ff0000',
    timestamp: Date.now(),
    layerId,
    layerName: document.getElementById('layer-name')?.value || 'Camada'
  };
  
  // Criar arquivo de configuração
  const configBlob = new Blob([JSON.stringify(iconSettings, null, 2)], {
    type: 'application/json'
  });
  
  // Download do arquivo
  const downloadLink = document.createElement('a');
  downloadLink.href = URL.createObjectURL(configBlob);
  downloadLink.download = `icon_settings_${layerId}_${Date.now()}.json`;
  downloadLink.click();
  
  showNotification('📥 Configurações de ícone exportadas com sucesso!', 'success');
}

/**
 * Carregar configurações de ícone salvas
 */
function loadIconSettings() {
  const savedSettings = localStorage.getItem(`icon_settings_${layerId}`);
  if (savedSettings) {
    try {
      const settings = JSON.parse(savedSettings);
      
      // Aplicar configurações salvas
      const iconThemeCategory = document.getElementById('icon-theme-category');
      const iconSpecificType = document.getElementById('icon-specific-type');
      const iconSizeSlider = document.getElementById('icon-size-slider');
      const iconColorPicker = document.getElementById('icon-color-picker');
      
      if (iconThemeCategory) iconThemeCategory.value = settings.category;
      if (iconSpecificType) {
        iconSpecificType.value = settings.iconType;
        iconSpecificType.disabled = false;
      }
      if (iconSizeSlider) iconSizeSlider.value = settings.iconSize;
      if (iconColorPicker) iconColorPicker.value = settings.iconColor;
      
      // Atualizar interface
      updateIconSpecificTypes(settings.category);
      updateIconPreview();
      enableApplyButton();
      
      console.log('✅ Configurações de ícone carregadas:', settings);
    } catch (error) {
      console.error('❌ Erro ao carregar configurações de ícone:', error);
    }
  }
}

/**
 * Força a atualização completa do mapa de pré-visualização
 */
function forceMapUpdate() {
  console.log('🔄 Forçando atualização do mapa de pré-visualização...');
  console.log('🔍 Debug forceMapUpdate:', {
    hasCurrentLayer: !!currentLayer,
    hasMap: !!map,
    currentLayer: currentLayer,
    map: map,
    layerData: layerData
  });
  
  if (!currentLayer || !map) {
    console.warn('❌ currentLayer ou map não disponível para atualização');
    return;
  }
  
  // Remover e readicionar a camada para forçar atualização
  map.removeLayer(currentLayer);
  
  // Aplicar todas as configurações atuais
  applyCurrentSymbologySettings();
  
  // IMPORTANTE: Garantir que os pontos sejam renderizados corretamente
  ensurePointRendering();
  
  // Readicionar a camada ao mapa
  currentLayer.addTo(map);
  
  // Forçar renderização
  map.invalidateSize();
  
  console.log('✅ Mapa de pré-visualização atualizado com sucesso');
}

/**
 * Aplica todas as configurações atuais de simbologia à camada
 */
function applyCurrentSymbologySettings() {
  console.log('🎨 Aplicando configurações atuais de simbologia...');
  
  if (!currentLayer) {
    console.warn('❌ currentLayer não disponível em applyCurrentSymbologySettings');
    return;
  }
  
  const styleType = document.getElementById('style-type')?.value;
  const geomType = document.getElementById('geom-type')?.value;
  
  console.log('📊 Configurações detectadas:', { styleType, geomType });
  console.log('🔍 Debug applyCurrentSymbologySettings:', {
    hasCurrentLayer: !!currentLayer,
    currentLayer: currentLayer,
    styleType: styleType,
    geomType: geomType
  });
  
  // Aplicar configurações baseadas no tipo de simbologia
  if (styleType === 'single') {
    applySingleSymbolStyle();
  } else if (styleType === 'categorized') {
    applyCategorizedStyle();
  } else if (styleType === 'graduated') {
    applyGraduatedStyleFromUI();
  }
  
  // Aplicar configurações específicas de geometria
  if (geomType === 'point') {
    applyPointSpecificSettings();
  } else if (geomType === 'line') {
    applyLineSpecificSettings();
  }
  
  // Aplicar ícones temáticos se configurados
  applyThematicIcons();
  
  console.log('✅ Todas as configurações de simbologia aplicadas');
}

/**
 * Aplica estilo de símbolo único
 */
function applySingleSymbolStyle() {
  const fillColor = document.getElementById('fill-color')?.value || '#38bdf8';
  const strokeColor = document.getElementById('stroke-color')?.value || '#333333';
  const strokeWeight = document.getElementById('stroke-weight')?.value || 2;
  const fillOpacity = document.getElementById('fill-opacity')?.value || 0.3;
  
  currentLayer.eachLayer(featureLayer => {
    const style = {
      fillColor: fillColor,
      color: strokeColor,
      weight: parseFloat(strokeWeight),
      fillOpacity: parseFloat(fillOpacity)
    };
    
    // Para pontos, garantir que sejam renderizados como círculos
    if (featureLayer.feature && featureLayer.feature.geometry?.type === 'Point') {
      style.radius = 6; // Raio padrão
      style.renderer = L.canvas.tileCanvas;
      
      // Remover ícones personalizados
      if (featureLayer.setIcon) {
        featureLayer.setIcon(null);
      }
    }
    
    featureLayer.setStyle(style);
  });
}

/**
 * Aplica estilo categorizado
 */
function applyCategorizedStyle() {
  const field = document.getElementById('field-select')?.value;
  if (!field) return;
  
  // Obter categorias da interface
  const categoryItems = document.querySelectorAll('.categorized-class-item');
  
  categoryItems.forEach(item => {
    const category = item.dataset.category;
    const color = item.querySelector('.color-picker')?.value || '#ff0000';
    const lineWeight = item.querySelector('.line-weight-input')?.value || 2;
    const lineOpacity = item.querySelector('.line-opacity-input')?.value || 1;
    const lineStyle = item.querySelector('.line-style-select')?.value || '';
    
            // Aplicar estilo aos features desta categoria
        currentLayer.eachLayer(featureLayer => {
          if (featureLayer.feature && featureLayer.feature.properties[field] === category) {
            const style = {
              fillColor: color,
              color: color,
              weight: parseFloat(lineWeight),
              opacity: parseFloat(lineOpacity)
            };
            
            if (lineStyle) {
              style.dashArray = lineStyle;
            }
            
            // Para pontos, garantir que sejam renderizados como círculos
            if (featureLayer.feature.geometry?.type === 'Point') {
              style.radius = 6; // Raio padrão
              style.renderer = L.canvas.tileCanvas;
              style.fillOpacity = 0.8;
              
              // Remover ícones personalizados
              if (featureLayer.setIcon) {
                featureLayer.setIcon(null);
              }
            }
            
            featureLayer.setStyle(style);
          }
        });
  });
}

/**
 * Aplica estilo graduado
 */
function applyGraduatedStyleFromUI() {
  const field = document.getElementById('field-select')?.value;
  const classes = document.getElementById('classes-input')?.value || 5;
  const method = document.getElementById('method-select')?.value || 'equal';
  const palette = document.getElementById('palette-select')?.value || 'Blues';
  
  if (!field) return;
  
  // Calcular breaks e aplicar estilos
  const style = {
    type: 'graduated',
    field: field,
    classes: parseInt(classes),
    method: method,
    palette: palette,
    geometry_type: document.getElementById('geom-type')?.value || 'point'
  };
  
  applyGraduatedStyle(currentLayer, style);
}

/**
 * Aplica configurações específicas para pontos
 */
function applyPointSpecificSettings() {
  console.log('🎯 Aplicando configurações específicas para pontos...');
  
  const pointRadiusDefault = document.getElementById('point-radius-default')?.value;
  const pointOpacityDefault = document.getElementById('point-opacity-default')?.value;
  const pointShapeDefault = document.getElementById('point-shape-default')?.value;
  const pointBorderWidthDefault = document.getElementById('point-border-width-default')?.value;
  const pointBorderColorDefault = document.getElementById('point-border-color-default')?.value;
  const pointBorderStyleDefault = document.getElementById('point-border-style-default')?.value;
  const pointShadowDefault = document.getElementById('point-shadow-default')?.value;
  
  // Aplicar tamanho proporcional se ativado
  const isProportionalPointSizeEnabled = document.getElementById('proportional-point-size-toggle')?.checked || false;
  
  currentLayer.eachLayer(featureLayer => {
    if (featureLayer.feature && featureLayer.feature.geometry?.type === 'Point') {
      const currentStyle = featureLayer.options || {};
      const newStyle = { ...currentStyle };
      
      // IMPORTANTE: Definir o tipo de renderização como círculo para pontos
      newStyle.renderer = L.canvas.tileCanvas;
      
      if (isProportionalPointSizeEnabled) {
        // Aplicar tamanho proporcional
        const minRadius = parseFloat(document.getElementById('min-point-radius')?.value || 4);
        const maxRadius = parseFloat(document.getElementById('max-point-radius')?.value || 12);
        const field = document.getElementById('field-select')?.value;
        
        if (field && featureLayer.feature.properties[field]) {
          const value = parseFloat(featureLayer.feature.properties[field]);
          if (!isNaN(value)) {
            // Calcular raio proporcional
            const values = layerData.features
              .map(f => parseFloat(f.properties[field]))
              .filter(v => !isNaN(v))
              .sort((a, b) => a - b);
            
            if (values.length > 0) {
              const min = values[0];
              const max = values[values.length - 1];
              const totalRange = max - min;
              
              if (totalRange > 0) {
                const valuePercent = ((value - min) / totalRange) * 100;
                const proportionalRadius = minRadius + (valuePercent / 100) * (maxRadius - minRadius);
                newStyle.radius = proportionalRadius;
              }
            }
          }
        }
      } else if (pointRadiusDefault) {
        newStyle.radius = parseFloat(pointRadiusDefault);
      } else {
        // Raio padrão se nenhum for definido
        newStyle.radius = 6;
      }
      
      // Aplicar forma específica baseada na seleção
      if (pointShapeDefault) {
        switch (pointShapeDefault) {
          case 'circle':
            newStyle.renderer = L.canvas.tileCanvas;
            break;
          case 'square':
            newStyle.renderer = L.canvas.tileCanvas;
            newStyle.shape = 'square';
            break;
          case 'diamond':
            newStyle.renderer = L.canvas.tileCanvas;
            newStyle.shape = 'diamond';
            break;
          case 'triangle':
            newStyle.renderer = L.canvas.tileCanvas;
            newStyle.shape = 'triangle';
            break;
          case 'star':
            newStyle.renderer = L.canvas.tileCanvas;
            newStyle.shape = 'star';
            break;
          case 'cross':
            newStyle.renderer = L.canvas.tileCanvas;
            newStyle.shape = 'cross';
            break;
          case 'pin':
            newStyle.renderer = L.canvas.tileCanvas;
            newStyle.shape = 'pin';
            break;
          case 'marker':
            newStyle.renderer = L.canvas.tileCanvas;
            newStyle.shape = 'marker';
            break;
          default:
            newStyle.renderer = L.canvas.tileCanvas;
        }
      }
      
      // Aplicar opacidade
      if (pointOpacityDefault) {
        newStyle.fillOpacity = parseFloat(pointOpacityDefault);
      } else {
        newStyle.fillOpacity = 0.8;
      }
      
      // Aplicar borda
      if (pointBorderWidthDefault) {
        newStyle.weight = parseFloat(pointBorderWidthDefault);
      } else {
        newStyle.weight = 1;
      }
      
      if (pointBorderColorDefault) {
        newStyle.color = pointBorderColorDefault;
      } else {
        newStyle.color = '#000000';
      }
      
      // Aplicar estilo da borda
      if (pointBorderStyleDefault) {
        newStyle.dashArray = pointBorderStyleDefault === 'dashed' ? '5,5' : 
                           pointBorderStyleDefault === 'dotted' ? '2,2' : '';
      }
      
      // Aplicar sombra
      if (pointShadowDefault && parseFloat(pointShadowDefault) > 0) {
        newStyle.shadowBlur = parseFloat(pointShadowDefault);
        newStyle.shadowColor = 'rgba(0,0,0,0.3)';
        newStyle.shadowOffsetX = 2;
        newStyle.shadowOffsetY = 2;
      }
      
      // Garantir que o ponto seja renderizado como círculo por padrão
      newStyle.renderer = L.canvas.tileCanvas;
      
      console.log('🎯 Estilo aplicado ao ponto:', newStyle);
      
      // Aplicar o estilo
      featureLayer.setStyle(newStyle);
      
      // IMPORTANTE: Remover qualquer ícone personalizado para usar o estilo padrão
      if (featureLayer.setIcon) {
        featureLayer.setIcon(null);
      }
    }
  });
}

/**
 * Aplica configurações específicas para linhas
 */
function applyLineSpecificSettings() {
  console.log('🎯 Aplicando configurações específicas para linhas...');
  
  const lineWeightDefault = document.getElementById('line-weight-default')?.value;
  const lineOpacityDefault = document.getElementById('line-opacity-default')?.value;
  const lineStyleDefault = document.getElementById('line-style-default')?.value;
  
  // Aplicar tamanho proporcional se ativado
  const isProportionalSizeEnabled = document.getElementById('proportional-size-toggle')?.checked || false;
  
  currentLayer.eachLayer(featureLayer => {
    if (featureLayer.feature && featureLayer.feature.geometry?.type === 'LineString') {
      const currentStyle = featureLayer.options || {};
      const newStyle = { ...currentStyle };
      
      if (isProportionalSizeEnabled) {
        // Aplicar peso proporcional
        const minWeight = parseFloat(document.getElementById('min-line-weight')?.value || 2);
        const maxWeight = parseFloat(document.getElementById('max-line-weight')?.value || 8);
        const field = document.getElementById('field-select')?.value;
        
        if (field && featureLayer.feature.properties[field]) {
          const value = parseFloat(featureLayer.feature.properties[field]);
          if (!isNaN(value)) {
            // Calcular peso proporcional
            const values = layerData.features
              .map(f => parseFloat(f.properties[field]))
              .filter(v => !isNaN(v))
              .sort((a, b) => a - b);
            
            if (values.length > 0) {
              const min = values[0];
              const max = values[values.length - 1];
              const totalRange = max - min;
              
              if (totalRange > 0) {
                const valuePercent = ((value - min) / totalRange) * 100;
                const proportionalWeight = minWeight + (valuePercent / 100) * (maxWeight - minWeight);
                newStyle.weight = proportionalWeight;
              }
            }
          }
        }
      } else if (lineWeightDefault) {
        newStyle.weight = parseFloat(lineWeightDefault);
      }
      
      if (lineOpacityDefault) {
        newStyle.opacity = parseFloat(lineOpacityDefault);
      }
      
      if (lineStyleDefault) {
        newStyle.dashArray = lineStyleDefault;
      }
      
      featureLayer.setStyle(newStyle);
    }
  });
}

/**
 * Garante que os pontos sejam renderizados corretamente
 */
function ensurePointRendering() {
  console.log('🎯 Garantindo renderização correta dos pontos...');
  
  if (!currentLayer) return;
  
  const geomType = document.getElementById('geom-type')?.value;
  if (geomType !== 'point') return;
  
  // Verificar se há configurações específicas de ponto
  const pointRadiusDefault = document.getElementById('point-radius-default')?.value;
  const pointOpacityDefault = document.getElementById('point-opacity-default')?.value;
  const pointShapeDefault = document.getElementById('point-shape-default')?.value;
  const pointBorderWidthDefault = document.getElementById('point-border-width-default')?.value;
  const pointBorderColorDefault = document.getElementById('point-border-color-default')?.value;
  
  // Se houver configurações específicas, aplicar estilos padrão
  if (pointRadiusDefault || pointOpacityDefault || pointShapeDefault || pointBorderWidthDefault || pointBorderColorDefault) {
    console.log('🎯 Aplicando estilos específicos de ponto...');
    
    currentLayer.eachLayer(featureLayer => {
      if (featureLayer.feature && featureLayer.feature.geometry?.type === 'Point') {
        // Remover ícones personalizados
        if (featureLayer.setIcon) {
          featureLayer.setIcon(null);
        }
        
        // Aplicar estilo padrão de ponto
        const currentStyle = featureLayer.options || {};
        const newStyle = { ...currentStyle };
        
        // Garantir que seja renderizado como círculo
        newStyle.renderer = L.canvas.tileCanvas;
        
        if (pointRadiusDefault) {
          newStyle.radius = parseFloat(pointRadiusDefault);
        } else {
          newStyle.radius = 6;
        }
        
        if (pointOpacityDefault) {
          newStyle.fillOpacity = parseFloat(pointOpacityDefault);
        } else {
          newStyle.fillOpacity = 0.8;
        }
        
        if (pointBorderWidthDefault) {
          newStyle.weight = parseFloat(pointBorderWidthDefault);
        } else {
          newStyle.weight = 1;
        }
        
        if (pointBorderColorDefault) {
          newStyle.color = pointBorderColorDefault;
        } else {
          newStyle.color = '#000000';
        }
        
        // Aplicar forma específica
        if (pointShapeDefault && pointShapeDefault !== 'circle') {
          newStyle.shape = pointShapeDefault;
        }
        
        console.log('🎯 Estilo padrão aplicado ao ponto:', newStyle);
        featureLayer.setStyle(newStyle);
      }
    });
  }
}

/**
 * Aplica ícones temáticos se configurados
 */
function applyThematicIcons() {
  const savedSettings = localStorage.getItem(`icon_settings_${layerId}`);
  if (!savedSettings) return;
  
  try {
    const iconSettings = JSON.parse(savedSettings);
    
    if (iconSettings.category && iconSettings.iconType) {
      console.log('🎨 Aplicando ícones temáticos:', iconSettings);
      
      currentLayer.eachLayer(featureLayer => {
        if (featureLayer.feature && featureLayer.feature.geometry?.type === 'Point') {
          const customIcon = createCustomIcon(iconSettings);
          if (customIcon) {
            featureLayer.setIcon(customIcon);
          }
        }
      });
    }
  } catch (error) {
    console.error('❌ Erro ao aplicar ícones temáticos:', error);
  }
}

/**
 * Mostrar notificação para o usuário
 */
function showNotification(message, type = 'info') {
  // Criar elemento de notificação
  const notification = document.createElement('div');
  notification.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
  notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
  notification.innerHTML = `
    ${message}
    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
  `;
  
  // Adicionar ao body
  document.body.appendChild(notification);
  
  // Remover automaticamente após 5 segundos
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 5000);
}

// Carregar configurações de ícone quando a página carregar
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(() => {
    loadIconSettings();
  }, 1000);
  
  // Configurar event listeners para atualização automática do mapa
  setupSymbologyEventListeners();
});

/**
 * Configura event listeners para todos os controles de simbologia
 */
function setupSymbologyEventListeners() {
  console.log('🎯 Configurando event listeners para simbologia...');
  
  // Event listeners para controles básicos
  const basicControls = [
    'style-type', 'geom-type', 'field-select', 'classes-input', 'method-select',
    'palette-select', 'palette-opacity', 'border-color', 'border-width'
  ];
  
  basicControls.forEach(controlId => {
    const control = document.getElementById(controlId);
    if (control) {
      control.addEventListener('change', function() {
        console.log(`🔄 Controle ${controlId} alterado, atualizando mapa...`);
        setTimeout(() => forceMapUpdate(), 100);
      });
    }
  });
  
  // Event listeners para controles de cor
  const colorControls = [
    'fill-color', 'stroke-color', 'label-color', 'label-buffer-color'
  ];
  
  colorControls.forEach(controlId => {
    const control = document.getElementById(controlId);
    if (control) {
      control.addEventListener('change', function() {
        console.log(`🎨 Cor ${controlId} alterada, atualizando mapa...`);
        setTimeout(() => forceMapUpdate(), 100);
      });
    }
  });
  
  // Event listeners para sliders
  const sliderControls = [
    'fill-opacity', 'stroke-weight', 'label-size', 'label-buffer-size'
  ];
  
  sliderControls.forEach(controlId => {
    const control = document.getElementById(controlId);
    if (control) {
      control.addEventListener('input', function() {
        console.log(`📏 Slider ${controlId} alterado, atualizando mapa...`);
        setTimeout(() => forceMapUpdate(), 100);
      });
    }
  });
  
  // Event listeners para controles específicos de ponto
  const pointControls = [
    'point-radius-default', 'point-opacity-default', 'point-shape-default',
    'point-border-width-default', 'point-border-color-default', 'point-shadow-default'
  ];
  
  pointControls.forEach(controlId => {
    const control = document.getElementById(controlId);
    if (control) {
      control.addEventListener('change', function() {
        console.log(`🎯 Controle de ponto ${controlId} alterado, atualizando mapa...`);
        setTimeout(() => forceMapUpdate(), 100);
      });
    }
  });
  
  // Event listeners para controles específicos de linha
  const lineControls = [
    'line-weight-default', 'line-opacity-default', 'line-style-default',
    'line-spacing-default', 'line-cap', 'line-join'
  ];
  
  lineControls.forEach(controlId => {
    const control = document.getElementById(controlId);
    if (control) {
      control.addEventListener('change', function() {
        console.log(`📏 Controle de linha ${controlId} alterado, atualizando mapa...`);
        setTimeout(() => forceMapUpdate(), 100);
      });
    }
  });
  
  // Event listeners para toggles
  const toggleControls = [
    'proportional-size-toggle', 'proportional-point-size-toggle',
    'composite-legend-toggle', 'class-invert'
  ];
  
  toggleControls.forEach(controlId => {
    const control = document.getElementById(controlId);
    if (control) {
      control.addEventListener('change', function() {
        console.log(`🔄 Toggle ${controlId} alterado, atualizando mapa...`);
        setTimeout(() => forceMapUpdate(), 100);
      });
    }
  });
  
  // Event listeners para controles de tamanho proporcional
  const proportionalControls = [
    'min-line-weight', 'max-line-weight', 'min-point-radius', 'max-point-radius'
  ];
  
  proportionalControls.forEach(controlId => {
    const control = document.getElementById(controlId);
    if (control) {
      control.addEventListener('input', function() {
        console.log(`⚖️ Controle proporcional ${controlId} alterado, atualizando mapa...`);
        setTimeout(() => forceMapUpdate(), 100);
      });
    }
  });
  
  // Event listeners para controles de rótulos
  const labelControls = [
    'labels-enabled', 'label-field-select', 'label-font', 'label-size',
    'label-color', 'label-bold', 'label-italic'
  ];
  
  labelControls.forEach(controlId => {
    const control = document.getElementById(controlId);
    if (control) {
      control.addEventListener('change', function() {
        console.log(`🏷️ Controle de rótulo ${controlId} alterado, atualizando mapa...`);
        setTimeout(() => forceMapUpdate(), 100);
      });
    }
  });
  
  console.log('✅ Event listeners para simbologia configurados com sucesso');
  
  // Configurar observer para mudanças na interface de categorias
  setupCategoryChangeObserver();
}

/**
 * Configura observer para detectar mudanças nas categorias
 */
function setupCategoryChangeObserver() {
  console.log('👁️ Configurando observer para mudanças nas categorias...');
  
  // Observer para mudanças na lista de categorias
  const categoryList = document.getElementById('category-list');
  if (categoryList) {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'childList' || mutation.type === 'attributes') {
          console.log('🔄 Mudança detectada nas categorias, atualizando mapa...');
          setTimeout(() => forceMapUpdate(), 100);
        }
      });
    });
    
    observer.observe(categoryList, {
      childList: true,
      attributes: true,
      subtree: true
    });
    
    console.log('✅ Observer para categorias configurado');
  }
  
  // Observer para mudanças na lista de classes graduadas
  const graduatedClassesList = document.getElementById('graduated-classes-list');
  if (graduatedClassesList) {
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'childList' || mutation.type === 'attributes') {
          console.log('🔄 Mudança detectada nas classes graduadas, atualizando mapa...');
          setTimeout(() => forceMapUpdate(), 100);
        }
      });
    });
    
    observer.observe(graduatedClassesList, {
      childList: true,
      attributes: true,
      subtree: true
    });
    
    console.log('✅ Observer para classes graduadas configurado');
  }
}
</script>

{% endblock %}